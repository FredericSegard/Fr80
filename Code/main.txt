Sections:
00: "seg0" (0-8000)
01: "seg8000" (8000-FD00)
02: "segfd00" (FD00-FE00)
03: "segfe00" (FE00-FF00)
04: "segff00" (FF00-FFFF)


Source: "main.asm"
                        	     1: ; --------------------------------------------------------------------------------------------------------------
                        	     2: ;         :::::::::     ::::::::       :::::::            :::::::::     :::::::::::     ::::::::       :::::::: 
                        	     3: ;             :+:     :+:    :+:     :+:   :+:           :+:    :+:        :+:        :+:    :+:     :+:    :+: 
                        	     4: ;           +:+      +:+    +:+     +:+   +:+           +:+    +:+        +:+        +:+    +:+     +:+         
                        	     5: ;         +#+        +#++:++#      +#+   +:+           +#++:++#+         +#+        +#+    +:+     +#++:++#++   
                        	     6: ;       +#+        +#+    +#+     +#+   +#+           +#+    +#+        +#+        +#+    +#+            +#+    
                        	     7: ;     #+#         #+#    #+#     #+#   #+#           #+#    #+#        #+#        #+#    #+#     #+#    #+#     
                        	     8: ;   #########     ########       #######            #########     ###########     ########       ########       
                        	     9: ; ------------------------------------------------------------------------------------------------------
                        	    10: 
                        	    11: ; *********************************************************************************************************************
                        	    12: ; * Z80 Project, code nema Fre80 (Freddy) by Frédéric Segard, a.k.a. MicroHobbyist
                        	    13: ; * https://www.youtube.com/@microhobbyist
                        	    14: ; * https://github.com/FredericSegard
                        	    15: ; *
                        	    16: ; * Copyright (C) 2023 Frédéric Segard
                        	    17: ; *
                        	    18: ; * This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General
                        	    19: ; * Public License as published by the Free Software Foundation. You can use all or part of the code, regardless of
                        	    20: ; * the version. But there is no warrenty of any kind.
                        	    21: ; *
                        	    22: ; * Reference:	ASCII text: https://www.messletters.com/en/big-text/ (alligator, standard)
                        	    23: ; *				Editor tab-stops set to 4
                        	    24: ; *				Assembler: VASM  (BIN: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fbin -o %1.out -L %1.txt)
                        	    25: ; *								 (HEX: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fihex)
                        	    26: ; * Version 0.7
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: 
                        	    30: ;   ____                         _                     _         
                        	    31: ;  / ___|   ___    _ __    ___  | |_    __ _   _ __   | |_   ___ 
                        	    32: ; | |      / _ \  | '_ \  / __| | __|  / _` | | '_ \  | __| / __|
                        	    33: ; | |___  | (_) | | | | | \__ \ | |_  | (_| | | | | | | |_  \__ \
                        	    34: ;  \____|  \___/  |_| |_| |___/  \__|  \__,_| |_| |_|  \__| |___/
                        	    35: ;
                        	    36: ; ---------------------------------------------------------------------------------------------------------------------
                        	    37: ; VARIOUS CONSTANTS AND ADDRESSES USED IN THE CODE
                        	    38: 
                        	    39: ; GENERAL EQUATES
                        	    40: NULL			= 0x00
                        	    41: CTRLC			= 0x03				; Control-C (Break)
                        	    42: CTRLG			= 0x07				; Control-G (Bell)
                        	    43: BKSP			= 0x08				; Backspace
                        	    44: TAB				= 0x09				; Horizontal tab
                        	    45: LF				= 0x0A				; Line-feed character
                        	    46: CS				= 0x0C				; Clear Screen
                        	    47: CR				= 0x0D				; Carriage-return character
                        	    48: CTRLO			= 0x0F				; Control "O"
                        	    49: CTRLQ			= 0x11				; Control "Q"
                        	    50: CTRLR			= 0x12				; Control "R"
                        	    51: CTRLS			= 0x13				; Control "S"
                        	    52: CTRLU			= 0x15				; Control "U"
                        	    53: ESC				= 0x1B				; Escape
                        	    54: SPACE			= 0x20				; Space character
                        	    55: DEL				= 0x7F				; Delete
                        	    56: 
                        	    57: DELIMITER		= " "				; Space delimiter between command line parameters
                        	    58: ERRORPTR		= "^"				; Error pointer symbol (used for pointing to the error position on command line)
                        	    59: QUOTE			= 0x22
                        	    60: JUMP			= 0xC3				; Delimiter for command list items (It's the actual jp command opcode)
                        	    61: HELP			= 0x0F
                        	    62: EOT				= 0xFF				; End of table
                        	    63: 
                        	    64: ;PARAMETERS
                        	    65: HorizTextRes	= 40				; Horizontal text resolution (40 or 80)
                        	    66: VertTextRes		= 24				; Vertical text resolution (typical 24 or 25)
                        	    67: ErrorPtrOffset	= 9					; Take into account the command prompt width
                        	    68: BytesFree		= (VectorTable-EndOfCode)+(StartOfCode-InterruptVectorEnd)	; Base free bytes
                        	    69: 
                        	    70: ; I/O ADDRESSES
                        	    71: SIO_PortA_Data	= 0x04				; SIO data port A
                        	    72: SIO_PortB_Data	= 0x05				; SIO data port B
                        	    73: SIO_PortA_Ctrl	= 0x06				; SIO control port A
                        	    74: SIO_PortB_Ctrl	= 0x07				; SIO control port B
                        	    75: 
                        	    76: BankSelect		= 0x30				; RAM bank select address (values (0x00 to 0xFF)
                        	    77: RomDisable		= 0x38				; ROM dissable address (any value)
                        	    78: 
                        	    79: ; STATUS INDICATOR FLAGS (BIT NUMBER... 3 and 5 are not used
                        	    80: Carry			= 0					; (F) Carry flag
                        	    81: Negative		= 1					; (N) Add/substract flag
                        	    82: Parity			= 2					; (P) Parity flag (Same bit position as bellow, depends on the instruction)
                        	    83: Overflow		= 2					; (V) Overflow flag (Same bit position as above, depends on the instruction)
                        	    84: HalfCarry		= 4					; (H) Half-carry flag
                        	    85: Zero			= 6					; (Z) Zero flag
                        	    86: Sign			= 7					; (S) Sign flag
                        	    87: 
                        	    88: 
                        	    89: ;  ___           _                                          _    __     __                _                        
                        	    90: ; |_ _|  _ __   | |_    ___   _ __   _ __   _   _   _ __   | |_  \ \   / /   ___    ___  | |_    ___    _ __   ___ 
                        	    91: ;  | |  | '_ \  | __|  / _ \ | '__| | '__| | | | | | '_ \  | __|  \ \ / /   / _ \  / __| | __|  / _ \  | '__| / __|
                        	    92: ;  | |  | | | | | |_  |  __/ | |    | |    | |_| | | |_) | | |_    \ V /   |  __/ | (__  | |_  | (_) | | |    \__ \
                        	    93: ; |___| |_| |_|  \__|  \___| |_|    |_|     \__,_| | .__/   \__|    \_/     \___|  \___|  \__|  \___/  |_|    |___/
                        	    94: ;                                                  |_|                                                             
                        	    95: ; ---------------------------------------------------------------------------------------------------------------------
                        	    96: ; RESET AND INTERRUPT VECTORS (8-BYTE VECTORS EACH)
                        	    97: 
                        	    98: 	.org	0x0000
                        	    99: 	
                        	   100: RST00:								; Reset vector 0: Standard boot up reset vector
00:0000 C38000          	   101: 	jp		ShadowCopy				; Shadow copy BIOS and vectors
00:0003 FF              	   102: 	ds		0x0008-$,0xFF
00:0004 *
                        	   103: 
                        	   104: RST08:								; Reset Vector 1
00:0008 76              	   105: 	halt
00:0009 FF              	   106: 	ds		0x0010-$,0xFF
00:000A *
                        	   107: 
                        	   108: RST10:								; Reset Vector 2
00:0010 76              	   109: 	halt
00:0011 FF              	   110: 	ds		0x0018-$,0xFF
00:0012 *
                        	   111: 	
                        	   112: RST18:								; Reset Vector 3
00:0018 76              	   113: 	halt
00:0019 FF              	   114: 	ds		0x0020-$,0xFF
00:001A *
                        	   115: 
                        	   116: RST20:								; Reset Vector 4
00:0020 76              	   117: 	halt
00:0021 FF              	   118: 	ds		0x0028-$,0xFF
00:0022 *
                        	   119: 
                        	   120: RST28:								; Reset Vector 5
00:0028 76              	   121: 	halt
00:0029 FF              	   122: 	ds		0x0030-$,0xFF
00:002A *
                        	   123: 
                        	   124: RST30:								; Reset Vector 6
00:0030 76              	   125: 	halt
00:0031 FF              	   126: 	ds		0x0038-$,0xFF
00:0032 *
                        	   127: 
                        	   128: RST38:								; Reset vector 7: Interrupt Mode 1
00:0038 76              	   129: 	halt
00:0039 FF              	   130: 	ds		0x0066-$,0xFF
00:003A *
                        	   131: 
                        	   132: NMI66:								; Non-masquable interreupt vector
00:0066 76              	   133: 	halt
00:0067 FF              	   134: 	ds		0x0080-$,0xFF
00:0068 *
                        	   135: 
                        	   136: InterruptVectorEnd:
                        	   137: 
                        	   138: 
                        	   139: ;  ____    _                   _                         ____                         
                        	   140: ; / ___|  | |__     __ _    __| |   ___   __      __    / ___|   ___    _ __    _   _ 
                        	   141: ; \___ \  | '_ \   / _` |  / _` |  / _ \  \ \ /\ / /   | |      / _ \  | '_ \  | | | |
                        	   142: ;  ___) | | | | | | (_| | | (_| | | (_) |  \ V  V /    | |___  | (_) | | |_) | | |_| |
                        	   143: ; |____/  |_| |_|  \__,_|  \__,_|  \___/    \_/\_/      \____|  \___/  | .__/   \__, |
                        	   144: ;                                                                      |_|      |___/ 
                        	   145: ; ---------------------------------------------------------------------------------------------------------------------
                        	   146: ; SHADOW COPY VECTORS AND BIOS FROM FLASH TO RAM
                        	   147: 
                        	   148: ShadowCopy:
00:0080 F3              	   149: 	di								; Disable interrupts
                        	   150: 	
                        	   151: ; COPY INTERRUPT VECTORS TO ALL BANKS
00:0081 3E0E            	   152: 	ld		A,0x0E					; Starting bank number
                        	   153: BankCopyLoop:						; Loop to copy reset vectors to all banks
00:0083 D330            	   154: 	out		(BankSelect),A			; Sets bank number to value in accumulator
                        	   155: 	; Perform vector copy
00:0085 210000          	   156: 	ld      HL,0x0000				; Set start at address 0x0000 (ROM)
00:0088 110000          	   157: 	ld      DE,0x0000				; Set destination address (RAM)
00:008B 018000          	   158: 	ld      BC,InterruptVectorEnd	; Set counter to copy the interrupt vector table only
00:008E EDB0            	   159: 	ldir							; Copy, paste, and repeat, until the end of BC has been reached
                        	   160: 	; Check for next iteration
00:0090 3D              	   161: 	dec		A						; Decrement accumulator to move on to next bank
00:0091 FEFF            	   162: 	cp		0xFF						; Has accumulator reached the end of the loop (past zero)?
00:0093 20EE            	   163: 	jr		nz,BankCopyLoop			; If not then do next bank the loop, else Bank 0 is already pre-selected
00:0095 32B8B0          	   164: 	ld		(CurrentBank),A			; Save Current Bank
                        	   165: 
                        	   166: ; COPY THE BIOS TO RAM
                        	   167: ROMCopy:
00:0098 210080          	   168:     ld      HL,StartOfCode			; Source address
00:009B 110080          	   169:     ld      DE,StartOfCode			; Destination address
00:009E 01E030          	   170:     ld      BC,EndOfCode-StartOfCode; Bytes to copy
00:00A1 EDB0            	   171:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   172: 
                        	   173: ; COPY THE VECTORS AND BLANK STACK TO RAM
                        	   174: VectorCopy:
00:00A3 2100FD          	   175:     ld      HL,VectorTable			; Source address
00:00A6 1100FD          	   176:     ld      DE,VectorTable			; Destination address
00:00A9 01FF02          	   177:     ld      BC,0xFFFF-VectorTable	; Bytes to copy
00:00AC EDB0            	   178:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   179: 
00:00AE C30080          	   180: 	jp		StartOfCode
                        	   181: 
00:00B1 FF              	   182: 	ds		StartOfCode-$,0xFF		; Fill the rest of memory to start of code with 0xFF for fast FLASH programming
00:00B2 *
                        	   183: 
                        	   184: 
                        	   185: ;  ___           _   _     _           _   _              
                        	   186: ; |_ _|  _ __   (_) | |_  (_)   __ _  | | (_)  ____   ___ 
                        	   187: ;  | |  | '_ \  | | | __| | |  / _` | | | | | |_  /  / _ \
                        	   188: ;  | |  | | | | | | | |_  | | | (_| | | | | |  / /  |  __/
                        	   189: ; |___| |_| |_| |_|  \__| |_|  \__,_| |_| |_| /___|  \___|
                        	   190: ;
                        	   191: ; ---------------------------------------------------------------------------------------------------------------------
                        	   192: ; START OF CODE
                        	   193: 
                        	   194: 	.org	0x8000					; Start of code at beginning of high memory
                        	   195: 
                        	   196: StartOfCode:
01:8000 3E00            	   197: 	ld		A,0
01:8002 D338            	   198: 	out		(RomDisable),A			; Disable the ROM
01:8004 31FFFF          	   199: 	ld      SP,0xFFFF				; Set top of stack pointer to page FF
                        	   200: 	
01:8007 CD4D81          	   201: 	call	SIO_Init				; Initializes the SIO
                        	   202: 
                        	   203: 	; Print Boot message with bytes free
01:800A CDAC82          	   204: 	call	ClearScreen				; Clear the terminal screen (with ANSI codes)
01:800D 2135A8          	   205: 	ld		HL,BootMsg
01:8010 CDB080          	   206: 	call	PrintString				; Print first line of boot message
01:8013 CD8E80          	   207: 	call	PrintLine				; Print a separator line
01:8016 CDB080          	   208: 	call	PrintString				; Print second line of boot message
01:8019 E5              	   209: 	push	HL
01:801A 21A0CB          	   210: 	ld		HL,BytesFree			; Load the amount of bytes free
01:801D CD5A80          	   211: 	call	PrintDec
01:8020 E1              	   212: 	pop		HL
01:8021 CDB080          	   213: 	call	PrintString
                        	   214: 
01:8024 210000          	   215: 	ld		HL,0x0000				; Set default current address
01:8027 22B9B0          	   216: 	ld		(CurrentAddress),HL		; Save in CurrentAddress variable
01:802A 3E00            	   217: 	ld		A,0
01:802C D330            	   218: 	out		(BankSelect),A			; Set the bank to number 0
01:802E 32B8B0          	   219: 	ld		(CurrentBank),A			; Save the Current Bank
                        	   220: 
                        	   221: 	; Clear the registers
01:8031 3E00            	   222: 	ld		A,0
01:8033 010000          	   223: 	ld		BC,0
01:8036 110000          	   224: 	ld		DE,0
01:8039 210000          	   225: 	ld		HL,0
01:803C DD210000        	   226: 	ld		IX,0
01:8040 FD210000        	   227: 	ld		IY,0
01:8044 C5              	   228: 	push	BC						; LSB to clear the flag
01:8045 F1              	   229: 	pop		AF						; Clear flag
                        	   230: 
                        	   231: ;	ei								; Enable interrupts
                        	   232: 
                        	   233: 
                        	   234: ;  __  __           _         
                        	   235: ; |  \/  |   __ _  (_)  _ __  
                        	   236: ; | |\/| |  / _` | | | | '_ \ 
                        	   237: ; | |  | | | (_| | | | | | | |
                        	   238: ; |_|  |_|  \__,_| |_| |_| |_|
                        	   239: ;
                        	   240: ; ----------------------------
                        	   241: ; MAIN LOOP
                        	   242: 
                        	   243: Main:
01:8046 CDA588          	   244: 	call	CommandPrompt			; Print the command prompt (0000>)
                        	   245: 	
01:8049 C5              	   246: 	push	BC
01:804A E5              	   247: 	push	HL
                        	   248: 	
01:804B 061E            	   249: 	ld		B,30					; Set the maximum number of bytes to read
01:804D 218DB0          	   250: 	ld		HL,CommandBuffer		; Set the memory area to read the string to
01:8050 CDF080          	   251: 	call	ReadString				; Read a string from console (HL is the address of buffer, BC is character count)
                        	   252: 	
01:8053 E1              	   253: 	pop		HL
01:8054 C1              	   254: 	pop		BC
                        	   255: 	
01:8055 CD5A89          	   256: 	call	Parser					; Parse the entered command
                        	   257: 	
01:8058 18EC            	   258: 	jr		Main
                        	   259: 
                        	   260: 
                        	   261: ;  ____            _                              _     _                      
                        	   262: ; / ___|   _   _  | |__    _ __    ___    _   _  | |_  (_)  _ __     ___   ___ 
                        	   263: ; \___ \  | | | | | '_ \  | '__|  / _ \  | | | | | __| | | | '_ \   / _ \ / __|
                        	   264: ;  ___) | | |_| | | |_) | | |    | (_) | | |_| | | |_  | | | | | | |  __/ \__ \
                        	   265: ; |____/   \__,_| |_.__/  |_|     \___/   \__,_|  \__| |_| |_| |_|  \___| |___/
                        	   266: ;
                        	   267: ; ---------------------------------------------------------------------------------------------------------------------
                        	   268: ; ALL SUBROUTINES ARE EMBEDED IN VARIOUS INCLUDE FILES
                        	   269: 
                        	   270: 	.include	"io.asm"			; Input and output subroutines

Source: "io.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- PrintChar		[A ->]
                        	     4: ;	- PrintString	[HL ->]
                        	     5: ;	- PrintCRLF
                        	     6: ;	- PrintNibble	[A ->]
                        	     7: ;	- PrintByte		[A ->]
                        	     8: ;	- PrintWord		[HL ->]
                        	     9: ;	- ReadChar		[-> A]
                        	    10: ;	- ReadString	[HL ->]
                        	    11: ;	- ReadByte		[-> A]
                        	    12: ;	- ReadWord		[-> HL]
                        	    13: ;	- SIO_Init
                        	    14: 
                        	    15: 
                        	    16: ;  ____           _           _     ____                
                        	    17: ; |  _ \   _ __  (_)  _ __   | |_  |  _ \    ___    ___ 
                        	    18: ; | |_) | | '__| | | | '_ \  | __| | | | |  / _ \  / __|
                        	    19: ; |  __/  | |    | | | | | | | |_  | |_| | |  __/ | (__ 
                        	    20: ; |_|     |_|    |_| |_| |_|  \__| |____/   \___|  \___|
                        	    21: ;
                        	    22: ;
                        	    23: ; *********************************************************************************************************************
                        	    24: ; Prints a hex number to Decimal on the console
                        	    25: ;	- Input:	HL = 16-bit hex number
                        	    26: ;	- Ouput:	HL = Untouched 16-bit hex number
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: PrintDec:
01:805A E5              	    30: 	push	HL
01:805B CD0E82          	    31: 	call	Hex2Dec
01:805E CDB080          	    32: 	call	PrintString
01:8061 E1              	    33: 	pop		HL
01:8062 C9              	    34: 	ret
                        	    35: 
                        	    36: 
                        	    37: ;  ____           _           _     ____            _          
                        	    38: ; |  _ \   _ __  (_)  _ __   | |_  | __ )   _   _  | |_    ___ 
                        	    39: ; | |_) | | '__| | | | '_ \  | __| |  _ \  | | | | | __|  / _ \
                        	    40: ; |  __/  | |    | | | | | | | |_  | |_) | | |_| | | |_  |  __/
                        	    41: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__, |  \__|  \___|
                        	    42: ;                                           |___/              
                        	    43: ;
                        	    44: ; *********************************************************************************************************************
                        	    45: ; Prints a byte to the console
                        	    46: ;	- Input:	A (Byte to print)
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: PrintByte:
01:8063 F5              	    50: 	push	AF
01:8064 F5              	    51: 	push	AF
01:8065 CB3F            	    52: 	srl		A					; Push the uppermost nibble to the lower half
01:8067 CB3F            	    53: 	srl		A
01:8069 CB3F            	    54: 	srl		A
01:806B CB3F            	    55: 	srl		A
01:806D CDA080          	    56: 	call	PrintNibble			; Print the first nibble of the byte
01:8070 F1              	    57: 	pop		AF
01:8071 CDA080          	    58: 	call	PrintNibble			; Print the second nibble of the byte
01:8074 F1              	    59: 	pop		AF
01:8075 C9              	    60: 	ret
                        	    61: 
                        	    62: 
                        	    63: ;  ____           _           _      ____   _                    
                        	    64: ; |  _ \   _ __  (_)  _ __   | |_   / ___| | |__     __ _   _ __ 
                        	    65: ; | |_) | | '__| | | | '_ \  | __| | |     | '_ \   / _` | | '__|
                        	    66: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | (_| | | |   
                        	    67: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| |_|  \__,_| |_|   
                        	    68: ;
                        	    69: 
                        	    70: ; *********************************************************************************************************************
                        	    71: ; Print a character to the console
                        	    72: ;	- Input: A (Character to transmit)
                        	    73: ; *********************************************************************************************************************
                        	    74: 
                        	    75: PrintChar:
01:8076 F5              	    76: 	push	AF
                        	    77: PrintCharTxWait:
01:8077 DB06            	    78: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in accumulator
01:8079 E604            	    79: 	and		%00000100				; Isolate bit 2: TX Buffer Empty
01:807B 28FA            	    80: 	jr		z,PrintCharTxWait		; If it's busy, then wait
01:807D F1              	    81: 	pop		AF
01:807E D304            	    82: 	out		(SIO_PortA_Data),A		; Transmit the character in accumulator
01:8080 C9              	    83: 	ret
                        	    84: 
                        	    85: 
                        	    86: ;  ____           _           _      ____   ____    _       _____ 
                        	    87: ; |  _ \   _ __  (_)  _ __   | |_   / ___| |  _ \  | |     |  ___|
                        	    88: ; | |_) | | '__| | | | '_ \  | __| | |     | |_) | | |     | |_   
                        	    89: ; |  __/  | |    | | | | | | | |_  | |___  |  _ <  | |___  |  _|  
                        	    90: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| \_\ |_____| |_|    
                        	    91: 
                        	    92: 
                        	    93: ; *********************************************************************************************************************
                        	    94: ; Print a carriage-return and line-feed to serial port A
                        	    95: ; *********************************************************************************************************************
                        	    96: 
                        	    97: PrintCRLF:
01:8081 F5              	    98: 	push	AF
01:8082 3E0D            	    99: 	ld		A,CR
01:8084 CD7680          	   100: 	call	PrintChar				; Print carriage-return
01:8087 3E0A            	   101: 	ld		A,LF
01:8089 CD7680          	   102: 	call	PrintChar				; Print line-feed
01:808C F1              	   103: 	pop		AF
01:808D C9              	   104: 	ret
                        	   105: 
                        	   106: 
                        	   107: ;  ____           _           _     _       _                
                        	   108: ; |  _ \   _ __  (_)  _ __   | |_  | |     (_)  _ __     ___ 
                        	   109: ; | |_) | | '__| | | | '_ \  | __| | |     | | | '_ \   / _ \
                        	   110: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | | |  __/
                        	   111: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_| |_| |_|  \___|
                        	   112: 
                        	   113: 
                        	   114: ; *********************************************************************************************************************
                        	   115: ; Prints a line (the size of HorizTextRes)
                        	   116: ; *********************************************************************************************************************
                        	   117: 
                        	   118: PrintLine:
01:808E F5              	   119: 	push	AF
01:808F C5              	   120: 	push	BC
01:8090 3E28            	   121: 	ld		A,HorizTextRes			; Load the screen width constant
01:8092 47              	   122: 	ld		B,A						; Place it register B
01:8093 3E2D            	   123: 	ld		A,"-"					; Load the dash character
                        	   124: PrintLineLoop:
01:8095 CD7680          	   125: 	call	PrintChar				; Print the dash
01:8098 10FB            	   126: 	djnz	PrintLineLoop			; Decrement B, and loop until B is 0
01:809A CD8180          	   127: 	call	PrintCRLF				; Change line
01:809D C1              	   128: 	pop		BC
01:809E F1              	   129: 	pop		AF
01:809F C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____           _           _     _   _   _   _       _       _        
                        	   134: ; |  _ \   _ __  (_)  _ __   | |_  | \ | | (_) | |__   | |__   | |   ___ 
                        	   135: ; | |_) | | '__| | | | '_ \  | __| |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	   136: ; |  __/  | |    | | | | | | | |_  | |\  | | | | |_) | | |_) | | | |  __/
                        	   137: ; |_|     |_|    |_| |_| |_|  \__| |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	   138: 
                        	   139: 
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Prints a nibble to the console
                        	   142: ;	- Input:	A (LSB to print)
                        	   143: ; *********************************************************************************************************************
                        	   144: 
                        	   145: PrintNibble:
01:80A0 F5              	   146: 	push	AF
01:80A1 E60F            	   147: 	and		$0F						; Filter out MSB
01:80A3 C630            	   148: 	add     "0"						; Add ASCII character 0
01:80A5 FE3A            	   149: 	cp      "9"+1					; Is the value numeric values?
01:80A7 3802            	   150: 	jr		c,PrintNibbleEnd		; Yes, then exit with 0 through 9
01:80A9 C607            	   151: 	add     "A"-"9"-1				; No, then exit with A through F
                        	   152: PrintNibbleEnd:
01:80AB CD7680          	   153: 	call	PrintChar				; Print the nibble
01:80AE F1              	   154: 	pop		AF
01:80AF C9              	   155: 	ret
                        	   156: 	
                        	   157: 	
                        	   158: ;  ____           _           _     ____    _            _                 
                        	   159: ; |  _ \   _ __  (_)  _ __   | |_  / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   160: ; | |_) | | '__| | | | '_ \  | __| \___ \  | __| | '__| | | | '_ \   / _` |
                        	   161: ; |  __/  | |    | | | | | | | |_   ___) | | |_  | |    | | | | | | | (_| |
                        	   162: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   163: ;                                                                    |___/ 
                        	   164: ;
                        	   165: ; *********************************************************************************************************************
                        	   166: ; Prints a string to serial port A, until the null character is reached
                        	   167: ;	- Input:	HL = Address pointer of string to transmit
                        	   168: ;	- Output:	HL = Address pointer to the next character, past NULL (Practical for printing lines in between text)
                        	   169: ; *********************************************************************************************************************
                        	   170: 
                        	   171: PrintString:
01:80B0 F5              	   172: 	push	AF
                        	   173: PrintStringLoop:
01:80B1 7E              	   174: 	ld		A,(HL)					; Load character to print in accumulator
01:80B2 23              	   175: 	inc		HL						; Increment HL to next character to print
01:80B3 FE00            	   176: 	cp		0					; Is it the end of the string?
01:80B5 2805            	   177: 	jr		z,PrintStringEnd		; Yes, then exit routine
01:80B7 CD7680          	   178: 	call	PrintChar				; Print the character
01:80BA 18F5            	   179: 	jr		PrintStringLoop			; Repeat the loop until null character is reached
                        	   180: PrintStringEnd:
01:80BC F1              	   181: 	pop		AF
01:80BD C9              	   182: 	ret
                        	   183: 
                        	   184: 
                        	   185: ;  ____           _           _    __        __                     _ 
                        	   186: ; |  _ \   _ __  (_)  _ __   | |_  \ \      / /   ___    _ __    __| |
                        	   187: ; | |_) | | '__| | | | '_ \  | __|  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   188: ; |  __/  | |    | | | | | | | |_    \ V  V /   | (_) | | |    | (_| |
                        	   189: ; |_|     |_|    |_| |_| |_|  \__|    \_/\_/     \___/  |_|     \__,_|
                        	   190: 
                        	   191: 
                        	   192: ; *********************************************************************************************************************
                        	   193: ; Prints a 16-bit word (double-byte) to the console
                        	   194: ;	- Input: HL (Word to print)
                        	   195: ; *********************************************************************************************************************
                        	   196: 
                        	   197: PrintWord:
01:80BE F5              	   198: 	push	AF
01:80BF 7C              	   199: 	ld		A,H						; Get the first byte in accumulator
01:80C0 CD6380          	   200: 	call	PrintByte				; Print first byte
01:80C3 7D              	   201: 	ld		A,L						; Get the second byte in accumulator
01:80C4 CD6380          	   202: 	call	PrintByte				; Print second byte
01:80C7 F1              	   203: 	pop		AF
01:80C8 C9              	   204: 	ret
                        	   205: 
                        	   206: 
                        	   207: ;  ____                       _    ____   _                    
                        	   208: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __ 
                        	   209: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__|
                        	   210: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |   
                        	   211: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|   
                        	   212: 
                        	   213: 
                        	   214: ; *********************************************************************************************************************
                        	   215: ; Read a character from the console (waiting)
                        	   216: ;	- Output:	Character received in A
                        	   217: ; *********************************************************************************************************************
                        	   218: 
                        	   219: ReadChar:
01:80C9 DB06            	   220: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80CB E601            	   221: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80CD 28FA            	   222: 	jr		z,ReadChar				; If there's no character in buffer, loop until one is present
01:80CF DB04            	   223: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80D1 C9              	   224: 	ret
                        	   225: 
                        	   226: 
                        	   227: ;  ____                       _    ____   _                      _   _          __        __          _   _   
                        	   228: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __  | \ | |   ___   \ \      / /   __ _  (_) | |_ 
                        	   229: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__| |  \| |  / _ \   \ \ /\ / /   / _` | | | | __|
                        	   230: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |    | |\  | | (_) |   \ V  V /   | (_| | | | | |_ 
                        	   231: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|    |_| \_|  \___/     \_/\_/     \__,_| |_|  \__|
                        	   232: ;
                        	   233: ;
                        	   234: ; *********************************************************************************************************************
                        	   235: ; Read a character from the console if present (non-waiting)
                        	   236: ;	- Output:	Character in A if received.
                        	   237: ;				A = 0 if no character received.
                        	   238: ;				Z = not ready, NZ = has character
                        	   239: ; *********************************************************************************************************************
                        	   240: 
                        	   241: ReadCharNoWait:
01:80D2 DB06            	   242: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80D4 E601            	   243: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80D6 3E00            	   244: 	ld		A,$00					; Put nothing in A
01:80D8 C8              	   245: 	ret		z						; Return if not ready
01:80D9 DB04            	   246: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80DB B7              	   247: 	or		A						; Resets the carry flag (and zero)
01:80DC C9              	   248: 	ret
                        	   249: 
                        	   250: 
                        	   251: ;  ____                       _   ____            _          
                        	   252: ; |  _ \    ___    __ _    __| | | __ )   _   _  | |_    ___ 
                        	   253: ; | |_) |  / _ \  / _` |  / _` | |  _ \  | | | | | __|  / _ \
                        	   254: ; |  _ <  |  __/ | (_| | | (_| | | |_) | | |_| | | |_  |  __/
                        	   255: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__, |  \__|  \___|
                        	   256: ;                                         |___/              
                        	   257: ;
                        	   258: ; *********************************************************************************************************************
                        	   259: ; Read a byte (2 ASCII Hex characters) from the console (waiting)
                        	   260: ;	- Output: Byte received in A
                        	   261: ; *********************************************************************************************************************
                        	   262: 
                        	   263: ReadByte:
01:80DD E5              	   264: 	push	HL
01:80DE 21BCB0          	   265: 	ld		HL,DigitString			; Point to staging area to convert ASCII Characters to a byte
01:80E1 CDC980          	   266: 	call	ReadChar				; Read first character
01:80E4 77              	   267: 	ld		(HL),A					; Store it
01:80E5 23              	   268: 	inc		HL						; Point to the next cell
01:80E6 CDC980          	   269: 	call	ReadChar				; Read second character
01:80E9 77              	   270: 	ld		(HL),A					; Store it
01:80EA 2B              	   271: 	dec		HL						; Point back to the beginning
01:80EB CD8F81          	   272: 	call	Ascii2HexByte
01:80EE E1              	   273: 	pop		HL
01:80EF C9              	   274: 	ret
                        	   275: 
                        	   276: 
                        	   277: ;  ____                       _   ____    _            _                 
                        	   278: ; |  _ \    ___    __ _    __| | / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   279: ; | |_) |  / _ \  / _` |  / _` | \___ \  | __| | '__| | | | '_ \   / _` |
                        	   280: ; |  _ <  |  __/ | (_| | | (_| |  ___) | | |_  | |    | | | | | | | (_| |
                        	   281: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   282: ;                                                                  |___/ 
                        	   283: 
                        	   284: ; *********************************************************************************************************************
                        	   285: ; Read a string from console
                        	   286: ;	- Input:	HL = Points to the memory area to store string
                        	   287: ;				B = Bytes to count
                        	   288: ;	- Output:	HL = Points to the start of string
                        	   289: ; *********************************************************************************************************************
                        	   290: 
                        	   291: ReadString:
01:80F0 F5              	   292: 	push	AF
01:80F1 C5              	   293: 	push	BC
01:80F2 D5              	   294: 	push	DE
01:80F3 E5              	   295: 	push	HL						; Store the start position
                        	   296: 
01:80F4 0E00            	   297: 	ld		C,0						; Character counter initialized to zero
01:80F6 E5              	   298: 	push	HL						; Save HL's start position...
01:80F7 D1              	   299: 	pop		DE						; in DE for later use
                        	   300: ;	ld		HL,CommandBuffer		; Load CommandBuffer location in HL
                        	   301: 
                        	   302: ; READ A CHARACTER AND VALIDATE
                        	   303: ReadStringChar:	
01:80F8 CDC980          	   304: 	call	ReadChar				; Read a character from console
01:80FB FE08            	   305: 	cp		BKSP					; Is it the backspace?
01:80FD 281C            	   306: 	jr		z,ReadStringBS			; If it is, then erase last character
01:80FF FE1B            	   307: 	cp		ESC						; Is it the escape key?
01:8101 2831            	   308: 	jr		z,ReadStringESC			; If it is, then ignore whatever has been entered
01:8103 FE0D            	   309: 	cp		CR						; Is it the carriage return?
01:8105 282E            	   310: 	jr		z,ReadStringCR			; If it is, then end the routine
01:8107 FE80            	   311: 	cp		$80						; Is it a character above or equal to the ASCII value $80?
01:8109 30ED            	   312: 	jr		nc,ReadStringChar		; Loop to get a valid ASCII character
01:810B FE20            	   313: 	cp		$20						; Is it any other non-printable character?
01:810D 38E9            	   314: 	jr		c,ReadStringChar		; Loop to get a valid ASCII character
                        	   315: 
                        	   316: ; STORE THE CHARACTER IN THE BUFFER
                        	   317: ReadStringSave:
01:810F CD7680          	   318: 	call	PrintChar				; Echo typed character on screen
                        	   319: ;	call	UpperCase				; *** (Optional) *****************************
01:8112 77              	   320: 	ld		(HL),A					; Store character in memory
01:8113 23              	   321: 	inc		HL						; Increment buffer to next spot
01:8114 0C              	   322: 	inc		C						; Increment bytes counter
01:8115 78              	   323: 	ld		A,B						; Load total bytes to read in accumulator
01:8116 B9              	   324: 	cp		C						; Has the total number of characters been read?
01:8117 3802            	   325: 	jr		c,ReadStringBS			; If it was one too many characters, backspace
01:8119 18DD            	   326: 	jr		ReadStringChar			; Else, loop to get the next character
                        	   327: 
                        	   328: ReadStringBS:
01:811B 79              	   329: 	ld		A,C						; Load characther counter in accumulator
01:811C FE00            	   330: 	cp		0						; Are there any characters to erase?
01:811E CAF880          	   331: 	jp		z,ReadStringChar		; No, then go read another character
01:8121 0D              	   332: 	dec		C						; Else, decrement character counter by one
01:8122 2B              	   333: 	dec		HL						; And decrement buffer to previous spot
01:8123 3E08            	   334: 	ld		A,BKSP					; Erace character on screen...
01:8125 CD7680          	   335: 	call	PrintChar				; Go back one previous character
01:8128 3E20            	   336: 	ld		A," "					;
01:812A CD7680          	   337: 	call	PrintChar				; Overwrite the character with a space
01:812D 3E08            	   338: 	ld		A,BKSP					;
01:812F CD7680          	   339: 	call	PrintChar				; Then go back one character again
01:8132 18C4            	   340: 	jr		ReadStringChar			; Get the next character
                        	   341: 	
                        	   342: ReadStringESC:
01:8134 EB              	   343: 	ex		DE,HL					; Restore start position of HL
                        	   344: ;	ld		HL,CommandBuffer		; Point CommandBuffer to start
                        	   345: 
                        	   346: ReadStringCR:
01:8135 3600            	   347: 	ld		(HL),0					; Write NULL character in buffer to indicate end of string
01:8137 CD8180          	   348: 	call	PrintCRLF				; Change line
                        	   349: 	
01:813A E1              	   350: 	pop		HL						; Points to the start of the string
01:813B D1              	   351: 	pop		DE
01:813C C1              	   352: 	pop		BC
01:813D F1              	   353: 	pop		AF
01:813E C9              	   354: 	ret
                        	   355: 
                        	   356: 
                        	   357: ;  ____                       _  __        __                     _ 
                        	   358: ; |  _ \    ___    __ _    __| | \ \      / /   ___    _ __    __| |
                        	   359: ; | |_) |  / _ \  / _` |  / _` |  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   360: ; |  _ <  |  __/ | (_| | | (_| |   \ V  V /   | (_) | | |    | (_| |
                        	   361: ; |_| \_\  \___|  \__,_|  \__,_|    \_/\_/     \___/  |_|     \__,_|
                        	   362: 
                        	   363: 
                        	   364: ; *********************************************************************************************************************
                        	   365: ; Read a word (4 ASCII Hex characters) from the console (waiting)
                        	   366: ;	- Output: Word received in HL
                        	   367: ; *********************************************************************************************************************
                        	   368: 
                        	   369: ReadWord:
01:813F F5              	   370: 	push	AF
01:8140 CDDD80          	   371: 	call	ReadByte			; Read first byte (first and second ASCII character)
01:8143 67              	   372: 	ld		H,A					; Store the MSB
01:8144 CDDD80          	   373: 	call	ReadByte			; Read second byte (third and fourth ASCII character)
01:8147 6F              	   374: 	ld		L,A					; Store the LSB
01:8148 CDAE81          	   375: 	call	Ascii2HexWord		; Convert the ASCII characters to a word, result in BC
01:814B F1              	   376: 	pop		AF
01:814C C9              	   377: 	ret
                        	   378: 
                        	   379: 	
                        	   380: ;  ____    ___    ___            ___           _   _   
                        	   381: ; / ___|  |_ _|  / _ \          |_ _|  _ __   (_) | |_ 
                        	   382: ; \___ \   | |  | | | |          | |  | '_ \  | | | __|
                        	   383: ;  ___) |  | |  | |_| |          | |  | | | | | | | |_ 
                        	   384: ; |____/  |___|  \___/   _____  |___| |_| |_| |_|  \__|
                        	   385: ;                       |_____|                        
                        	   386: 
                        	   387: ; *********************************************************************************************************************
                        	   388: ; Initializes SIO port A
                        	   389: ;   - Destroys: AF, HL, BC (There's usually no need to save registers in the init stage)
                        	   390: ; *********************************************************************************************************************
                        	   391: 
                        	   392: SIO_Init:
01:814D 3E18            	   393: 	ld		A,%00011000				; Perform channel reset
01:814F D306            	   394: 	out		(SIO_PortA_Ctrl),A		; Requires four extra clock cycles for the SIO reset time
01:8151 00              	   395: 	nop
01:8152 3E04            	   396: 	ld		A,%00000100				; WR0: select register 4
01:8154 D306            	   397: 	out		(SIO_PortA_Ctrl),A
01:8156 3E44            	   398: 	ld		A,%01000100				; WR4: 1/16 (115200 @ 1.8432MHZ), 8-bit sync, 1 stop bit, no parity
01:8158 D306            	   399: 	out		(SIO_PortA_Ctrl),A
01:815A 3E03            	   400: 	ld		A,%00000011				; WR0: select register 3
01:815C D306            	   401: 	out		(SIO_PortA_Ctrl),A
01:815E 3EC1            	   402: 	ld		A,%11000001				; WR3: 8-bits/char, RX enabled
01:8160 D306            	   403: 	out		(SIO_PortA_Ctrl),A
01:8162 3E05            	   404: 	ld		A,%00000101				; WR0: select register 5
01:8164 D306            	   405: 	out		(SIO_PortA_Ctrl),A
01:8166 3E68            	   406: 	ld		A,%01101000				; WR5: DTR=0, 8-bits/char, TX enabled
01:8168 D306            	   407: 	out		(SIO_PortA_Ctrl),A
01:816A C9              	   408: 	ret
                        	   409: 

Source: "main.asm"
                        	   271: 	.include	"convert.asm"		; Convert and process data subroutines

Source: "convert.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- Ascii2HexNibble	[A -> A]
                        	     4: ;	- Ascii2HexByte		[HL -> A]
                        	     5: ;	- Ascii2HexWord		[HL -> BC]
                        	     6: ;	- UpperCase			[A -> A]
                        	     7: 
                        	     8: ; *********************************************************************************************************************
                        	     9: ; Converts a single decimal digit to BCD
                        	    10: ;	- Input:	A = Contains the ASCII character to convert to BCD
                        	    11: ;	- Output:	A = Contains the 4-bit BCD value in LSB
                        	    12: ;				Carry set if valid; Carry clear if error
                        	    13: ; *********************************************************************************************************************
                        	    14: 
                        	    15: Ascii2BcdDigit:
                        	    16: 
                        	    17: ;     _                   _   _   ____    _   _                 _   _   _   _       _       _        
                        	    18: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | \ | | (_) | |__   | |__   | |   ___ 
                        	    19: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	    20: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |\  | | | | |_) | | |_) | | | |  __/
                        	    21: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	    22: ;
                        	    23: 
                        	    24: ; *********************************************************************************************************************
                        	    25: ; Converts a single ASCII hex character to a nibble, and validate if it's ok
                        	    26: ;	- Input:	A = Contains the ASCII character to convert to hex value
                        	    27: ;	- Output:	A = Converted 4-bit value in LSB
                        	    28: ;				Carry set if valid; Carry clear if error
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: Ascii2HexNibble:
01:816B CDA182          	    32: 	call	UpperCase				; Convert a-f to uppercase
01:816E FE30            	    33: 	cp		"0"						; If it's anything bellow 0
01:8170 381B            	    34: 	jr		c,Ascii2HexNibbleErr	; Then indicate an error
01:8172 FE47            	    35: 	cp		"F"+1					; If it's anything above F
01:8174 3017            	    36: 	jr		nc,Ascii2HexNibbleErr	; Then indicate an error
01:8176 FE3A            	    37: 	cp		"9"+1					; Check if it's less then 9
01:8178 3806            	    38: 	jr		c,Ascii2HexNibbleOK		; Then it's a valid 0-9 digit
01:817A FE41            	    39: 	cp		"A"						; Check if it's above A
01:817C 3002            	    40: 	jr		nc,Ascii2HexNibbleOK	; Then it's a valid A-F hex digit
01:817E 180D            	    41: 	jr		Ascii2HexNibbleErr		; Else, anything in between is an error
                        	    42: 
                        	    43: Ascii2HexNibbleOK:
01:8180 D630            	    44: 	sub		$30						; Substract $30 to transform character 0-9 into a number
01:8182 FE0A            	    45: 	cp		9+1						; Is it a decimal 0-9 digit?
01:8184 3802            	    46: 	jr		c,Ascii2HexNibbleEnd	; If it's then return value it as is
01:8186 D607            	    47: 	sub		$07						; If not, then substract the alpha offset to get A-F
                        	    48: 
                        	    49: Ascii2HexNibbleEnd:
01:8188 CD5089          	    50: 	call	IncErrorPointer			; Increment command line error pointer
01:818B 37              	    51: 	scf								; Set carry flag
01:818C C9              	    52: 	ret
                        	    53: 
                        	    54: Ascii2HexNibbleErr:
01:818D B7              	    55: 	or		A						; Clear carry flag
01:818E C9              	    56: 	ret
                        	    57: 
                        	    58: 
                        	    59: ;     _                   _   _   ____    _   _                 ____            _          
                        	    60: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	    61: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	    62: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	    63: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	    64: ;                                                                       |___/              
                        	    65: ;
                        	    66: ; *********************************************************************************************************************
                        	    67: ; Converts a pair of ASCII hex characters to a byte and validate if it's ok
                        	    68: ;	- Input:	HL = Points to the two characters to convert
                        	    69: ;	- Output:	A = Converted 8-bit byte
                        	    70: ;				HL = points to the next position
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: Ascii2HexByte:
01:818F C5              	    75: 	push	BC
01:8190 7E              	    76: 	ld		A,(HL)
01:8191 23              	    77: 	inc		HL
01:8192 CD6B81          	    78: 	call	Ascii2HexNibble			; Convert the first character (MSB)
01:8195 3014            	    79: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:8197 CB27            	    80: 	sla		A						; Place result to the MSB position...
01:8199 CB27            	    81: 	sla		A						;	by shifting it 4 times to the left...
01:819B CB27            	    82: 	sla		A						;	and zeroing out the LSB in the process
01:819D CB27            	    83: 	sla		A						;
01:819F 47              	    84: 	ld		B,A						; Save resulting MSB
01:81A0 7E              	    85: 	ld		A,(HL)
01:81A1 23              	    86: 	inc		HL
01:81A2 CD6B81          	    87: 	call	Ascii2HexNibble			; Convert the second character (LSB)
01:81A5 3004            	    88: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:81A7 B0              	    89: 	or		B						; Merge MSB with LSB, result in A
01:81A8 C1              	    90: 	pop		BC
01:81A9 37              	    91: 	scf								; Set carry flag
01:81AA C9              	    92: 	ret
                        	    93: 
                        	    94: Ascii2HexByteErr:
01:81AB C1              	    95: 	pop		BC
01:81AC B7              	    96: 	or		A						; Clear carry flag
01:81AD C9              	    97: 	ret
                        	    98: 
                        	    99: 
                        	   100: ;     _                   _   _   ____    _   _                 ____            _          
                        	   101: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	   102: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	   103: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	   104: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	   105: ;                                                                       |___/              
                        	   106: ;
                        	   107: ; *********************************************************************************************************************
                        	   108: ; Converts four ASCII hex characters to a 16-bit word and validate if it's ok
                        	   109: ;	- Input:	HL = Points to the 4 characters to be converted
                        	   110: ;	- Output:	BC = Contains the 16-bit value
                        	   111: ;				HL = points to the next position
                        	   112: ;				Carry set if valid; Carry clear if error
                        	   113: ; *********************************************************************************************************************
                        	   114: 
                        	   115: Ascii2HexWord:
01:81AE F5              	   116: 	push	AF
01:81AF CD8F81          	   117: 	call	Ascii2HexByte			; Convert the upper 2 characters (MSB)
01:81B2 300A            	   118: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81B4 47              	   119: 	ld		B,A						; Save the MSB result to B
01:81B5 CD8F81          	   120: 	call	Ascii2HexByte			; Convert the lower 2 characters (LSB)
01:81B8 3004            	   121: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81BA 4F              	   122: 	ld		C,A						; Save the the LSB
01:81BB F1              	   123: 	pop		AF
01:81BC 37              	   124: 	scf								; Set carry flag
01:81BD C9              	   125: 	ret
                        	   126: 	
                        	   127: Ascii2HexWordErr:
01:81BE F1              	   128: 	pop		AF
01:81BF B7              	   129: 	or		A						; Clear carry flag
01:81C0 C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____                  ____    _   _               
                        	   134: ; |  _ \    ___    ___  |___ \  | | | |   ___  __  __
                        	   135: ; | | | |  / _ \  / __|   __) | | |_| |  / _ \ \ \/ /
                        	   136: ; | |_| | |  __/ | (__   / __/  |  _  | |  __/  >  < 
                        	   137: ; |____/   \___|  \___| |_____| |_| |_|  \___| /_/\_\
                        	   138: ;
                        	   139: ;
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Convert decimal digits in a string to a hex number
                        	   142: ;	- Input:	HL = Points to the string the decimal characters are
                        	   143: ;	- Output:	BC = 16-bit hex value
                        	   144: ;				HL = Points to the next position after the last decimal number
                        	   145: ; *********************************************************************************************************************
                        	   146: 
                        	   147: Dec2Hex:
01:81C1 F5              	   148: 	push	AF
01:81C2 D5              	   149: 	push	DE
                        	   150: 	
01:81C3 CD3D8B          	   151: 	call	SkipSpaces
01:81C6 EB              	   152: 	ex		DE,HL					; HL is normally processed for strings, but ADD requires HL in this routine
01:81C7 210000          	   153: 	ld		HL,0
                        	   154: Dec2HexLoop:		
01:81CA 1A              	   155: 	ld		A,(DE)					; HL is required for add, so DE is used to grab the string instead of HL
01:81CB FE00            	   156: 	cp		0
01:81CD 2829            	   157: 	jr		z,Dec2HexShuffleRegs
01:81CF FE20            	   158: 	cp		DELIMITER
01:81D1 2825            	   159: 	jr		z,Dec2HexShuffleRegs
                        	   160: 	
01:81D3 FE30            	   161: 	cp		"0"						; If it's anything bellow 0
01:81D5 382D            	   162: 	jr		c,Dec2HexInvalidDec		; Then indicate an error
01:81D7 FE3A            	   163: 	cp		"9"+1					; Check if it's less then 9
01:81D9 3029            	   164: 	jr		nc,Dec2HexInvalidDec	; Then indicate an error
                        	   165: 
01:81DB D630            	   166: 	sub		$30						; Convert ASCII decimal to BCD
01:81DD 13              	   167: 	inc		DE						; Increment buffer pointer
01:81DE CD5089          	   168: 	call	IncErrorPointer
                        	   169: 
01:81E1 E5              	   170: 	push	HL
01:81E2 C1              	   171: 	pop		BC
                        	   172: 
01:81E3 29              	   173: 	add		HL,HL
01:81E4 3818            	   174: 	jr		c,Dec2HexOutOfRange
01:81E6 29              	   175: 	add		HL,HL	
01:81E7 3815            	   176: 	jr		c,Dec2HexOutOfRange
01:81E9 09              	   177: 	add		HL,BC	
01:81EA 3812            	   178: 	jr		c,Dec2HexOutOfRange
01:81EC 29              	   179: 	add		HL,HL
01:81ED 380F            	   180: 	jr		c,Dec2HexOutOfRange
                        	   181: 	
01:81EF 85              	   182: 	add		L	
01:81F0 6F              	   183: 	ld		L,A	
01:81F1 30D7            	   184: 	jr		nc,Dec2HexLoop
01:81F3 24              	   185: 	inc		H
01:81F4 3808            	   186: 	jr		c,Dec2HexOutOfRange
01:81F6 18D2            	   187: 	jr		Dec2HexLoop
                        	   188: 
                        	   189: Dec2HexShuffleRegs:
01:81F8 E5              	   190: 	push	HL						; Push result in BC
01:81F9 C1              	   191: 	pop		BC						;
01:81FA EB              	   192: 	ex		DE,HL					; Place buffer pointer in HL
01:81FB 37              	   193: 	scf								; Set Carry
01:81FC 180D            	   194: 	jr		Dec2HexEnd
                        	   195: 
                        	   196: Dec2HexOutOfRange:
01:81FE CD6CB0          	   197: 	call	NumberOutOfRange
01:8201 B7              	   198: 	or		A
01:8202 1807            	   199: 	jr		Dec2HexEnd
                        	   200: 	
                        	   201: Dec2HexInvalidDec:
01:8204 CDC289          	   202: 	call	PrintErrorPointer
01:8207 CD75B0          	   203: 	call	InvalidDecimalNumber
01:820A B7              	   204: 	or		A
                        	   205: 	
                        	   206: Dec2HexEnd:
01:820B D1              	   207: 	pop		DE
01:820C F1              	   208: 	pop		AF
01:820D C9              	   209: 	ret
                        	   210: 
                        	   211: 
                        	   212: ;  _   _                 ____    ____                
                        	   213: ; | | | |   ___  __  __ |___ \  |  _ \    ___    ___ 
                        	   214: ; | |_| |  / _ \ \ \/ /   __) | | | | |  / _ \  / __|
                        	   215: ; |  _  | |  __/  >  <   / __/  | |_| | |  __/ | (__ 
                        	   216: ; |_| |_|  \___| /_/\_\ |_____| |____/   \___|  \___|
                        	   217: ;
                        	   218: ;
                        	   219: ; *********************************************************************************************************************
                        	   220: ; Convert a 16-bit a hex binary data to a decimal string
                        	   221: ;	- Input:	HL = 16-bit hex number
                        	   222: ;	- Output:	HL = Start of string pointer (DigitString variable) - Ends with null
                        	   223: ; *********************************************************************************************************************
                        	   224: ; B is the first non-zero flag, so as not to print leading zero's
                        	   225: 
                        	   226: Hex2Dec:
01:820E F5              	   227: 	push	AF
01:820F C5              	   228: 	push	BC
01:8210 D5              	   229: 	push	DE
01:8211 DDE5            	   230: 	push	IX
                        	   231: 
01:8213 0600            	   232: 	ld		B,0
01:8215 DD21BCB0        	   233: 	ld		IX,DigitString
                        	   234: Hex2Dec10000:
                        	   235: 	; CALCULATE THE 10,000's
01:8219 3EFF            	   236: 	ld		A,-1					; Start at -1
                        	   237: Hex2Dec10000Loop:
01:821B 3C              	   238: 	inc		A						; Add 1
01:821C B7              	   239: 	or		A						; Clear carry
01:821D 111027          	   240: 	ld		DE,10000
01:8220 ED52            	   241: 	sbc		HL,DE					; Substract 10,000
01:8222 30F7            	   242: 	jr		nc,Hex2Dec10000Loop		; Continue if not reached negative
01:8224 19              	   243: 	add		HL,DE					; Add 10,000 back to make it positive
01:8225 FE00            	   244: 	cp		0
01:8227 2002            	   245: 	jr		nz,Hex2Dec10000Set
01:8229 1809            	   246: 	jr		Hex2Dec1000				; If it's not set
                        	   247: Hex2Dec10000Set
01:822B CBC0            	   248: 	set		0,B
01:822D C630            	   249: 	add		$30
01:822F DD7700          	   250: 	ld		(IX),A
01:8232 DD23            	   251: 	inc		IX
                        	   252: 
                        	   253: 	; CALCULATE THE 1,000's
                        	   254: Hex2Dec1000:
01:8234 3EFF            	   255: 	ld		A,-1					; Start at -1
                        	   256: Hex2Dec1000Loop:
01:8236 3C              	   257: 	inc		A						; Add 1
01:8237 B7              	   258: 	or		A						; Clear carry
01:8238 11E803          	   259: 	ld		DE,1000
01:823B ED52            	   260: 	sbc		HL,DE					; Substract 1,000
01:823D 30F7            	   261: 	jr		nc,Hex2Dec1000Loop		; Continue if not reached negative
01:823F 19              	   262: 	add		HL,DE					; Add 1,000 back to make it positive
01:8240 FE00            	   263: 	cp		0
01:8242 2004            	   264: 	jr		nz,Hex2Dec1000Set
01:8244 CB40            	   265: 	bit		0,B						; Check the flag
01:8246 2809            	   266: 	jr		z,Hex2Dec100			; If it's not set
                        	   267: Hex2Dec1000Set
01:8248 CBC0            	   268: 	set		0,B						
01:824A C630            	   269: 	add		$30
01:824C DD7700          	   270: 	ld		(IX),A
01:824F DD23            	   271: 	inc		IX
                        	   272: 
                        	   273: 	; CALCULATE THE 100's
                        	   274: Hex2Dec100:
01:8251 3EFF            	   275: 	ld		A,-1					; Start at -1
                        	   276: Hex2Dec100Loop:
01:8253 3C              	   277: 	inc		A						; Add 1
01:8254 B7              	   278: 	or		A						; Clear carry
01:8255 116400          	   279: 	ld		DE,100
01:8258 ED52            	   280: 	sbc		HL,DE					; Substract 100
01:825A 30F7            	   281: 	jr		nc,Hex2Dec100Loop		; Continue if not reached negative
01:825C 19              	   282: 	add		HL,DE					; Add 100 back to make it positive
01:825D FE00            	   283: 	cp		0
01:825F 2004            	   284: 	jr		nz,Hex2Dec100Set
01:8261 CB40            	   285: 	bit		0,B						; Check the flag
01:8263 2809            	   286: 	jr		z,Hex2Dec10				; If it's not set
                        	   287: Hex2Dec100Set
01:8265 CBC0            	   288: 	set		0,B						
01:8267 C630            	   289: 	add		$30
01:8269 DD7700          	   290: 	ld		(IX),A
01:826C DD23            	   291: 	inc		IX
                        	   292: 
                        	   293: 
                        	   294: 	; CALCULATE THE 10's
                        	   295: Hex2Dec10:
01:826E 3EFF            	   296: 	ld		A,-1					; Start at -1
                        	   297: Hex2Dec10Loop:
01:8270 3C              	   298: 	inc		A						; Add 1
01:8271 B7              	   299: 	or		A						; Clear carry
01:8272 110A00          	   300: 	ld		DE,10
01:8275 ED52            	   301: 	sbc		HL,DE					; Substract 10
01:8277 30F7            	   302: 	jr		nc,Hex2Dec10Loop		; Continue if not reached negative
01:8279 19              	   303: 	add		HL,DE					; Add 10 back to make it positive
01:827A FE00            	   304: 	cp		0
01:827C 2004            	   305: 	jr		nz,Hex2Dec10Set
01:827E CB40            	   306: 	bit		0,B						; Check the flag
01:8280 2809            	   307: 	jr		z,Hex2Dec1				; If it's not set
                        	   308: Hex2Dec10Set
01:8282 CBC0            	   309: 	set		0,B						
01:8284 C630            	   310: 	add		$30
01:8286 DD7700          	   311: 	ld		(IX),A
01:8289 DD23            	   312: 	inc		IX
                        	   313: 
                        	   314: 	; STORE THE 1's
                        	   315: Hex2Dec1:
01:828B 7D              	   316: 	ld		A,L
01:828C C630            	   317: 	add		$30
01:828E DD7700          	   318: 	ld		(IX),A
01:8291 DD23            	   319: 	inc		IX
01:8293 3E00            	   320: 	ld		A,0
01:8295 DD7700          	   321: 	ld		(IX),A					; End string with null character
                        	   322: 	
                        	   323: Hex2DecEnd:
01:8298 21BCB0          	   324: 	ld		HL,DigitString			; Point to decimal string to output
                        	   325: 	
01:829B DDE1            	   326: 	pop		IX
01:829D D1              	   327: 	pop		DE
01:829E C1              	   328: 	pop		BC
01:829F F1              	   329: 	pop		AF
01:82A0 C9              	   330: 	ret
                        	   331: 
                        	   332: 
                        	   333: ;  _   _                                  ____                      
                        	   334: ; | | | |  _ __    _ __     ___   _ __   / ___|   __ _   ___    ___ 
                        	   335: ; | | | | | '_ \  | '_ \   / _ \ | '__| | |      / _` | / __|  / _ \
                        	   336: ; | |_| | | |_) | | |_) | |  __/ | |    | |___  | (_| | \__ \ |  __/
                        	   337: ;  \___/  | .__/  | .__/   \___| |_|     \____|  \__,_| |___/  \___|
                        	   338: ;         |_|     |_|                                               
                        	   339: ;
                        	   340: ; *********************************************************************************************************************
                        	   341: ; Converts a character to uppercase
                        	   342: ;	- INPUT:	A = Character to uppercase
                        	   343: ;	- OUTPUT:	A = Uppercased character
                        	   344: ; *********************************************************************************************************************
                        	   345: 
                        	   346: UpperCase:
01:82A1 FE61            	   347: 	cp		"a"						; Is the value less then lowercase a?
01:82A3 3806            	   348: 	jr		c,UpperCaseEnd			; If so, then end routine
01:82A5 FE7B            	   349: 	cp		"z"+1					; Is the value more then lowercase z?
01:82A7 3002            	   350: 	jr		nc,UpperCaseEnd			; If so, then end routine
01:82A9 D620            	   351: 	sub		32						; Substract the ASCII difference
                        	   352: UpperCaseEnd:
01:82AB C9              	   353: 	ret
                        	   354: 	

Source: "main.asm"
                        	   272: 	.include	"monitor.asm"		; Monitor command subroutines

Source: "monitor.asm"
                        	     1: ; Command routines in this include file:
                        	     2: ; --------------------------------------
                        	     3: ;	- ClearScreen					; {}
                        	     4: ;	- Diagnostics					; {}
                        	     5: ;	- Fill							; {SSSS EEEE BB}
                        	     6: ;	- HexDump 						; {AAAA LL}
                        	     7: ;	- IntelHex  					; {}
                        	     8: ;	- List  						; {}
                        	     9: ;	- Peek							; [AAAA]
                        	    10: ;	- Poke							; AAAA BB
                        	    11: ;	- Registers  					; {}
                        	    12: ;	- Run  							; {AAAA}
                        	    13: ;	- SetAddress					; [AAAA]
                        	    14: ;	- SetBank						; [N]
                        	    15: ;	- SysInfo 						; {}
                        	    16: ;	- Write							; AAAA BB [BB] [BB] [BB] [BB] [BB]
                        	    17: ;	- Zero							; {}
                        	    18: 
                        	    19: 
                        	    20: ;   ____   _                         ____                                      
                        	    21: ;  / ___| | |   ___    __ _   _ __  / ___|    ___   _ __    ___    ___   _ __  
                        	    22: ; | |     | |  / _ \  / _` | | '__| \___ \   / __| | '__|  / _ \  / _ \ | '_ \ 
                        	    23: ; | |___  | | |  __/ | (_| | | |     ___) | | (__  | |    |  __/ |  __/ | | | |
                        	    24: ;  \____| |_|  \___|  \__,_| |_|    |____/   \___| |_|     \___|  \___| |_| |_|
                        	    25: ;
                        	    26: 
                        	    27: ; *********************************************************************************************************************
                        	    28: ; ClearScreen: Clears the VT terminal screen
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: ClearScreen:
01:82AC E5              	    32: 	push	HL
01:82AD 21AAAB          	    33: 	ld		HL,ClearScreenSeq
01:82B0 CDB080          	    34: 	call	PrintString
01:82B3 E1              	    35: 	pop		HL
01:82B4 C9              	    36: 	ret
                        	    37: 
                        	    38: 
                        	    39: ;   ____                           ____    _                  _    
                        	    40: ;  / ___|   ___    _ __    _   _  | __ )  | |   ___     ___  | | __
                        	    41: ; | |      / _ \  | '_ \  | | | | |  _ \  | |  / _ \   / __| | |/ /
                        	    42: ; | |___  | (_) | | |_) | | |_| | | |_) | | | | (_) | | (__  |   < 
                        	    43: ;  \____|  \___/  | .__/   \__, | |____/  |_|  \___/   \___| |_|\_\
                        	    44: ;                 |_|      |___/
                        	    45: ;
                        	    46: ; *********************************************************************************************************************
                        	    47: ; Copy data from source to destination
                        	    48: ; - Input:	HL = Source address
                        	    49: ;			DE = Destination address
                        	    50: ;			BC = Number of bytes to move
                        	    51: ; *********************************************************************************************************************
                        	    52: 
                        	    53: CopyBlock:
01:82B5 F5              	    54: 	push	AF
01:82B6 C5              	    55: 	push	BC
01:82B7 D5              	    56: 	push	DE
01:82B8 E5              	    57: 	push	HL
                        	    58: 
01:82B9 2AB5B0          	    59: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	    60: 	
                        	    61: CopySourceAddress:
01:82BC CDCF88          	    62: 	call	GetHexParameter			; Get the first parameter, start address
01:82BF D21583          	    63: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82C2 FE00            	    64: 	cp		0						; Is there a first parameter?
01:82C4 2847            	    65: 	jr		z,CopyNoParameter		; No, then print error message
01:82C6 ED43D5B0        	    66: 	ld		(StartAddress),BC		; Save source address
                        	    67: 
                        	    68: CopyDestinationAddress:
01:82CA CDCF88          	    69: 	call	GetHexParameter			; Get the first parameter, start address
01:82CD D21583          	    70: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82D0 FE00            	    71: 	cp		0						; Is there a first parameter?
01:82D2 2839            	    72: 	jr		z,CopyNoParameter		; No, then print error message
01:82D4 ED43D7B0        	    73: 	ld		(EndAddress),BC			; Save destination address
                        	    74: 
                        	    75: CopyNumberOfBytes:
01:82D8 CDCF88          	    76: 	call	GetHexParameter			; Get the first parameter, start address
01:82DB D21583          	    77: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82DE FE00            	    78: 	cp		0						; Is there a first parameter?
01:82E0 282B            	    79: 	jr		z,CopyNoParameter		; No, then print error message
                        	    80: 
                        	    81: 	; Check if the number of bytes is zero
01:82E2 78              	    82: 	ld		A,B
01:82E3 B1              	    83: 	or		C
01:82E4 282C            	    84: 	jr		z,CopyNothing
                        	    85: 
01:82E6 2AD5B0          	    86: 	ld		HL,(StartAddress)		; Restore HL
                        	    87: 	
                        	    88: 	; Does destination area overlap source area?
01:82E9 ED5BD5B0        	    89: 	ld		DE,(StartAddress)
01:82ED 2AD7B0          	    90: 	ld		HL,(EndAddress)
01:82F0 B7              	    91: 	or		A						; Clear carry
01:82F1 ED52            	    92: 	sbc		HL,DE
01:82F3 B7              	    93: 	or		A						; Clear carry
01:82F4 ED42            	    94: 	sbc		HL,BC
01:82F6 2AD5B0          	    95: 	ld		HL,(StartAddress)
01:82F9 ED5BD7B0        	    96: 	ld		DE,(EndAddress)
01:82FD 300A            	    97: 	jr		nc,CopyNoOverlap
                        	    98: 	
                        	    99: 	; Destination overlaps, copy from highest address to avoid destroying data
01:82FF 09              	   100: 	add		HL,BC
01:8300 2B              	   101: 	dec		HL
01:8301 EB              	   102: 	ex		DE,HL
01:8302 09              	   103: 	add		HL,BC
01:8303 2B              	   104: 	dec		HL
01:8304 EB              	   105: 	ex		DE,HL
01:8305 EDB8            	   106: 	lddr
01:8307 180C            	   107: 	jr		CopyEnd
                        	   108: 
                        	   109: CopyNoOverlap:
01:8309 EDB0            	   110: 	ldir
01:830B 1808            	   111: 	jr		CopyEnd
                        	   112: 
                        	   113: CopyNoParameter:
01:830D CD45B0          	   114: 	call	NoParameter
01:8310 1803            	   115: 	jr		CopyEnd
                        	   116: 
                        	   117: CopyNothing:
01:8312 CD7EB0          	   118: 	call	NothingToCopy
                        	   119: 
                        	   120: CopyEnd:	
01:8315 E1              	   121: 	pop		HL
01:8316 D1              	   122: 	pop		DE
01:8317 C1              	   123: 	pop		BC
01:8318 F1              	   124: 	pop		AF
01:8319 C9              	   125: 	ret
                        	   126: 
                        	   127: 
                        	   128: ;  ____    _                                         _     _              
                        	   129: ; |  _ \  (_)   __ _    __ _   _ __     ___    ___  | |_  (_)   ___   ___ 
                        	   130: ; | | | | | |  / _` |  / _` | | '_ \   / _ \  / __| | __| | |  / __| / __|
                        	   131: ; | |_| | | | | (_| | | (_| | | | | | | (_) | \__ \ | |_  | | | (__  \__ \
                        	   132: ; |____/  |_|  \__,_|  \__, | |_| |_|  \___/  |___/  \__| |_|  \___| |___/
                        	   133: ;                      |___/                                              
                        	   134: ;
                        	   135: ;
                        	   136: ; *********************************************************************************************************************
                        	   137: ; Test system RAM, except the range of this routine
                        	   138: ; *********************************************************************************************************************
                        	   139: 
                        	   140: Diagnostics:
01:831A F5              	   141: 	push	AF
01:831B C5              	   142: 	push	BC
01:831C D5              	   143: 	push	DE
01:831D E5              	   144: 	push	HL
01:831E DDE5            	   145: 	push	IX
01:8320 FDE5            	   146: 	push	IY
                        	   147: 	
                        	   148: ; TEST BANK MEMORY
                        	   149: ; ----------------
01:8322 3E00            	   150: 	ld		A,0						; Set Bank number to 0
01:8324 FD210000        	   151: 	ld		IY,0
                        	   152: DiagnosticsBankLoop:
01:8328 2130AE          	   153: 	ld		HL,TestingBankNumberMsg
01:832B CDB080          	   154: 	call	PrintString
01:832E CDA080          	   155: 	call	PrintNibble
01:8331 CD8180          	   156: 	call	PrintCRLF
01:8334 DD210000        	   157: 	ld		IX,$0000				; Set start address
01:8338 21FF7F          	   158: 	ld		HL,$7FFF				; Set end address
01:833B D330            	   159: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:833D CD6383          	   160: 	call	DiagnosticsTest
01:8340 3C              	   161: 	inc		A
01:8341 FD6F            	   162: 	ld		IYL,A					; Save the bank number for error printing
01:8343 FE0F            	   163: 	cp		$F
01:8345 20E1            	   164: 	jr		nz,DiagnosticsBankLoop
                        	   165: 
                        	   166: ; TEST HIGH MEMORY (BETWEEN START OF BIOS AND START OF DIAG CODE)
                        	   167: ; ---------------------------------------------------------------
01:8347 2143AE          	   168: 	ld		HL,TestingHighRamMsg
01:834A CDB080          	   169: 	call	PrintString
01:834D DD210080        	   170: 	ld		IX,$8000				; Set start address
01:8351 216383          	   171: 	ld		HL,DiagnosticsTest		; Set end address
01:8354 CD6383          	   172: 	call	DiagnosticsTest
                        	   173: 
                        	   174: ; TEST HIGH MEMORY (AFTER DIAG CODE TILL THE END)
                        	   175: ; -----------------------------------------------
01:8357 DD21D183        	   176: 	ld		IX,DiagnosticsEnd		; Set start address
01:835B 21FFFF          	   177: 	ld		HL,$FFFF				; Set end address
01:835E CD6383          	   178: 	call	DiagnosticsTest
                        	   179: 
01:8361 186E            	   180: 	jr		DiagnosticsEnd
                        	   181: 
                        	   182: ; ACTUAL MEMORY TEST SUBROUTINE WITHN THE SUBROUTINE
                        	   183: ; --------------------------------------------------
                        	   184: DiagnosticsTest:	
01:8363 F5              	   185: 	push	AF
                        	   186: 	
01:8364 DD2B            	   187: 	dec		IX						; Start with one less, since the increment starts at the start of the loop
                        	   188: DiagnosticsTestLoop:
01:8366 DD23            	   189: 	inc		IX						; Increment address pointer
01:8368 DD4600          	   190: 	ld		B,(IX)					; Save the original byte in B
                        	   191: 	
                        	   192: 	; Write pattern 55
01:836B 3E55            	   193: 	ld		A,$55					; Use $55 as the first pattern value
01:836D DD7700          	   194: 	ld		(IX),A					; Write it to the memory location
01:8370 4F              	   195: 	ld		C,A						; Save expected byte for error messages
01:8371 DD7E00          	   196: 	ld		A,(IX)					; Read from same memory location
01:8374 FE55            	   197: 	cp		$55						; Compare if the it's the same
01:8376 C49783          	   198: 	call	nz,DiagMemoryError
                        	   199: 
                        	   200: 	; Write pattern AA
01:8379 3EAA            	   201: 	ld		A,$AA					; Use $55 as the first pattern value
01:837B DD7700          	   202: 	ld		(IX),A					; Write it to the memory location
01:837E 4F              	   203: 	ld		C,A						; Save expected byte for error messages
01:837F DD7E00          	   204: 	ld		A,(IX)					; Read from same memory location
01:8382 FEAA            	   205: 	cp		$AA						; Compare if the it's the same
01:8384 C49783          	   206: 	call	nz,DiagMemoryError
                        	   207: 
01:8387 DD7000          	   208: 	ld		(IX),B					; Attempt to save the original value back in it's original place
                        	   209: 	
                        	   210: 	; Check for end of range
01:838A DDE5            	   211: 	push	IX
01:838C D1              	   212: 	pop		DE
01:838D B7              	   213: 	or		A						; Clear carry flag
01:838E E5              	   214: 	push	HL
01:838F ED52            	   215: 	sbc		HL,DE					; HL = HL - DE
01:8391 E1              	   216: 	pop		HL
01:8392 C26683          	   217: 	jp		nz,DiagnosticsTestLoop	; If reached the end of range, exit
                        	   218: 
01:8395 F1              	   219: 	pop		AF
01:8396 C9              	   220: 	ret
                        	   221: 
                        	   222: ; PRINT ERROR MESSAGE IF MEMORY IS BAD
                        	   223: ; ------------------------------------
                        	   224: DiagMemoryError:
01:8397 F5              	   225: 	push	AF
01:8398 E5              	   226: 	push	HL
                        	   227: 
                        	   228: 	; Print "Error at"
01:8399 2101AE          	   229: 	ld		HL,BadMemory1Err
01:839C CDB080          	   230: 	call	PrintString
                        	   231: 	
                        	   232: 	; Print bank number it it's in low memory
01:839F F5              	   233: 	push	AF
01:83A0 FD7D            	   234: 	ld		A,IYL
01:83A2 FE0F            	   235: 	cp		$0F
01:83A4 3008            	   236: 	jr		nc,DiagMemoryAddr
01:83A6 CDA080          	   237: 	call	PrintNibble
01:83A9 3E3A            	   238: 	ld		A,":"
01:83AB CD7680          	   239: 	call	PrintChar
                        	   240: 	
                        	   241: 	; Print address of error
                        	   242: DiagMemoryAddr
01:83AE F1              	   243: 	pop		AF
01:83AF DDE5            	   244: 	push	IX
01:83B1 E1              	   245: 	pop		HL
01:83B2 CDBE80          	   246: 	call	PrintWord
                        	   247: 	
                        	   248: 	; Print "got"
01:83B5 210BAE          	   249: 	ld		HL,BadMemory2Err
01:83B8 CDB080          	   250: 	call	PrintString
                        	   251: 	
                        	   252: 	; Print the read back data
01:83BB F5              	   253: 	push	AF
01:83BC 78              	   254: 	ld		A,B
01:83BD CD6380          	   255: 	call	PrintByte
01:83C0 F1              	   256: 	pop		AF
                        	   257: 	
                        	   258: 	; Print "expected"
01:83C1 CDB080          	   259: 	call	PrintString
                        	   260: 	
                        	   261: 	; Print the pattern that was written
01:83C4 79              	   262: 	ld		A,C
01:83C5 CD6380          	   263: 	call	PrintByte
01:83C8 CD8180          	   264: 	call	PrintCRLF
                        	   265: 	
01:83CB FD2601          	   266: 	ld		IYH,1					; Indicate an error has occured
01:83CE E1              	   267: 	pop		HL
01:83CF F1              	   268: 	pop		AF
01:83D0 C9              	   269: 	ret
                        	   270: 
                        	   271: DiagnosticsEnd:
01:83D1 3E00            	   272: 	ld		A,$0
01:83D3 D330            	   273: 	out		(BankSelect),A			; Sets bank number to 0
                        	   274: 	
01:83D5 FD7C            	   275: 	ld		A,IYH
01:83D7 FE01            	   276: 	cp		1
01:83D9 2806            	   277: 	jr		z,DiagnosticsEnd2		; If memory test failed, exit, as there was warning errors
01:83DB 2156AE          	   278: 	ld		HL,MemoryTestPassedMsg	; Else print test passed
01:83DE CDB080          	   279: 	call	PrintString
                        	   280: 
                        	   281: DiagnosticsEnd2:
01:83E1 FDE1            	   282: 	pop		IY
01:83E3 DDE1            	   283: 	pop		IX
01:83E5 E1              	   284: 	pop		HL
01:83E6 D1              	   285: 	pop		DE
01:83E7 C1              	   286: 	pop		BC
01:83E8 F1              	   287: 	pop		AF
01:83E9 C9              	   288: 	ret
                        	   289: 
                        	   290: 
                        	   291: ;  _____   _   _   _   __  __                                           
                        	   292: ; |  ___| (_) | | | | |  \/  |   ___   _ __ ___     ___    _ __   _   _ 
                        	   293: ; | |_    | | | | | | | |\/| |  / _ \ | '_ ` _ \   / _ \  | '__| | | | |
                        	   294: ; |  _|   | | | | | | | |  | | |  __/ | | | | | | | (_) | | |    | |_| |
                        	   295: ; |_|     |_| |_| |_| |_|  |_|  \___| |_| |_| |_|  \___/  |_|     \__, |
                        	   296: ;                                                                 |___/ 
                        	   297: 
                        	   298: ; *********************************************************************************************************************
                        	   299: ; Fill a memory address range with a byte. Does not fill all banks, only the current one. It will exclude
                        	   300: ; shadow ROM (otherwise it will corrupt the BIOS), as well as vector pages.
                        	   301: ;		- Parameter 1 = Start address
                        	   302: ;		- Parameter 2 = End address
                        	   303: ;		- Parameter 3 = The byte to write
                        	   304: ; *********************************************************************************************************************
                        	   305: ; 	Wishlist:
                        	   306: ;		- Verify after write
                        	   307: ;		- Add: Filled xxxx bytes in decimal
                        	   308: 
                        	   309: FillMemory:
01:83EA F5              	   310: 	push	AF
01:83EB C5              	   311: 	push	BC
01:83EC D5              	   312: 	push	DE
01:83ED E5              	   313: 	push	HL
                        	   314: 	
01:83EE 2AB5B0          	   315: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   316: 	
                        	   317: ; GET ALL THE PARAMETERS AND STORE THEM IN MEMORY
                        	   318: FillStartAddr:
01:83F1 CDCF88          	   319: 	call	GetHexParameter			; Get the first parameter, start address
01:83F4 D28484          	   320: 	jp		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:83F7 FE00            	   321: 	cp		0						; Is there a first parameter?
01:83F9 287D            	   322: 	jr		z,FillNoParameter		; No, then print error message
01:83FB FE0F            	   323: 	cp		HELP
01:83FD 287F            	   324: 	jr		z,FillPrintHelp
01:83FF ED43D5B0        	   325: 	ld		(StartAddress),BC		; Store start address
01:8403 ED43D9B0        	   326: 	ld		(StartAddressAlt),BC	; Store start address
                        	   327: 	
                        	   328: FillEndAddr:
01:8407 CDCF88          	   329: 	call	GetHexParameter			; Get the second parameter, end address
01:840A 3078            	   330: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:840C FE00            	   331: 	cp		0						; Is there a second parameter?
01:840E 2868            	   332: 	jr		z,FillNoParameter		; No, then print error message
01:8410 ED43D7B0        	   333: 	ld		(EndAddress),BC			; Store end address
                        	   334: 
                        	   335: FillByte:
01:8414 CDCF88          	   336: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8417 306B            	   337: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:8419 FE00            	   338: 	cp		0						; Is there a third parameter?
01:841B 285B            	   339: 	jr		z,FillNoParameter		; No, then print error message
01:841D 79              	   340: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:841E 32DDB0          	   341: 	ld		(ByteTransfer),A		; Store the byte to write
                        	   342: 	
01:8421 CDDA89          	   343: 	call	RangeValidation			; Check if Fill can write to a valid range of RAM space (excluse BIOS and Vectors)
01:8424 385E            	   344: 	jr		c,FillMemoryEnd
                        	   345: 	
                        	   346: FillRange1:
                        	   347: 	; Detect amout of bytes to copy in high range
01:8426 C5              	   348: 	push	BC
01:8427 CB49            	   349: 	bit		1,C
01:8429 2823            	   350: 	jr		z,FillRange2
01:842B 2ADBB0          	   351: 	ld		HL,(EndAddressAlt)		; Load end address
01:842E ED5BD9B0        	   352: 	ld		DE,(StartAddressAlt)	; Load start
01:8432 B7              	   353: 	or		A						; Clear carry flag
01:8433 ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:8435 E5              	   355: 	push	HL						; Put result of byte count
01:8436 C1              	   356: 	pop		BC						; Into the byte count register
01:8437 2AD9B0          	   357: 	ld		HL,(StartAddressAlt)	; Set source address
01:843A 3ADDB0          	   358: 	ld		A,(ByteTransfer)		; Grab byte to write
01:843D 77              	   359: 	ld		(HL),A					; Save it at the source address
01:843E ED5BD9B0        	   360: 	ld		DE,(StartAddressAlt)	; Place destination address
01:8442 13              	   361: 	inc		DE						; Destination address +1
01:8443 EDB0            	   362: 	ldir
01:8445 ED4BD9B0        	   363: 	ld		BC,(StartAddressAlt)	; Set CurrentAddress to start of available RAM
01:8449 ED43B9B0        	   364: 	ld		(CurrentAddress),BC
01:844D 37              	   365: 	scf								; Set carry
                        	   366: 
                        	   367: FillRange2:
                        	   368: 	; Detect amout of bytes to copy in low range
01:844E C1              	   369: 	pop		BC
01:844F CB41            	   370: 	bit		0,C
01:8451 2831            	   371: 	jr		z,FillMemoryEnd
01:8453 2AD7B0          	   372: 	ld		HL,(EndAddress)			; Load end address
01:8456 ED5BD5B0        	   373: 	ld		DE,(StartAddress)		; Load start
01:845A B7              	   374: 	or		A						; Clear carry flag
01:845B ED52            	   375: 	sbc		HL,DE					; HL = HL - DE
01:845D E5              	   376: 	push	HL						; Put result of byte count
01:845E C1              	   377: 	pop		BC						; Into the byte count register
01:845F 2AD5B0          	   378: 	ld		HL,(StartAddress)		; Set source address
01:8462 3ADDB0          	   379: 	ld		A,(ByteTransfer)		; Grab byte to write
01:8465 77              	   380: 	ld		(HL),A					; Save it at the source address
01:8466 ED5BD5B0        	   381: 	ld		DE,(StartAddress)		; Place destination address
01:846A 13              	   382: 	inc		DE						; Destination address +1
01:846B EDB0            	   383: 	ldir
01:846D ED4BD5B0        	   384: 	ld		BC,(StartAddress)		; Set CurrentAddress to start of available RAM
01:8471 ED43B9B0        	   385: 	ld		(CurrentAddress),BC
01:8475 37              	   386: 	scf								; Set Carry, indicates no error to calling program
01:8476 180C            	   387: 	jr		FillMemoryEnd
                        	   388: 
                        	   389: FillNoParameter:
01:8478 CD45B0          	   390: 	call	NoParameter
01:847B B7              	   391: 	or		A						; Clear Carry, indicates error to calling program
01:847C 1806            	   392: 	jr		FillMemoryEnd
                        	   393: 
                        	   394: FillPrintHelp:
01:847E 2105AF          	   395: 	ld		HL,FillHelp
01:8481 CDB080          	   396: 	call	PrintString
                        	   397: 
                        	   398: FillMemoryEnd:
01:8484 E1              	   399: 	pop		HL
01:8485 D1              	   400: 	pop		DE
01:8486 C1              	   401: 	pop		BC
01:8487 F1              	   402: 	pop		AF
01:8488 C9              	   403: 	ret
                        	   404: 
                        	   405: 
                        	   406: ; *********************************************************************************************************************
                        	   407: ; Halts the CPU
                        	   408: ; *********************************************************************************************************************
                        	   409:  
                        	   410: HaltCmd:
01:8489 76              	   411: 	halt
01:848A C9              	   412: 	ret
                        	   413: 
                        	   414: 
                        	   415: ;  _   _                 ____                              
                        	   416: ; | | | |   ___  __  __ |  _ \   _   _   _ __ ___    _ __  
                        	   417: ; | |_| |  / _ \ \ \/ / | | | | | | | | | '_ ` _ \  | '_ \ 
                        	   418: ; |  _  | |  __/  >  <  | |_| | | |_| | | | | | | | | |_) |
                        	   419: ; |_| |_|  \___| /_/\_\ |____/   \__,_| |_| |_| |_| | .__/ 
                        	   420: ;                                                   |_|    
                        	   421: ;
                        	   422: ; *********************************************************************************************************************
                        	   423: ; Prints the content of memory to serial port A
                        	   424: ; Parameters:	[AAAA], [LL] (where AAAA is the address to start displaying, and LL is the number of lines to display)
                        	   425: ; *********************************************************************************************************************
                        	   426: ;
                        	   427: ; Registers and variables used:
                        	   428: ;	- B is the number of bytes/characters per line
                        	   429: ;	- C is the line counter per page
                        	   430: ;	- DE is the number of lines to print
                        	   431: ;	- HL is the address to display
                        	   432: 
                        	   433: ; Wish list:
                        	   434: ;	- End at $FFFF
                        	   435: ;	- When more then a page long, pause every page and wait for ENTER to continues, or ESC to quit
                        	   436: 
                        	   437: HexDump:
01:848B F5              	   438: 	push	AF
01:848C C5              	   439: 	push	BC
01:848D D5              	   440: 	push	DE
01:848E E5              	   441: 	push	HL
                        	   442: 	
01:848F 2AB5B0          	   443: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:8492 CDCF88          	   444: 	call	GetHexParameter			; Get the first parameter: the address to display
01:8495 306B            	   445: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:8497 FE0F            	   446: 	cp		HELP
01:8499 2861            	   447: 	jr		z,HexDumpPrintHelp
01:849B FE00            	   448: 	cp		0						; Is there a parameter?
01:849D 2004            	   449: 	jr		nz,HexLinesToRead		; If There's a parameter, go check second parameter
01:849F ED4BB9B0        	   450: 	ld		BC,(CurrentAddress)		; Since it's no parameter, then place CurrentAddress as default address
                        	   451: 
                        	   452: HexLinesToRead:
01:84A3 C5              	   453: 	push	BC						; Save the first parameter's address...
01:84A4 D1              	   454: 	pop		DE						;    to be later recovered as HL
01:84A5 CDCF88          	   455: 	call	GetHexParameter			; Get the secode parameter: the number of lines to display
01:84A8 3058            	   456: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:84AA FE00            	   457: 	cp		0						; Is there a parameter?
01:84AC 2808            	   458: 	jr		z,HexDefaultLines		; There is no parameter, so go load the default line number
01:84AE FE01            	   459: 	cp		1						; Is it a one byte parameter
01:84B0 2806            	   460: 	jr		z,HexDisplayContent		; If it is, C already contains the number of lines, so start printing content
01:84B2 0EFF            	   461: 	ld		C,$FF					; Else, if it's a 2 byte or more parameter, set maximum lines to $FF
01:84B4 1802            	   462: 	jr		HexDisplayContent		; Start printing hex dump
                        	   463: HexDefaultLines:
01:84B6 0E15            	   464: 	ld		C,VertTextRes-3			; Get number of vertical lines
                        	   465: 
                        	   466: HexDisplayContent:
01:84B8 EB              	   467: 	ex		DE,HL					; Restore address from first parameter read
                        	   468: 	
                        	   469: ; PRINT ADDRESS AT BEGINNING
                        	   470: HexNextLine:
01:84B9 E5              	   471: 	push	HL						; Save HL for later use (character portion of memory dump)
01:84BA CDBE80          	   472: 	call	PrintWord				; Print address
01:84BD 0608            	   473: 	ld		B,8						; Setup byte counter per line
01:84BF 3E3A            	   474: 	ld		A,":"
01:84C1 CD7680          	   475: 	call	PrintChar				; Print colon
01:84C4 3E20            	   476: 	ld		A," "
01:84C6 CD7680          	   477: 	call	PrintChar				; Print space
                        	   478: 
                        	   479: ; PRINT EIGHT BYTES
                        	   480: HexNextByte:
01:84C9 7E              	   481: 	ld		A,(HL)
01:84CA CD6380          	   482: 	call	PrintByte				; Print byte contained in address HL
01:84CD 3E20            	   483: 	ld		A," "
01:84CF CD7680          	   484: 	call	PrintChar				; Print space
01:84D2 23              	   485: 	inc		HL						; Increment HL for next byte
01:84D3 05              	   486: 	dec		B						; Decrement byte counter
01:84D4 20F3            	   487: 	jr		nz,HexNextByte			; If the 8 bytes have not all been printed, then loop again
                        	   488: 
                        	   489: ; PRINT EIGHT CHARACTERS
01:84D6 CD7680          	   490: 	call	PrintChar				; Print an extra space (to space out bytes from character printout)
01:84D9 0608            	   491: 	ld		B,8						; Reset the counter to count characters instead
01:84DB E1              	   492: 	pop		HL						; Reset HL so we can print the characters instead of the bytes at the end of the line
                        	   493: HexNextChar:
01:84DC 7E              	   494: 	ld		A,(HL)
01:84DD FE20            	   495: 	cp		$20						; Compare A with first displayable character
01:84DF 3806            	   496: 	jr		c,HexReplaceDot			; If it's lower, then replace with a period
01:84E1 FE7F            	   497: 	cp		$7F						; Is it higher or equal to the DEL character?
01:84E3 3002            	   498: 	jr		nc,HexReplaceDot		; Then replace that with a period
01:84E5 1802            	   499: 	jr		HexPrintChar
                        	   500: HexReplaceDot:
01:84E7 3E2E            	   501: 	ld		A,"."					; No, then replace it with a period
                        	   502: HexPrintChar:
01:84E9 CD7680          	   503: 	call	PrintChar				; Print the character representation of the byte
01:84EC 23              	   504: 	inc		HL						; Increment HL for next character
01:84ED 05              	   505: 	dec		B						; Decrement character counter
01:84EE 20EC            	   506: 	jr		nz,HexNextChar			; If the 8 characters have not all been printed, then loop again
01:84F0 CD8180          	   507: 	call	PrintCRLF				; Change line
01:84F3 0D              	   508: 	dec		C						; 
01:84F4 C2B984          	   509: 	jp		nz,HexNextLine
01:84F7 22B9B0          	   510: 	ld		(CurrentAddress),HL		; Save Current Address to where Hex left off
01:84FA 1806            	   511: 	jr		HexDumpEnd
                        	   512: 	
                        	   513: HexDumpPrintHelp:
01:84FC 2170AF          	   514: 	ld		HL,HexDumpHelp
01:84FF CDB080          	   515: 	call	PrintString
                        	   516: 	
                        	   517: HexDumpEnd:
01:8502 E1              	   518: 	pop		HL
01:8503 D1              	   519: 	pop		DE
01:8504 C1              	   520: 	pop		BC
01:8505 F1              	   521: 	pop		AF
01:8506 C9              	   522: 	ret
                        	   523: 
                        	   524: 
                        	   525: ;  ___           _            _   _   _               
                        	   526: ; |_ _|  _ __   | |_    ___  | | | | | |   ___  __  __
                        	   527: ;  | |  | '_ \  | __|  / _ \ | | | |_| |  / _ \ \ \/ /
                        	   528: ;  | |  | | | | | |_  |  __/ | | |  _  | |  __/  >  < 
                        	   529: ; |___| |_| |_|  \__|  \___| |_| |_| |_|  \___| /_/\_\
                        	   530: ;
                        	   531: 
                        	   532: ; *********************************************************************************************************************
                        	   533: ; Transfer programs via Intel Hex (i8HEX) - Press ESC to exit
                        	   534: ; - Input:	Upload an i8Hex file from a terminal program on your computer (Transfer File)
                        	   535: ; - Output:	Sets (CurrentAddress) variable to the start address declared in the IntelHex file
                        	   536: 
                        	   537: ; File Format:	SBBAAAARRDDDDDDCC termintated by (CR) and/or (LF)
                        	   538: ;				:0300300002337A1E
                        	   539: ;					S = : is the start code
                        	   540: ;					BB = it the data byte count ($20 is the typical)
                        	   541: ;					AAAA = The 16-bit beginning memory address offset of the data
                        	   542: ;					RR = Record type, 00 = Data, 01 = End of File
                        	   543: ;					DD = Data
                        	   544: ;					CC = Checksum from BB to the last DD (Two's complement)
                        	   545: ; *********************************************************************************************************************
                        	   546: ;	- B = Byte couter
                        	   547: ;	- C = Checksum
                        	   548: ;	- D = Flags (Start address, Checksum error, Last record)
                        	   549: ;	- HL = Address offset pointer
                        	   550: 
                        	   551: StartAddr	= 0						; Start address flag bit
                        	   552: ChecksumErr	= 1						; Checksum error flag bit
                        	   553: LastRec		= 7						; Last record flag bit
                        	   554: 
                        	   555: IntelHex:
01:8507 F5              	   556: 	push	AF
01:8508 C5              	   557: 	push	BC
01:8509 D5              	   558: 	push	DE
01:850A E5              	   559: 	push	HL
01:850B DDE5            	   560: 	push	IX
                        	   561: 	
01:850D CD3D8B          	   562: 	call	SkipSpaces
01:8510 7E              	   563: 	ld		A,(HL)					; Read a character form the CommandBuffer	
01:8511 FE0F            	   564: 	cp		HELP
01:8513 CACA85          	   565: 	jp		z,IntelHexPrintHelp
                        	   566: 
01:8516 2199AE          	   567: 	ld		HL,IntelHexLoadMsg		; Print load message, or ESC to exit
01:8519 CDB080          	   568: 	call	PrintString				;
01:851C 1600            	   569: 	ld		D,0						; Clear the flags register
01:851E DD210000        	   570: 	ld		IX,0					; Clear byte counter
01:8522 DD22DEB0        	   571: 	ld		(UserCodeSize),IX		; Clear user code byte counter
                        	   572: 	
                        	   573: ; *** START CODE
                        	   574: IntelHexStartCode:
01:8526 CDC980          	   575: 	call	ReadChar				; Read a character form the console
01:8529 FE1B            	   576: 	cp		ESC						; Did the user press ESCAPE?
01:852B CAAC85          	   577: 	jp		z,IntelHexAbort			; Yes, then exit
01:852E FE3A            	   578: 	cp		":"						; Is it the start code
01:8530 2802            	   579: 	jr		z,IntelHexByteCount		; Yes, then read byte count
01:8532 18F2            	   580: 	jr		IntelHexStartCode		; No, then read a new character until ":" is present
                        	   581: 	
                        	   582: ; *** BYTE COUNT
                        	   583: IntelHexByteCount:
01:8534 CDDD80          	   584: 	call	ReadByte				; Read the byte count
01:8537 47              	   585: 	ld		B,A						; Store byte counter in B
01:8538 4F              	   586: 	ld		C,A						; copy value of accumulator in checksum register
                        	   587: 
                        	   588: ; *** ADDRESS
                        	   589: IntelHexAddress:
01:8539 CDDD80          	   590: 	call	ReadByte				; Read the MSB characters and convert it to a byte
01:853C 67              	   591: 	ld		H,A						; Store the address's MSB
01:853D 81              	   592: 	add		C						; Add checksum
01:853E 4F              	   593: 	ld		C,A						; Store back result in checksum accumulator
01:853F CDDD80          	   594: 	call	ReadByte				; Read the LSB characters and convert it to a byte
01:8542 6F              	   595: 	ld		L,A						; Store the address's LSB
01:8543 81              	   596: 	add		C						; Add checksum
01:8544 4F              	   597: 	ld		C,A						; Store back result in checksum accumulator
01:8545 CB42            	   598: 	bit		StartAddr,D				; Check if it's the first time the address has been read...
01:8547 2005            	   599: 	jr		nz,IntelHexRecordType	;	If it's not the first line, then go get record type
01:8549 22B9B0          	   600: 	ld		(CurrentAddress),HL		; Else store the starting address
01:854C CBC2            	   601: 	set		StartAddr,D				; Set first line start address flag
                        	   602: ;	ld		E,1						; Set first pass flag
                        	   603: 
                        	   604: ; *** RECORD TYPE
                        	   605: IntelHexRecordType:
01:854E CDDD80          	   606: 	call	ReadByte				; Read the record type byte
01:8551 F5              	   607: 	push	AF
01:8552 81              	   608: 	add		C						; Add checksum
01:8553 4F              	   609: 	ld		C,A						; Store back result in checksum accumulator
01:8554 F1              	   610: 	pop		AF
01:8555 FE00            	   611: 	cp		00						; Is it data?
01:8557 2808            	   612: 	jr		z,IntelHexData
01:8559 FE01            	   613: 	cp		01						; Is it the end of file record type
01:855B 2057            	   614: 	jr		nz,IntelHexUnsupported		
01:855D CBFA            	   615: 	set		LastRec,D	
01:855F 180B            	   616: 	jr		IntelHexChecksum		; Get checksum
                        	   617: 
                        	   618: ; *** DATA
                        	   619: IntelHexData:
01:8561 CDDD80          	   620: 	call	ReadByte				; Get data byte
01:8564 77              	   621: 	ld		(HL),A					; Store data byte in memory
01:8565 23              	   622: 	inc		HL						; Point to the next address
01:8566 DD23            	   623: 	inc		IX						; Count the total number of bytes
01:8568 81              	   624: 	add		C						; Add checksum
01:8569 4F              	   625: 	ld		C,A						; Store back result in checksum accumulator
01:856A 10F5            	   626: 	djnz	IntelHexData			; Decrement count, and go to next data if not finished
                        	   627: 
                        	   628: ; *** CHECKSUM
                        	   629: IntelHexChecksum:
01:856C CDDD80          	   630: 	call	ReadByte				; Read the checksum for that record
01:856F ED44            	   631: 	neg								; Do a 2s compliment on A (saves instructions if I swapped C with A)
01:8571 B9              	   632: 	cp		C						; Compare the transmited checksum with the calculated checksum
01:8572 2806            	   633: 	jr		z,IntelHexCheckOk		; Is it the same?
01:8574 3E78            	   634: 	ld		A,"x"					; Display an "x" if checksum do not match
01:8576 CBCA            	   635: 	set		ChecksumErr,D			; Indicate an error in checksum flag
01:8578 1802            	   636: 	jr		IntelHexPrintStatus		;
                        	   637: IntelHexCheckOk:
01:857A 3E2E            	   638: 	ld		A,"."					; Display a "." if checksum is a match
                        	   639: IntelHexPrintStatus:
01:857C CD7680          	   640: 	call	PrintChar				; Print the checksum validity character
01:857F CB7A            	   641: 	bit		LastRec,D				; Check if it's the last record
01:8581 CA2685          	   642: 	jp		z,IntelHexStartCode		; No, then continue reading more lines
01:8584 CDC980          	   643: 	call	ReadChar				; Flush CR
                        	   644: 
                        	   645: IntelHexPrintEndMsg:
01:8587 CD8180          	   646: 	call	PrintCRLF
01:858A 217AAE          	   647: 	ld		HL,IntelHexFinishedMsg	; Print the end message
01:858D CDB080          	   648: 	call	PrintString
01:8590 218AAE          	   649: 	ld		HL,IntelHexSuccessMsg	; Point to "unsuccessful"
01:8593 CB4A            	   650: 	bit		ChecksumErr,D			; Cneck if there was an error that was flagged
01:8595 2002            	   651: 	jr		nz,IntelHexPrintNotOk	; If the ChecksumErr flag was set, then print unsuccessful
01:8597 23              	   652: 	inc		HL						; Push pointer to letters..
01:8598 23              	   653: 	inc		HL						;   so it becomes "successful"
                        	   654: IntelHexPrintNotOk:
01:8599 CDB080          	   655: 	call	PrintString				; Print the sucess level
01:859C E5              	   656: 	push	HL
01:859D DDE5            	   657: 	push	IX						; Copy byte counter
01:859F E1              	   658: 	pop		HL						; To HL to be printed
01:85A0 CD5A80          	   659: 	call	PrintDec				; Print the decimal number
01:85A3 21F1AE          	   660: 	ld		HL,DownloadedBytesMsg	; 
01:85A6 CDB080          	   661: 	call	PrintString				; Print bytes loaded text
01:85A9 E1              	   662: 	pop		HL
01:85AA 1824            	   663: 	jr		IntelHexEnd				; And end load
                        	   664: 
                        	   665: IntelHexAbort:
01:85AC 21D6AE          	   666: 	ld		HL,IntelHexAbortedMsg	; Abort message
01:85AF CDB080          	   667: 	call	PrintString				;
01:85B2 181C            	   668: 	jr		IntelHexEnd
                        	   669: 
                        	   670: IntelHexUnsupported:
01:85B4 2147AD          	   671: 	ld		HL,IntelHexUnsupportedErr	; Unsupported record type message
01:85B7 CDB080          	   672: 	call	PrintString				;
01:85BA CD6380          	   673: 	call	PrintByte				; Print the record number
01:85BD CD8180          	   674: 	call	PrintCRLF
01:85C0 180E            	   675: 	jr		IntelHexEnd
                        	   676: 
                        	   677: IntelHexParamError:
01:85C2 210DAD          	   678: 	ld		HL,UnrecognizedParamErr
01:85C5 CDB080          	   679: 	call	PrintString
01:85C8 1806            	   680: 	jr		IntelHexEnd
                        	   681: 
                        	   682: IntelHexPrintHelp:
01:85CA 21D5AF          	   683: 	ld		HL,IntelHexHelp
01:85CD CDB080          	   684: 	call	PrintString
                        	   685: 	
                        	   686: IntelHexEnd:
01:85D0 DDE1            	   687: 	pop		IX
01:85D2 E1              	   688: 	pop		HL
01:85D3 D1              	   689: 	pop		DE
01:85D4 C1              	   690: 	pop		BC
01:85D5 F1              	   691: 	pop		AF
01:85D6 C9              	   692: 	ret
                        	   693: 
                        	   694: 
                        	   695: ;  _       _         _   
                        	   696: ; | |     (_)  ___  | |_ 
                        	   697: ; | |     | | / __| | __|
                        	   698: ; | |___  | | \__ \ | |_ 
                        	   699: ; |_____| |_| |___/  \__|
                        	   700: 
                        	   701: 
                        	   702: ; *********************************************************************************************************************
                        	   703: ; Prints a list of available commands
                        	   704: ; *********************************************************************************************************************
                        	   705: 
                        	   706: ListCmd:
01:85D7 E5              	   707: 	push	HL
01:85D8 213FA9          	   708: 	ld		HL,ListOfCommands
01:85DB CDB080          	   709: 	call	PrintString				; Print first line
01:85DE CD8E80          	   710: 	call	PrintLine				; Print a line
01:85E1 CDB080          	   711: 	call	PrintString				; Print the rest
01:85E4 E1              	   712: 	pop		HL
01:85E5 C9              	   713: 	ret
                        	   714: 
                        	   715: 
                        	   716: ;  ____                  _    
                        	   717: ; |  _ \    ___    ___  | | __
                        	   718: ; | |_) |  / _ \  / _ \ | |/ /
                        	   719: ; |  __/  |  __/ |  __/ |   < 
                        	   720: ; |_|      \___|  \___| |_|\_\
                        	   721: 
                        	   722: 
                        	   723: ; *********************************************************************************************************************
                        	   724: ; Read a byte of a I/O port
                        	   725: ; *********************************************************************************************************************
                        	   726: ; To be done: Error messages
                        	   727: 
                        	   728: PeekCmd:
01:85E6 F5              	   729: 	push	AF
01:85E7 C5              	   730: 	push	BC
01:85E8 E5              	   731: 	push	HL
                        	   732: 	
01:85E9 2AB5B0          	   733: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   734: 	
                        	   735: PeekAddress:
01:85EC CDCF88          	   736: 	call	GetHexParameter			; Get the IO port number parameter
01:85EF D21086          	   737: 	jp		nc,PeekError			; Exit routine if there was an error in the parameter
01:85F2 FE00            	   738: 	cp		0						; Is there a parameter?
01:85F4 2814            	   739: 	jr		z,PeekNoParameter		; No, then print a no parameter message
                        	   740: 
                        	   741: PeekRead:
01:85F6 79              	   742: 	ld		A,C						; Put port number from command line parameter in accumulator
01:85F7 CD6380          	   743: 	call	PrintByte				; Print the port number
01:85FA 3E3A            	   744: 	ld		A,":"
01:85FC CD7680          	   745: 	call	PrintChar
01:85FF ED78            	   746: 	in		A,(C)					; Read a byte from the specified port number
01:8601 CD6380          	   747: 	call	PrintByte				; Print the read byte
01:8604 CD8180          	   748: 	call	PrintCRLF				; Change line
01:8607 C31086          	   749: 	jp		PeekEnd					;
                        	   750: 
                        	   751: PeekNoParameter:
01:860A CD45B0          	   752: 	call	NoParameter
01:860D C31086          	   753: 	jp		PeekEnd
                        	   754: 	
                        	   755: PeekError:
                        	   756: 
                        	   757: PeekEnd:
01:8610 E1              	   758: 	pop		HL
01:8611 C1              	   759: 	pop		BC
01:8612 F1              	   760: 	pop		AF
01:8613 C9              	   761: 	ret
                        	   762: 
                        	   763: 
                        	   764: ;  ____            _           
                        	   765: ; |  _ \    ___   | | __   ___ 
                        	   766: ; | |_) |  / _ \  | |/ /  / _ \
                        	   767: ; |  __/  | (_) | |   <  |  __/
                        	   768: ; |_|      \___/  |_|\_\  \___|
                        	   769: 
                        	   770: 
                        	   771: ; *********************************************************************************************************************
                        	   772: ; Write a byte to a specific I/O port
                        	   773: ;	- Input:	Parameters: Port number & Byte
                        	   774: ; *********************************************************************************************************************
                        	   775: ; To be done: Error message
                        	   776: 
                        	   777: PokeCmd:
01:8614 F5              	   778: 	push 	AF
01:8615 C5              	   779: 	push	BC
01:8616 E5              	   780: 	push	HL
                        	   781: 	
01:8617 2AB5B0          	   782: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   783: 	
                        	   784: PokeGetPort:
01:861A CDCF88          	   785: 	call	GetHexParameter			; Get the first parameter, port number (byte in C)
01:861D D25086          	   786: 	jp		nc,PokeError			; Exit routine if there was an error in the parameter
01:8620 FE00            	   787: 	cp		0						; Is there a first parameter?
01:8622 2826            	   788: 	jr		z,PokeNoParameter		; No, then print error message
01:8624 79              	   789: 	ld		A,C
01:8625 32BBB0          	   790: 	ld		(CurrentPort),A			; Store port number for later use (cheaper than push-pop)
                        	   791: 	
                        	   792: PokeGetByte:
01:8628 CDCF88          	   793: 	call	GetHexParameter			; Get the second parameter, byte to write
01:862B 3023            	   794: 	jr		nc,PokeError			; Exit routine if there was an error in the parameter
01:862D FE00            	   795: 	cp		0						; Is there a third parameter?
01:862F 2819            	   796: 	jr		z,PokeNoParameter		; No, then print error message
01:8631 79              	   797: 	ld		A,C						; Save byte for later use
01:8632 47              	   798: 	ld		B,A						; ... and put it in B
                        	   799: 
                        	   800: PokeWrite:
01:8633 3ABBB0          	   801: 	ld		A,(CurrentPort)			; Read back the stored port number
01:8636 4F              	   802: 	ld		C,A						; Copy it in C for later use
01:8637 CD6380          	   803: 	call	PrintByte				; Print it
01:863A 3E3A            	   804: 	ld		A,":"
01:863C CD7680          	   805: 	call	PrintChar
01:863F ED41            	   806: 	out		(C),B					; Write byte in B, to port address in C
01:8641 78              	   807: 	ld		A,B						; Place the byte to print in the accumulator
01:8642 CD6380          	   808: 	call	PrintByte
01:8645 CD8180          	   809: 	call	PrintCRLF
01:8648 1806            	   810: 	jr		PokeEnd
                        	   811: 
                        	   812: PokeNoParameter:
01:864A CD45B0          	   813: 	call	NoParameter
01:864D C35086          	   814: 	jp		PokeEnd
                        	   815: 
                        	   816: PokeError:
                        	   817: 	
                        	   818: PokeEnd
01:8650 E1              	   819: 	pop		HL
01:8651 C1              	   820: 	pop		BC
01:8652 F1              	   821: 	pop		AF
01:8653 C9              	   822: 	ret
                        	   823: 
                        	   824: 
                        	   825: ;  ____                   _         _                       
                        	   826: ; |  _ \    ___    __ _  (_)  ___  | |_    ___   _ __   ___ 
                        	   827: ; | |_) |  / _ \  / _` | | | / __| | __|  / _ \ | '__| / __|
                        	   828: ; |  _ <  |  __/ | (_| | | | \__ \ | |_  |  __/ | |    \__ \
                        	   829: ; |_| \_\  \___|  \__, | |_| |___/  \__|  \___| |_|    |___/
                        	   830: ;                 |___/                                     
                        	   831: 
                        	   832: ; *********************************************************************************************************************
                        	   833: ; Prints the contents of the registers on the console
                        	   834: ; *********************************************************************************************************************
                        	   835: ;
                        	   836: ; Wish list:
                        	   837: ;	- Modify individual registers
                        	   838: 
                        	   839: Registers:
01:8654 ED73D2B0        	   840: 	ld		(StackPtr),SP			; Save the stack pointer
01:8658 F5              	   841: 	push	AF
01:8659 C5              	   842: 	push	BC
01:865A D5              	   843: 	push	DE
01:865B E5              	   844: 	push	HL
01:865C DDE5            	   845: 	push	IX
01:865E FDE5            	   846: 	push	IY
                        	   847: 	
01:8660 F5              	   848: 	push	AF						; Save the flags (to be restored in C later)
01:8661 32C7B0          	   849: 	ld		(RegA),A				; Save A
01:8664 ED43C8B0        	   850: 	ld		(RegBC),BC				; Save BC
01:8668 ED53CAB0        	   851: 	ld		(RegDE),DE				; Save DE
01:866C 22CCB0          	   852: 	ld		(RegHL),HL				; Save HL
01:866F DD22CEB0        	   853: 	ld		(RegIX),IX				; Save IX
01:8673 FD22D0B0        	   854: 	ld		(RegIY),IY				; Save IY
01:8677 C1              	   855: 	pop		BC						; Restore AF in BC to get the flags
01:8678 79              	   856: 	ld		A,C
01:8679 32D4B0          	   857: 	ld		(FlagsReg),A			; Save the flags register
                        	   858: 	
                        	   859: 	; PRINT THE ACCUMULATOR
01:867C 3E41            	   860: 	ld		A,"A"
01:867E CD7680          	   861: 	call	PrintChar
01:8681 3E3A            	   862: 	ld		A,":"
01:8683 CD7680          	   863: 	call	PrintChar
01:8686 3AC7B0          	   864: 	ld		A,(RegA)
01:8689 CD6380          	   865: 	call	PrintByte
01:868C 3E20            	   866: 	ld		A," "
01:868E CD7680          	   867: 	call	PrintChar
                        	   868: 
                        	   869: 	; PRINT BC REGISTER PAIR
01:8691 3E42            	   870: 	ld		A,"B"
01:8693 CD7680          	   871: 	call	PrintChar
01:8696 3E43            	   872: 	ld		A,"C"
01:8698 CD7680          	   873: 	call	PrintChar
01:869B 3E3A            	   874: 	ld		A,":"
01:869D CD7680          	   875: 	call	PrintChar
01:86A0 2AC8B0          	   876: 	ld		HL,(RegBC)
01:86A3 CDBE80          	   877: 	call	PrintWord
01:86A6 3E20            	   878: 	ld		A," "
01:86A8 CD7680          	   879: 	call	PrintChar
                        	   880: 
                        	   881: 	; PRINT DE REGISTER PAIR
01:86AB 3E44            	   882: 	ld		A,"D"
01:86AD CD7680          	   883: 	call	PrintChar
01:86B0 3E45            	   884: 	ld		A,"E"
01:86B2 CD7680          	   885: 	call	PrintChar
01:86B5 3E3A            	   886: 	ld		A,":"
01:86B7 CD7680          	   887: 	call	PrintChar
01:86BA 2ACAB0          	   888: 	ld		HL,(RegDE)
01:86BD CDBE80          	   889: 	call	PrintWord
01:86C0 3E20            	   890: 	ld		A," "
01:86C2 CD7680          	   891: 	call	PrintChar
                        	   892: 
                        	   893: 	; PRINT HL REGISTER PAIR
01:86C5 3E48            	   894: 	ld		A,"H"
01:86C7 CD7680          	   895: 	call	PrintChar
01:86CA 3E4C            	   896: 	ld		A,"L"
01:86CC CD7680          	   897: 	call	PrintChar
01:86CF 3E3A            	   898: 	ld		A,":"
01:86D1 CD7680          	   899: 	call	PrintChar
01:86D4 2ACCB0          	   900: 	ld		HL,(RegHL)
01:86D7 CDBE80          	   901: 	call	PrintWord
01:86DA CD8180          	   902: 	call	PrintCRLF
                        	   903: 
                        	   904: 	; PRINT IX INDEX REGISTER
01:86DD 3E49            	   905: 	ld		A,"I"
01:86DF CD7680          	   906: 	call	PrintChar
01:86E2 3E58            	   907: 	ld		A,"X"
01:86E4 CD7680          	   908: 	call	PrintChar
01:86E7 3E3A            	   909: 	ld		A,":"
01:86E9 CD7680          	   910: 	call	PrintChar
01:86EC 2ACEB0          	   911: 	ld		HL,(RegIX)
01:86EF CDBE80          	   912: 	call	PrintWord
01:86F2 3E20            	   913: 	ld		A," "
01:86F4 CD7680          	   914: 	call	PrintChar
                        	   915: 
                        	   916: 	; PRINT IY INDEX REGISTER
01:86F7 3E49            	   917: 	ld		A,"I"
01:86F9 CD7680          	   918: 	call	PrintChar
01:86FC 3E59            	   919: 	ld		A,"Y"
01:86FE CD7680          	   920: 	call	PrintChar
01:8701 3E3A            	   921: 	ld		A,":"
01:8703 CD7680          	   922: 	call	PrintChar
01:8706 2AD0B0          	   923: 	ld		HL,(RegIY)
01:8709 CDBE80          	   924: 	call	PrintWord
01:870C 3E20            	   925: 	ld		A," "
01:870E CD7680          	   926: 	call	PrintChar
                        	   927: 
                        	   928: 	; PRINT THE STACK POINTER
01:8711 3E53            	   929: 	ld		A,"S"
01:8713 CD7680          	   930: 	call	PrintChar
01:8716 3E50            	   931: 	ld		A,"P"
01:8718 CD7680          	   932: 	call	PrintChar
01:871B 3E3A            	   933: 	ld		A,":"
01:871D CD7680          	   934: 	call	PrintChar
01:8720 2AD2B0          	   935: 	ld		HL,(StackPtr)
01:8723 23              	   936: 	inc		HL						; Offset stack by 2 to compensate for...
01:8724 23              	   937: 	inc		HL						;	this routine's call
01:8725 CDBE80          	   938: 	call	PrintWord
01:8728 3E20            	   939: 	ld		A," "
01:872A CD7680          	   940: 	call	PrintChar
                        	   941: 
                        	   942: 	; PRINT THE FLAGS
01:872D 3E46            	   943: 	ld		A,"F"
01:872F CD7680          	   944: 	call	PrintChar
01:8732 3E3A            	   945: 	ld		A,":"
01:8734 CD7680          	   946: 	call	PrintChar
01:8737 21A4AB          	   947: 	ld		HL,FlagBits
                        	   948: 
                        	   949: 	; Sign
01:873A 7E              	   950: 	ld		A,(HL)					; Load the lowercase flag symbol
01:873B CB79            	   951: 	bit		Sign,C					; Check to the associated bit is set or not
01:873D 2803            	   952: 	jr		z,FlagSignClear			; If it's Set, then print lower case
01:873F CDA182          	   953: 	call	UpperCase				; Else, print upper case
                        	   954: FlagSignClear:
01:8742 CD7680          	   955: 	call	PrintChar				; Print the flag symbol
01:8745 23              	   956: 	inc		HL						; Point to the next symbol
                        	   957: 	
                        	   958: 	; Zero
01:8746 7E              	   959: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8747 CB71            	   960: 	bit		Zero,C					; Check to the associated bit is set or not
01:8749 2803            	   961: 	jr		z,FlagZeroClear			; If it's Set, then print lower case
01:874B CDA182          	   962: 	call	UpperCase				; Else, print upper case
                        	   963: FlagZeroClear:
01:874E CD7680          	   964: 	call	PrintChar				; Print the flag symbol
01:8751 23              	   965: 	inc		HL						; Point to the next symbol
                        	   966: 	
                        	   967: 	; Half-Carry
01:8752 7E              	   968: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8753 CB61            	   969: 	bit		HalfCarry,C				; Check to the associated bit is set or not
01:8755 2803            	   970: 	jr		z,FlagHalfClear			; If it's Set, then print lower case
01:8757 CDA182          	   971: 	call	UpperCase				; Else, print upper case
                        	   972: FlagHalfClear:
01:875A CD7680          	   973: 	call	PrintChar				; Print the flag symbol
01:875D 23              	   974: 	inc		HL						; Point to the next symbol
                        	   975: 	
                        	   976: 	; Overflow/Parity
01:875E 7E              	   977: 	ld		A,(HL)					; Load the lowercase flag symbol
01:875F CB51            	   978: 	bit		Overflow,C				; Check to the associated bit is set or not
01:8761 2803            	   979: 	jr		z,FlagOverClear			; If it's Set, then print lower case
01:8763 CDA182          	   980: 	call	UpperCase				; Else, print upper case
                        	   981: FlagOverClear:
01:8766 CD7680          	   982: 	call	PrintChar				; Print the flag symbol
01:8769 23              	   983: 	inc		HL						; Point to the next symbol
                        	   984: 	
                        	   985: 	; Add/Substract
01:876A 7E              	   986: 	ld		A,(HL)					; Load the lowercase flag symbol
01:876B CB49            	   987: 	bit		Negative,C				; Check to the associated bit is set or not
01:876D 2803            	   988: 	jr		z,FlagNegativeClear		; If it's Set, then print lower case
01:876F CDA182          	   989: 	call	UpperCase				; Else, print upper case
                        	   990: FlagNegativeClear:
01:8772 CD7680          	   991: 	call	PrintChar				; Print the flag symbol
01:8775 23              	   992: 	inc		HL						; Point to the next symbol
                        	   993: 	
                        	   994: 	; Carry
01:8776 7E              	   995: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8777 CB41            	   996: 	bit		Carry,C					; Check to the associated bit is set or not
01:8779 2803            	   997: 	jr		z,FlagCarryClear		; If it's Set, then print lower case
01:877B CDA182          	   998: 	call	UpperCase				; Else, print upper case
                        	   999: FlagCarryClear:
01:877E CD7680          	  1000: 	call	PrintChar				; Print the flag symbol
01:8781 23              	  1001: 	inc		HL						; Point to the next symbol
                        	  1002: 
01:8782 CD8180          	  1003: 	call	PrintCRLF
                        	  1004: 
01:8785 FDE1            	  1005: 	pop		IY
01:8787 DDE1            	  1006: 	pop		IX
01:8789 E1              	  1007: 	pop		HL
01:878A D1              	  1008: 	pop		DE
01:878B C1              	  1009: 	pop		BC
01:878C F1              	  1010: 	pop		AF
01:878D C9              	  1011: 	ret
                        	  1012: 
                        	  1013: 
                        	  1014: ;  ____                  
                        	  1015: ; |  _ \   _   _   _ __  
                        	  1016: ; | |_) | | | | | | '_ \ 
                        	  1017: ; |  _ <  | |_| | | | | |
                        	  1018: ; |_| \_\  \__,_| |_| |_|
                        	  1019: 
                        	  1020: 
                        	  1021: ; *********************************************************************************************************************
                        	  1022: ; Executes code at a specific address, clearing the registers at the beginning
                        	  1023: ; Parameter:	[AAAA], where AAAA is an optional address to execute from. Defaults to CurrentAddress
                        	  1024: ; *********************************************************************************************************************
                        	  1025: 
                        	  1026: RunCode:
01:878E 2AB5B0          	  1027: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:8791 CDCF88          	  1028: 	call	GetHexParameter			; Get the parameter
01:8794 300A            	  1029: 	jr		nc,RunEnd				; If there's an error in getting the parameter, then exit
01:8796 FE00            	  1030: 	cp		0						; Is there a parameter?
01:8798 2004            	  1031: 	jr		nz,RunCallBC			; There's a valid parameter, then execute user code
01:879A ED4BB9B0        	  1032: 	ld		BC,(CurrentAddress)		; Load the CurrentAddress in BC
                        	  1033: 
                        	  1034: RunCallBC:
01:879E C5              	  1035: 	push	BC						; Put execution address in the stack, see bellow "ret" acting as a "call (BC)"
01:879F C9              	  1036: 	ret								; Above "push BC" without "pop", "ret" acts as an indirect "call (BC)"
                        	  1037: 
                        	  1038: RunEnd:
01:87A0 C9              	  1039: 	ret
                        	  1040: 
                        	  1041: 
                        	  1042: ;  ____           _        _          _       _                           
                        	  1043: ; / ___|    ___  | |_     / \      __| |   __| |  _ __    ___   ___   ___ 
                        	  1044: ; \___ \   / _ \ | __|   / _ \    / _` |  / _` | | '__|  / _ \ / __| / __|
                        	  1045: ;  ___) | |  __/ | |_   / ___ \  | (_| | | (_| | | |    |  __/ \__ \ \__ \
                        	  1046: ; |____/   \___|  \__| /_/   \_\  \__,_|  \__,_| |_|     \___| |___/ |___/
                        	  1047: 
                        	  1048: 
                        	  1049: ; *********************************************************************************************************************
                        	  1050: ; Set current address from the command prompt
                        	  1051: ;	- Input:	An optional address parameter, defaults to $0000
                        	  1052: ; *********************************************************************************************************************
                        	  1053: 
                        	  1054: SetAddress:
01:87A1 F5              	  1055: 	push	AF
01:87A2 C5              	  1056: 	push	BC
01:87A3 D5              	  1057: 	push	DE
01:87A4 E5              	  1058: 	push	HL
                        	  1059: 	
01:87A5 2AB5B0          	  1060: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87A8 CDCF88          	  1061: 	call	GetHexParameter			; Get a parameter
01:87AB 3010            	  1062: 	jr		nc,SetAddressEnd		; Exit routine if there was an error in the parameter
01:87AD FE00            	  1063: 	cp		0						; Is there a parameter returned?
01:87AF 2806            	  1064: 	jr		z,SetAddressDefault		; If there is none, select default address
01:87B1 ED43B9B0        	  1065: 	ld		(CurrentAddress),BC		; Save address in parameter (BC or C) in CurrentAddress global variable
01:87B5 1806            	  1066: 	jr		SetAddressEnd
                        	  1067: 
                        	  1068: SetAddressDefault:
01:87B7 210000          	  1069: 	ld		HL,0					; Default address is $0000
01:87BA 22B9B0          	  1070: 	ld		(CurrentAddress),HL		; Save it in CurrentAddress global variable
                        	  1071: 
                        	  1072: SetAddressEnd:
01:87BD E1              	  1073: 	pop		HL
01:87BE D1              	  1074: 	pop		DE
01:87BF C1              	  1075: 	pop		BC
01:87C0 F1              	  1076: 	pop		AF
                        	  1077: 	
01:87C1 C9              	  1078: 	ret
                        	  1079: 	
                        	  1080: 
                        	  1081: ;  ____           _     ____                    _    
                        	  1082: ; / ___|    ___  | |_  | __ )    __ _   _ __   | | __
                        	  1083: ; \___ \   / _ \ | __| |  _ \   / _` | | '_ \  | |/ /
                        	  1084: ;  ___) | |  __/ | |_  | |_) | | (_| | | | | | |   < 
                        	  1085: ; |____/   \___|  \__| |____/   \__,_| |_| |_| |_|\_\
                        	  1086: 
                        	  1087: 
                        	  1088: ; *********************************************************************************************************************
                        	  1089: ; Set current bank from the command prompt
                        	  1090: ;	- Input:	An optional byte parameter, defaults to 0
                        	  1091: ; *********************************************************************************************************************
                        	  1092: ; Wishlist:
                        	  1093: ;	- Validation, only a nibble, and only 0-E
                        	  1094: ;	- Choice of BCD?
                        	  1095: 
                        	  1096: SetBank:
01:87C2 F5              	  1097: 	push	AF
01:87C3 C5              	  1098: 	push	BC
01:87C4 D5              	  1099: 	push	DE
01:87C5 E5              	  1100: 	push	HL
                        	  1101: 	
01:87C6 2AB5B0          	  1102: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87C9 CDCF88          	  1103: 	call	GetHexParameter			; Get a parameter
01:87CC 3020            	  1104: 	jr		nc,SetBankEnd			; Exit routine if there was an error in the parameter
01:87CE FE00            	  1105: 	cp		0						; Is there a parameter returned?
01:87D0 2810            	  1106: 	jr		z,SetBankDefault		; If there is none, select default bank
01:87D2 FE02            	  1107: 	cp		2
01:87D4 2815            	  1108: 	jr		z,SetBankError
                        	  1109: 	
01:87D6 79              	  1110: 	ld		A,C
01:87D7 FE0F            	  1111: 	cp		$0F
01:87D9 3010            	  1112: 	jr		nc,SetBankError
01:87DB 32B8B0          	  1113: 	ld		(CurrentBank),A			; Save nibble in parameter (C) in CurrentBank global variable
01:87DE D330            	  1114: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87E0 180C            	  1115: 	jr		SetBankEnd
                        	  1116: 
                        	  1117: SetBankDefault:
01:87E2 3E00            	  1118: 	ld		A,0						; Default bank is 0
01:87E4 32B8B0          	  1119: 	ld		(CurrentBank),A			; Save it in CurrentBank global variable
01:87E7 D330            	  1120: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87E9 1803            	  1121: 	jr		SetBankEnd
                        	  1122: 
                        	  1123: SetBankError:
01:87EB CD51B0          	  1124: 	call	InvalidBank
                        	  1125: 	
                        	  1126: SetBankEnd:
01:87EE E1              	  1127: 	pop		HL
01:87EF D1              	  1128: 	pop		DE
01:87F0 C1              	  1129: 	pop		BC
01:87F1 F1              	  1130: 	pop		AF
                        	  1131: 	
01:87F2 C9              	  1132: 	ret
                        	  1133: 	
                        	  1134: 	
                        	  1135: ;  ____                  ___            __         
                        	  1136: ; / ___|   _   _   ___  |_ _|  _ __    / _|   ___  
                        	  1137: ; \___ \  | | | | / __|  | |  | '_ \  | |_   / _ \ 
                        	  1138: ;  ___) | | |_| | \__ \  | |  | | | | |  _| | (_) |
                        	  1139: ; |____/   \__, | |___/ |___| |_| |_| |_|    \___/ 
                        	  1140: ;          |___/                                   
                        	  1141: 
                        	  1142: ; *********************************************************************************************************************
                        	  1143: ; Prints information about the ZedEighty (WiP)
                        	  1144: ; *********************************************************************************************************************
                        	  1145: 
                        	  1146: SysInfo:
01:87F3 E5              	  1147: 	push	HL
01:87F4 21B7AB          	  1148: 	ld		HL,SysInfoMsg			; Point the the text message
01:87F7 CDB080          	  1149: 	call	PrintString				; Print first line
01:87FA CD8E80          	  1150: 	call	PrintLine				; Print a line
01:87FD CDB080          	  1151: 	call	PrintString				; Print the rest
                        	  1152: 	
                        	  1153: 	; Speed in MHz
01:8800 CDB080          	  1154: 	call	PrintString
                        	  1155: 	
                        	  1156: 	; Free RAM
01:8803 E5              	  1157: 	push	HL
01:8804 21A0CB          	  1158: 	ld		HL,BytesFree			; Load the amount of bytes free
01:8807 CD5A80          	  1159: 	call	PrintDec				; Print decimal value
01:880A E1              	  1160: 	pop		HL
01:880B CDB080          	  1161: 	call	PrintString
                        	  1162: 	
01:880E E1              	  1163: 	pop		HL
01:880F C9              	  1164: 	ret
                        	  1165: 
                        	  1166: 
                        	  1167: ; __        __         _   _          
                        	  1168: ; \ \      / /  _ __  (_) | |_    ___ 
                        	  1169: ;  \ \ /\ / /  | '__| | | | __|  / _ \
                        	  1170: ;   \ V  V /   | |    | | | |_  |  __/
                        	  1171: ;    \_/\_/    |_|    |_|  \__|  \___|
                        	  1172: ;
                        	  1173: ; *********************************************************************************************************************
                        	  1174: ; Write up to 8 bytes into memory
                        	  1175: ; *********************************************************************************************************************
                        	  1176: 
                        	  1177: Write:
01:8810 F5              	  1178: 	push 	AF
01:8811 C5              	  1179: 	push	BC
01:8812 D5              	  1180: 	push	DE
01:8813 E5              	  1181: 	push	HL
                        	  1182: 	
01:8814 2AB5B0          	  1183: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	  1184: 	
                        	  1185: WriteGetAddress:
01:8817 CDCF88          	  1186: 	call	GetHexParameter			; Get the first parameter, start address
01:881A D25B88          	  1187: 	jp		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:881D FE00            	  1188: 	cp		0						; Is there a first parameter?
01:881F 2837            	  1189: 	jr		z,WriteNoParameter		; No, then print error message
01:8821 C5              	  1190: 	push	BC						; Store start address that's in BC
01:8822 D1              	  1191: 	pop		DE						; Into DE
                        	  1192: 
                        	  1193: WriteFirstByte:
01:8823 CDCF88          	  1194: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8826 3033            	  1195: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8828 FE00            	  1196: 	cp		0						; Is there a second parameter?
01:882A 282C            	  1197: 	jr		z,WriteNoParameter		; No, then print error message
01:882C FE02            	  1198: 	cp		2						; Is it bigger then a byte?
01:882E 301D            	  1199: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:8830 79              	  1200: 	ld		A,C						; Transfer byte in A
01:8831 12              	  1201: 	ld		(DE),A					; Save the byte
01:8832 13              	  1202: 	inc		DE						; Point to the next location
01:8833 ED53B9B0        	  1203: 	ld		(CurrentAddress),DE		; Set CurrentAddress
                        	  1204: 
                        	  1205: WriteRemainingBytes:
01:8837 CDCF88          	  1206: 	call	GetHexParameter			; Get the second parameter, byte to write
01:883A 301F            	  1207: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:883C FE00            	  1208: 	cp		0						; Is there another parameter?
01:883E 281B            	  1209: 	jr		z,WriteEnd				; No, then exit
01:8840 FE02            	  1210: 	cp		2						; Is it bigger then a byte?
01:8842 3009            	  1211: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:8844 79              	  1212: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:8845 12              	  1213: 	ld		(DE),A					; Save the byte
01:8846 13              	  1214: 	inc		DE						; Point to the next location
01:8847 ED53B9B0        	  1215: 	ld		(CurrentAddress),DE		; Set CurrentAddress
01:884B 18EA            	  1216: 	jr		WriteRemainingBytes		; See if there are other bytes
                        	  1217: 
                        	  1218: WriteTooManyDigits:
01:884D CDC588          	  1219: 	call	DecErrorPointer			; Back up pointer one
01:8850 CDC289          	  1220: 	call	PrintErrorPointer		; Print's pointer to actual error in command line
01:8853 CD5AB0          	  1221: 	call	TooManyDigits			; Print invalid number of digits message	
01:8856 1803            	  1222: 	jr		WriteEnd
                        	  1223: 	
                        	  1224: WriteNoParameter:
01:8858 CD45B0          	  1225: 	call	NoParameter
                        	  1226: 	
                        	  1227: WriteEnd:
01:885B E1              	  1228: 	pop		HL
01:885C D1              	  1229: 	pop		DE
01:885D C1              	  1230: 	pop		BC
01:885E F1              	  1231: 	pop		AF
01:885F C9              	  1232: 	ret
                        	  1233: 
                        	  1234: 
                        	  1235: ;  _____                           _      _   _   ____                      
                        	  1236: ; |__  /   ___   _ __    ___      / \    | | | | |  _ \    __ _   _ __ ___  
                        	  1237: ;   / /   / _ \ | '__|  / _ \    / _ \   | | | | | |_) |  / _` | | '_ ` _ \ 
                        	  1238: ;  / /_  |  __/ | |    | (_) |  / ___ \  | | | | |  _ <  | (_| | | | | | | |
                        	  1239: ; /____|  \___| |_|     \___/  /_/   \_\ |_| |_| |_| \_\  \__,_| |_| |_| |_|
                        	  1240: 
                        	  1241: 
                        	  1242: ; *********************************************************************************************************************
                        	  1243: ; Zero all the RAM, including all the RAM. Excludes shadow ROM (otherwise it will corrupt the BIOS), as well as
                        	  1244: ; vector pages.
                        	  1245: ; *********************************************************************************************************************
                        	  1246: 
                        	  1247: ZeroAllRam:
01:8860 F5              	  1248: 	push	AF
01:8861 C5              	  1249: 	push	BC
01:8862 D5              	  1250: 	push	DE
01:8863 E5              	  1251: 	push	HL
                        	  1252: 	
01:8864 3E0E            	  1253: 	ld		A,$E
                        	  1254: ZeroLowRange:
01:8866 D330            	  1255: 	out		(BankSelect),A
01:8868 210080          	  1256: 	ld		HL,StartOfCode			; Load end address
01:886B 2B              	  1257: 	dec		HL
01:886C 118000          	  1258: 	ld		DE,InterruptVectorEnd	; Load start
01:886F B7              	  1259: 	or		A						; Clear carry flag
01:8870 ED52            	  1260: 	sbc		HL,DE					; HL = HL - DE
01:8872 E5              	  1261: 	push	HL						; Put result of byte count
01:8873 C1              	  1262: 	pop		BC						; Into the byte count register
01:8874 218000          	  1263: 	ld		HL,InterruptVectorEnd	; Set source address
01:8877 F5              	  1264: 	push	AF
01:8878 3E00            	  1265: 	ld		A,0						; Grab byte to write
01:887A 77              	  1266: 	ld		(HL),A					; Save it at the source address
01:887B F1              	  1267: 	pop		AF
01:887C 118000          	  1268: 	ld		DE,InterruptVectorEnd	; Place destination address
01:887F 13              	  1269: 	inc		DE
01:8880 EDB0            	  1270: 	ldir
01:8882 3D              	  1271: 	dec		A
01:8883 FEFF            	  1272: 	cp		$FF
01:8885 20DF            	  1273: 	jr		nz,ZeroLowRange
                        	  1274: 
                        	  1275: ZeroHighRange:
01:8887 2100FD          	  1276: 	ld		HL,VectorTable			; Load end address
01:888A 2B              	  1277: 	dec		HL
01:888B 11E0B0          	  1278: 	ld		DE,EndOfCode			; Load start
01:888E B7              	  1279: 	or		A						; Clear carry flag
01:888F ED52            	  1280: 	sbc		HL,DE					; HL = HL - DE
01:8891 E5              	  1281: 	push	HL						; Put result of byte count
01:8892 C1              	  1282: 	pop		BC						; Into the byte count register
01:8893 21E0B0          	  1283: 	ld		HL,EndOfCode			; Set source address
01:8896 3E00            	  1284: 	ld		A,0						; Grab byte to write
01:8898 77              	  1285: 	ld		(HL),A					; Save it at the source address
01:8899 11E0B0          	  1286: 	ld		DE,EndOfCode			; Place destination address
01:889C 13              	  1287: 	inc		DE
01:889D EDB0            	  1288: 	ldir
                        	  1289: 
01:889F 37              	  1290: 	scf								; Set Carry, indicates no error to calling program
                        	  1291: 
                        	  1292: ZeroEnd:
01:88A0 E1              	  1293: 	pop		HL
01:88A1 D1              	  1294: 	pop		DE
01:88A2 C1              	  1295: 	pop		BC
01:88A3 F1              	  1296: 	pop		AF
01:88A4 C9              	  1297: 	ret
                        	  1298: 
                        	  1299: 

Source: "main.asm"
                        	   273: 	.include	"ancillary.asm"		; Anscillary subroutines for monitor commands

Source: "ancillary.asm"
                        	     1: ; Ancillary monitor routines in this include file:
                        	     2: ; ------------------------------------------------
                        	     3: ;	- CommandPrompt					; {}
                        	     4: ;	- GetHexParameter				; [(HL) -> BC,A,(HL)]
                        	     5: ;	- Parse							; (HL)
                        	     6: ;	- SkipSpaces					; [HL -> HL]
                        	     7: 
                        	     8: 
                        	     9: ;   ____                                                       _   ____                                       _   
                        	    10: ;  / ___|   ___    _ __ ___    _ __ ___     __ _   _ __     __| | |  _ \   _ __    ___    _ __ ___    _ __   | |_ 
                        	    11: ; | |      / _ \  | '_ ` _ \  | '_ ` _ \   / _` | | '_ \   / _` | | |_) | | '__|  / _ \  | '_ ` _ \  | '_ \  | __|
                        	    12: ; | |___  | (_) | | | | | | | | | | | | | | (_| | | | | | | (_| | |  __/  | |    | (_) | | | | | | | | |_) | | |_ 
                        	    13: ;  \____|  \___/  |_| |_| |_| |_| |_| |_|  \__,_| |_| |_|  \__,_| |_|     |_|     \___/  |_| |_| |_| | .__/   \__|
                        	    14: ;                                                                                                    |_|          
                        	    15: 
                        	    16: ; *********************************************************************************************************************
                        	    17: ; Prints the prompt to console
                        	    18: ; *********************************************************************************************************************
                        	    19: 
                        	    20: CommandPrompt:
01:88A5 F5              	    21: 	push	AF
01:88A6 E5              	    22: 	push	HL
01:88A7 3AB8B0          	    23: 	ld		A,(CurrentBank)			; Get Current Bank number
01:88AA CD6380          	    24: 	call	PrintByte				; Print it
01:88AD 3E3A            	    25: 	ld		A,":"					; 
01:88AF CD7680          	    26: 	call	PrintChar				; Print colon symbol
01:88B2 2AB9B0          	    27: 	ld		HL,(CurrentAddress)
01:88B5 CDBE80          	    28: 	call	PrintWord				; Print current address poointer
01:88B8 3E3E            	    29: 	ld		A,">"					; 
01:88BA CD7680          	    30: 	call	PrintChar				; Print prompt symbol
01:88BD 3E20            	    31: 	ld		A," "					; 
01:88BF CD7680          	    32: 	call	PrintChar				; Print a space
01:88C2 E1              	    33: 	pop		HL
01:88C3 F1              	    34: 	pop		AF
01:88C4 C9              	    35: 	ret
                        	    36: 
                        	    37: 
                        	    38: ;  ____                  _____                                ____            _           _                 
                        	    39: ; |  _ \    ___    ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	    40: ; | | | |  / _ \  / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	    41: ; | |_| | |  __/ | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	    42: ; |____/   \___|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	    43: ;
                        	    44: ;
                        	    45: ; *********************************************************************************************************************
                        	    46: ; Decrement error pointer by one
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: DecErrorPointer:
01:88C5 F5              	    50: 	push	AF
01:88C6 3AB7B0          	    51: 	ld		A,(CmdErrorPointer)
01:88C9 3D              	    52: 	dec		A
01:88CA 32B7B0          	    53: 	ld		(CmdErrorPointer),A
01:88CD F1              	    54: 	pop		AF
01:88CE C9              	    55: 	ret
                        	    56: 
                        	    57: 
                        	    58: ;   ____          _     _   _                 ____                                              _                 
                        	    59: ;  / ___|   ___  | |_  | | | |   ___  __  __ |  _ \    __ _   _ __    __ _   _ __ ___     ___  | |_    ___   _ __ 
                        	    60: ; | |  _   / _ \ | __| | |_| |  / _ \ \ \/ / | |_) |  / _` | | '__|  / _` | | '_ ` _ \   / _ \ | __|  / _ \ | '__|
                        	    61: ; | |_| | |  __/ | |_  |  _  | |  __/  >  <  |  __/  | (_| | | |    | (_| | | | | | | | |  __/ | |_  |  __/ | |   
                        	    62: ;  \____|  \___|  \__| |_| |_|  \___| /_/\_\ |_|      \__,_| |_|     \__,_| |_| |_| |_|  \___|  \__|  \___| |_|   
                        	    63: ;
                        	    64: ;
                        	    65: ; *********************************************************************************************************************
                        	    66: ; Read a hexadecimal parameter from the CommandBuffer
                        	    67: ;	- Input:	HL = Buffer pointer of command buffer, points to parameter
                        	    68: ;	- Output:	BC = contains the converted Hex number (if it's a byte B is 0, C is the converted byte) 
                        	    69: ;				A = 0 is no parameter, 1 is a byte, 2 is a word
                        	    70: ;				HL = New position of pointer
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: GetHexParameter:
01:88CF CD3D8B          	    75: 	call	SkipSpaces				; Skip any spaces if any
01:88D2 E5              	    76: 	push	HL						; Save it, restoring it after character count
01:88D3 0E00            	    77: 	ld		C,$00					; Character count set to zero
                        	    78: 	
                        	    79: GetParamCount:
01:88D5 7E              	    80: 	ld		A,(HL)					; Read a character form the CommandBuffer
01:88D6 FE00            	    81: 	cp		0						; Is it the end of the CommandBuffer?
01:88D8 280C            	    82: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88DA FE20            	    83: 	cp		DELIMITER				; If it's the delimiter for the next parameter
01:88DC 2808            	    84: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88DE FE3F            	    85: 	cp		"?"
01:88E0 2852            	    86: 	jr		z,GetParamHelp
01:88E2 23              	    87: 	inc		HL						; Increment buffer pointer to next character in parameter
01:88E3 0C              	    88: 	inc		C						; Add one, to the count of characters
01:88E4 18EF            	    89: 	jr		GetParamCount			; Loop if delimiter has not been reached
                        	    90: 
                        	    91: GetParamFetch:
01:88E6 79              	    92: 	ld		A,C						; Load counted characters into accumulator
01:88E7 E1              	    93: 	pop		HL						; Restore pointer back to it's original position
01:88E8 010000          	    94: 	ld		BC,$0000				; Clear the results register to store a nibble, byte or nibble+byte
                        	    95: 
                        	    96: GetParamFetch0;
01:88EB FE00            	    97: 	cp		0						; Was a parameter specified?
01:88ED 2004            	    98: 	jr		nz,GetParamFetch1		; No then check for 1 
01:88EF 3E00            	    99: 	ld		A,0						; Returns 0 to indicate no parameters
01:88F1 183F            	   100: 	jr		GetParameterEnd			; End routine
                        	   101: 	
                        	   102: GetParamFetch1:
01:88F3 FE01            	   103: 	cp		1						; Was it only one digit?
01:88F5 200C            	   104: 	jr		nz,GetParamFetch2		; No then check for 2
01:88F7 7E              	   105: 	ld		A,(HL)
01:88F8 23              	   106: 	inc		HL
01:88F9 CD6B81          	   107: 	call	Ascii2HexNibble			; Convert an ASCII char in HL to a 4-bit hex value
01:88FC 304A            	   108: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:88FE 4F              	   109: 	ld		C,A						; Save value in LSB of C
01:88FF 3E01            	   110: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:8901 182F            	   111: 	jr		GetParameterEnd			; End routine
                        	   112: 
                        	   113: GetParamFetch2:
01:8903 FE02            	   114: 	cp		2						; Was it two digits?
01:8905 200A            	   115: 	jr		nz,GetParamFetch3		; No then check for 3
01:8907 CD8F81          	   116: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:890A 303C            	   117: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:890C 4F              	   118: 	ld		C,A						; Save value in C
01:890D 3E01            	   119: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:890F 1821            	   120: 	jr		GetParameterEnd			; End routine
                        	   121: 
                        	   122: GetParamFetch3:
01:8911 FE03            	   123: 	cp		3						; Was three digits?
01:8913 2012            	   124: 	jr		nz,GetParamFetch4		; No then check for 4
01:8915 7E              	   125: 	ld		A,(HL)
01:8916 23              	   126: 	inc		HL
01:8917 CD6B81          	   127: 	call	Ascii2HexNibble			; Convert the first ASCII char in HL to a hex value
01:891A 302C            	   128: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:891C 47              	   129: 	ld		B,A						; Save result in D
01:891D CD8F81          	   130: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:8920 3026            	   131: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:8922 4F              	   132: 	ld		C,A						; Store resulting byte in C (LSB)
01:8923 3E02            	   133: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
01:8925 180B            	   134: 	jr		GetParameterEnd			; End routine
                        	   135: 
                        	   136: GetParamFetch4:
01:8927 FE04            	   137: 	cp		4						; Was four digits?
01:8929 200E            	   138: 	jr		nz,GetParamNumberError	; Print error message
01:892B CDAE81          	   139: 	call	Ascii2HexWord			; Convert a 4-character hex digit pointed by HL to a hex value
01:892E 3018            	   140: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:8930 3E02            	   141: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
                        	   142: 
                        	   143: GetParameterEnd:
01:8932 37              	   144: 	scf								; Set carry to indicate all is ok
01:8933 C9              	   145: 	ret
                        	   146: 
                        	   147: GetParamHelp:
01:8934 F1              	   148: 	pop		AF						; Dummy pop from stack as there was a push before
01:8935 3E0F            	   149: 	ld		A,HELP
01:8937 37              	   150: 	scf
01:8938 C9              	   151: 	ret
                        	   152: 
                        	   153: GetParamNumberError:
01:8939 0604            	   154: 	ld		B,4						;
                        	   155: GetErrorPointerLoop:
01:893B CD5089          	   156: 	call	IncErrorPointer			;
01:893E 10FB            	   157: 	djnz	GetErrorPointerLoop		;
01:8940 CDC289          	   158: 	call	PrintErrorPointer
01:8943 CD5AB0          	   159: 	call	TooManyDigits			; Print invalid number of digits message	
01:8946 1806            	   160: 	jr		GetParamErrorEnd		; End Error handling
                        	   161: 
                        	   162: GetParamHexError:
01:8948 CDC289          	   163: 	call	PrintErrorPointer
01:894B CD63B0          	   164: 	call	InvalidHexDigit			;Print invalid hex character message
                        	   165: 
                        	   166: GetParamErrorEnd:
01:894E B7              	   167: 	or		A						; Clear carry
01:894F C9              	   168: 	ret
                        	   169: 
                        	   170: 
                        	   171: ;  ___                  _____                                ____            _           _                 
                        	   172: ; |_ _|  _ __     ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   173: ;  | |  | '_ \   / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   174: ;  | |  | | | | | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   175: ; |___| |_| |_|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   176: ;
                        	   177: ;
                        	   178: ; *********************************************************************************************************************
                        	   179: ; Increment error pointer by one
                        	   180: ; *********************************************************************************************************************
                        	   181: 
                        	   182: IncErrorPointer:
01:8950 F5              	   183: 	push	AF
01:8951 3AB7B0          	   184: 	ld		A,(CmdErrorPointer)
01:8954 3C              	   185: 	inc		A
01:8955 32B7B0          	   186: 	ld		(CmdErrorPointer),A
01:8958 F1              	   187: 	pop		AF
01:8959 C9              	   188: 	ret
                        	   189: 
                        	   190: 
                        	   191: ;  ____                                     
                        	   192: ; |  _ \    __ _   _ __   ___    ___   _ __ 
                        	   193: ; | |_) |  / _` | | '__| / __|  / _ \ | '__|
                        	   194: ; |  __/  | (_| | | |    \__ \ |  __/ | |   
                        	   195: ; |_|      \__,_| |_|    |___/  \___| |_|   
                        	   196: ;
                        	   197: ;
                        	   198: ; *********************************************************************************************************************
                        	   199: ; Parse the string and compare the commands list and the command prompt, then execute if found
                        	   200: ;	- Output:	BufferPointer points to parameter, if any
                        	   201: ; *********************************************************************************************************************
                        	   202: ;	- A = Command buffer character
                        	   203: ;	- B	= Command list character
                        	   204: ;	- DE = Command list pointer
                        	   205: ;	- HL = Command buffer pointer
                        	   206: 
                        	   207: Parser:
01:895A F5              	   208: 	push	AF
01:895B C5              	   209: 	push	BC
01:895C D5              	   210: 	push	DE
01:895D 22C5B0          	   211: 	ld		(ParseSaveHL),HL		; Saves HL register, because it's not possible to push it due to routine call
                        	   212: 
01:8960 CD358B          	   213: 	call	ResetErrorPointer		; Reset error pointer to start position
01:8963 11BEA8          	   214: 	ld		DE,CommandList			; Commands list pointer
01:8966 218DB0          	   215: 	ld		HL,CommandBuffer		; Command buffer pointer
01:8969 CD3D8B          	   216: 	call	SkipSpaces				; Removes any leading spaces in command buffer
01:896C 22B5B0          	   217: 	ld		(BufferPointer),HL		; Save the position of the first character for later
01:896F 7E              	   218: 	ld		A,(HL)					; Read first character or delimiter of the command in command buffer
01:8970 FE00            	   219: 	cp		0						; Is it the end of the string already?
01:8972 2847            	   220: 	jr		z,ParseEnd				; If so, then exit parser routine
                        	   221: 
                        	   222: ParseNextChar:
01:8974 7E              	   223: 	ld		A,(HL)					; Read a character from the command buffer
01:8975 CDA182          	   224: 	call	UpperCase				; Change the case to uppercase, as the command list is in uppercase
01:8978 47              	   225: 	ld		B,A						; Put the uppercase character read from string in B
01:8979 1A              	   226: 	ld		A,(DE)					; Load a command list character in accumulator
01:897A FEFF            	   227: 	cp		EOT						; Has the end of the command list been reached?
01:897C 2837            	   228: 	jr		z,ParseInvalid			; Teache the End Of Table, no matching commands has been found
01:897E FEC3            	   229: 	cp		JUMP					; Is it a command delimiter? (Which is actualy a jp opcode)
01:8980 281B            	   230: 	jr		z,ParseValidate			; Yes, then execute command
01:8982 B8              	   231: 	cp		B						; Is the letter from the list matching the buffer?
01:8983 2007            	   232: 	jr		nz,ParseNextCmd			; If not the same, go to next command in the list
01:8985 CD5089          	   233: 	call	IncErrorPointer			; Increment command line error pointer
01:8988 13              	   234: 	inc		DE						; Increment command list pointer to the next character
01:8989 23              	   235: 	inc		HL						; Increment command buffer pointer to tne next character
01:898A 18E8            	   236: 	jr		ParseNextChar			; Get the next character from command list
                        	   237: 
                        	   238: ParseNextCmd:
01:898C 13              	   239: 	inc		DE						; Increment command list pointer to eventually go to next command
01:898D 1A              	   240: 	ld		A,(DE)					; Load from command list
01:898E FEC3            	   241: 	cp		JUMP					; Is it the End Of Command delimiter?
01:8990 20FA            	   242: 	jr		nz,ParseNextCmd			; No, then repeat until found
01:8992 13              	   243: 	inc		DE						; It is then bypass jump address
01:8993 13              	   244: 	inc		DE						; Point to the first character of following command
01:8994 13              	   245: 	inc		DE						;
01:8995 2AB5B0          	   246: 	ld		HL,(BufferPointer)		; Restore location of first valid command buffer character
01:8998 CD358B          	   247: 	call	ResetErrorPointer		; Reset error pointer to start position
01:899B 18D7            	   248: 	jr		ParseNextChar			; Loop back to read next character in list
                        	   249: 
                        	   250: ParseValidate:
01:899D 7E              	   251: 	ld		A,(HL)					; Check for extra unwanted characters by enforcing space delimiter
01:899E FE00            	   252: 	cp		0						; Check if it's the end of the buffer
01:89A0 2804            	   253: 	jr		z,ParseExecute			; It's the end of the buffer, execute command
01:89A2 FE20            	   254: 	cp		DELIMITER				; Is the space delimiter present in the command buffer?
01:89A4 200F            	   255: 	jr		nz,ParseInvalid			; No, then it's not valid
                        	   256: 
                        	   257: ParseExecute:
01:89A6 22B5B0          	   258: 	ld		(BufferPointer),HL		; Save current command buffer pointer for jump command parameters, if applicable
01:89A9 EB              	   259: 	ex		DE,HL					; Exchange DE with HL registers to be able to use HL for jumping
                        	   260: ;	jp		(HL)					; Execute command at address in DE (now HL)
                        	   261: 
01:89AA D1              	   262: 	pop		DE
01:89AB C1              	   263: 	pop		BC
01:89AC F1              	   264: 	pop		AF
01:89AD E5              	   265: 	push	HL						; Save call address
01:89AE 2AC5B0          	   266: 	ld		HL,(ParseSaveHL)		; Restore HL
01:89B1 C9              	   267: 	ret								; Perform indirect call (HL)
01:89B2 C34680          	   268: 	jp		Main					; Go to main
                        	   269: 	
                        	   270: ParseInvalid:
01:89B5 217EAC          	   271: 	ld		HL,ParseInvalidErr
01:89B8 CDB080          	   272: 	call	PrintString
                        	   273: 
                        	   274: ParseEnd:
01:89BB 2AC5B0          	   275: 	ld		HL,(ParseSaveHL)
01:89BE D1              	   276: 	pop		DE
01:89BF C1              	   277: 	pop		BC
01:89C0 F1              	   278: 	pop		AF
                        	   279: 	
01:89C1 C9              	   280: 	ret
                        	   281: 
                        	   282: 
                        	   283: ;  ____           _           _     _____                                ____            _           _                 
                        	   284: ; |  _ \   _ __  (_)  _ __   | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   285: ; | |_) | | '__| | | | '_ \  | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   286: ; |  __/  | |    | | | | | | | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   287: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   288: ;
                        	   289: ;
                        	   290: ; *********************************************************************************************************************
                        	   291: ; Print error pointer character under the command line, pointing to the culprit
                        	   292: ; *********************************************************************************************************************
                        	   293: 
                        	   294: PrintErrorPointer:
01:89C2 F5              	   295: 	push	AF
01:89C3 C5              	   296: 	push	BC
                        	   297: 	
01:89C4 3AB7B0          	   298: 	ld		A,(CmdErrorPointer)		; Load error pointer as counter
01:89C7 47              	   299: 	ld		B,A
                        	   300: PrintErrorLoop:
01:89C8 3E20            	   301: 	ld		A," "
01:89CA CD7680          	   302: 	call	PrintChar				; Print a space character
01:89CD 10F9            	   303: 	djnz	PrintErrorLoop			; Decrement B, and repeat printing space, until 0
01:89CF 3E5E            	   304: 	ld		A,ERRORPTR
01:89D1 CD7680          	   305: 	call	PrintChar				; Print the error pointer character
01:89D4 CD8180          	   306: 	call	PrintCRLF				; Change line
                        	   307: 	
01:89D7 C1              	   308: 	pop		BC
01:89D8 F1              	   309: 	pop		AF
01:89D9 C9              	   310: 	ret
                        	   311: 
                        	   312: 
                        	   313: ;  ____                                  __     __          _   _       _           _     _                 
                        	   314: ; |  _ \    __ _   _ __     __ _    ___  \ \   / /   __ _  | | (_)   __| |   __ _  | |_  (_)   ___    _ __  
                        	   315: ; | |_) |  / _` | | '_ \   / _` |  / _ \  \ \ / /   / _` | | | | |  / _` |  / _` | | __| | |  / _ \  | '_ \ 
                        	   316: ; |  _ <  | (_| | | | | | | (_| | |  __/   \ V /   | (_| | | | | | | (_| | | (_| | | |_  | | | (_) | | | | |
                        	   317: ; |_| \_\  \__,_| |_| |_|  \__, |  \___|    \_/     \__,_| |_| |_|  \__,_|  \__,_|  \__| |_|  \___/  |_| |_|
                        	   318: ;                          |___/                                                                            
                        	   319: 
                        	   320: ; *********************************************************************************************************************
                        	   321: ; Validates a range of addresses that can be written to with commands such as Fill and Zero. The range returns
                        	   322: ; one or two ranges (before BIOS and after BIOS). It excludes BIOS, Interrupt vectors, jump table, and stack.
                        	   323: ; - Input:	StartAddress, EndAddress
                        	   324: ; - Output:	Updated StartAddress and EndAddress for low range, and StartAddressAlt and EndAddressAlt for high range
                        	   325: ;			C = Flags: bit0 = Low bank, bit1 = High bank
                        	   326: ; *********************************************************************************************************************
                        	   327: 
                        	   328: RangeValidation:
01:89DA F5              	   329: 	push	AF
01:89DB D5              	   330: 	push	DE
01:89DC E5              	   331: 	push	HL
                        	   332: 	
01:89DD 0E00            	   333: 	ld		C,0						; Clear the region flag
01:89DF 210000          	   334: 	ld		HL,0
01:89E2 22D9B0          	   335: 	ld		(StartAddressAlt),HL	; Reset alternate start address (that represents low memory)
01:89E5 22DBB0          	   336: 	ld		(EndAddressAlt),HL		; Reset alternate end address (that represents high memory)
                        	   337: 	
                        	   338: ; CHECK ORDER OF START AND END ADDRESSES, AND IF RANGE IS ZERO
                        	   339: ; ------------------------------------------------------------
                        	   340: ValCheckInverted:
01:89E8 2AD5B0          	   341: 	ld		HL,(StartAddress)		; Load start address
01:89EB ED5BD7B0        	   342: 	ld		DE,(EndAddress)			; Load end address
01:89EF B7              	   343: 	or		A						; Clear carry flag
01:89F0 ED52            	   344: 	sbc		HL,DE					; HL = HL - DE
01:89F2 CA218B          	   345: 	jp		z,ValRangeTooSmallError	; If the range is 0, then print invalid error and exit
01:89F5 D2278B          	   346: 	jp		nc,ValInvertedError		; If start address is higher than the end address, then print error and exit
                        	   347: 
                        	   348: ; CHECK IF THE START AND END ADDRESSES ARE IN THE VECTOR AREAS AND AJUST THEM ACCORDINGLY
                        	   349: ; ----------------------------------------------------------------------------------------
                        	   350: ValCheckLowLimit:					; VALIDATE START ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:89F8 2AD5B0          	   351: 	ld		HL,(StartAddress)		; Load start address
01:89FB 118100          	   352: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:89FE B7              	   353: 	or		A						; Clear carry flag
01:89FF ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:8A01 3006            	   355: 	jr		nc, ValCheckLowLimit2	; If it's not in the interrupt vector table, continue to next validation 
01:8A03 218000          	   356: 	ld		HL,InterruptVectorEnd			; Load 
01:8A06 22D5B0          	   357: 	ld		(StartAddress),HL
                        	   358: 
                        	   359: ValCheckLowLimit2:					; VALIDATE END ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:8A09 2AD7B0          	   360: 	ld		HL,(EndAddress)			; Load end address
01:8A0C 118100          	   361: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:8A0F B7              	   362: 	or		A						; Clear carry flag
01:8A10 ED52            	   363: 	sbc		HL,DE					; HL = HL - DE
01:8A12 DA2D8B          	   364: 	jp		c, RangeValidationError	; If it's in the interrupt vector table, print error and exit
                        	   365: 
                        	   366: ValCheckHighLimit:					; VALIDATE END ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A15 2AD7B0          	   367: 	ld		HL,(EndAddress)			; Load start address
01:8A18 1100FD          	   368: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A1B B7              	   369: 	or		A						; Clear carry flag
01:8A1C ED52            	   370: 	sbc		HL,DE					; HL = HL - DE
01:8A1E 3806            	   371: 	jr		c, ValCheckHighLimit2	; If it's not in the vector tables, continue to next validation
01:8A20 21FFFC          	   372: 	ld		HL,VectorTable-1		; Load Start of vector table area
01:8A23 22D7B0          	   373: 	ld		(EndAddress),HL
                        	   374: 	
                        	   375: ValCheckHighLimit2:					; VALIDATE START ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A26 2AD5B0          	   376: 	ld		HL,(StartAddress)		; Load start address
01:8A29 1100FD          	   377: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A2C B7              	   378: 	or		A						; Clear carry flag
01:8A2D ED52            	   379: 	sbc		HL,DE					; HL = HL - DE
01:8A2F D22D8B          	   380: 	jp		nc,RangeValidationError	; If it's in the interrupt vector table, then change upper limit 
                        	   381: 
                        	   382: ; CHECK IF THE RANGE IS COMPLETELY IN BIOS ZONE
                        	   383: ; ---------------------------------------------
                        	   384: ValCheckBiosLow:
01:8A32 2AD5B0          	   385: 	ld		HL,(StartAddress)		; Load start address
01:8A35 110080          	   386: 	ld		DE,StartOfCode			; Load start of code to compare too
01:8A38 B7              	   387: 	or		A						; Clear carry flag
01:8A39 ED52            	   388: 	sbc		HL,DE					; HL = HL - DE
01:8A3B 380E            	   389: 	jr		c,ValCheckHigh			; If start address is lower than the start of code, then check if in high RRAM
                        	   390: 
                        	   391: ValCheckBiosHi:
01:8A3D 2AD7B0          	   392: 	ld		HL,(EndAddress)			; Load end address
01:8A40 11E0B0          	   393: 	ld		DE,EndOfCode			; Load end of code address to compare too
01:8A43 B7              	   394: 	or		A						; Clear carry flag
01:8A44 ED52            	   395: 	sbc		HL,DE					; HL = HL - DE
01:8A46 3003            	   396: 	jr		nc,ValCheckHigh			; If end address is higher than the end of code, then check if in high RAM
01:8A48 C31B8B          	   397: 	jp		ValBiosRangeError		; Else print invalid range and exit
                        	   398: 
                        	   399: ; CHECK IF RANGE IS IN HIGH MEMORY
                        	   400: ; --------------------------------
                        	   401: ValCheckHigh:
                        	   402: 	; Is it in high memory?
01:8A4B 2AD5B0          	   403: 	ld		HL,(StartAddress)		; Load start address
01:8A4E 110080          	   404: 	ld		DE,StartOfCode			; Load start of code address
01:8A51 B7              	   405: 	or		A						; Clear carry flag
01:8A52 ED52            	   406: 	sbc		HL,DE					; HL = HL - DE
                        	   407: 	; No, then check for low memory
01:8A54 3829            	   408: 	jr		c,ValCheckLow
                        	   409: 
                        	   410: 	; Is it in high memory, but is it within the BIOS region?
01:8A56 2AD5B0          	   411: 	ld		HL,(StartAddress)		; Load start address
01:8A59 11E0B0          	   412: 	ld		DE,EndOfCode			; Load end of code address
01:8A5C B7              	   413: 	or		A						; Clear carry flag
01:8A5D ED52            	   414: 	sbc		HL,DE					; HL = HL - DE
                        	   415: 	; Yes, then change StartAddress to upper limit of BIOS
01:8A5F 3810            	   416: 	jr		c,ValCheckHighBios
                        	   417: 	; No, then only copy start and end addresses to the Alt locations
01:8A61 2AD5B0          	   418: 	ld		HL,(StartAddress)		;
01:8A64 22D9B0          	   419: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A67 2AD7B0          	   420: 	ld		HL,(EndAddress)			;
01:8A6A 22DBB0          	   421: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A6D CBC9            	   422: 	set		1,C						; Flag high address
01:8A6F 180E            	   423: 	jr		ValCheckLow
                        	   424: 
                        	   425: ValCheckHighBios:
01:8A71 21E0B0          	   426: 	ld		HL,EndOfCode		;
01:8A74 22D9B0          	   427: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A77 2AD7B0          	   428: 	ld		HL,(EndAddress)			;
01:8A7A 22DBB0          	   429: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A7D CBC9            	   430: 	set		1,C						; Flag high address
                        	   431: 	
                        	   432: ; CHECK IF RANGE IS IN LOW MEMORY
                        	   433: ; -------------------------------
                        	   434: ValCheckLow:
                        	   435: 	; Is it in low memory only?
01:8A7F 2AD7B0          	   436: 	ld		HL,(EndAddress)			; Load start address
01:8A82 11E0B0          	   437: 	ld		DE,EndOfCode			; Load start of code address
01:8A85 B7              	   438: 	or		A						; Clear carry flag
01:8A86 ED52            	   439: 	sbc		HL,DE					; HL = HL - DE
                        	   440: 	; No, then it overlaps BIOS
01:8A88 3018            	   441: 	jr		nc,ValBiosOverlap
                        	   442: 
                        	   443: 	; Is it in low memory, but is it within the BIOS region?
01:8A8A 2AD7B0          	   444: 	ld		HL,(EndAddress)			; Load start address
01:8A8D 110080          	   445: 	ld		DE,StartOfCode			; Load end of code address
01:8A90 B7              	   446: 	or		A						; Clear carry flag
01:8A91 ED52            	   447: 	sbc		HL,DE					; HL = HL - DE
                        	   448: 	; Yes, then change EndAddress to lower limit of BIOS
01:8A93 3004            	   449: 	jr		nc,ValCheckLowBios
                        	   450: 	; No, then only flag low memory
01:8A95 CBC1            	   451: 	set		0,C						; Flag low address
01:8A97 1809            	   452: 	jr		ValBiosOverlap
                        	   453: 
                        	   454: ValCheckLowBios:
01:8A99 210080          	   455: 	ld		HL,StartOfCode			;
01:8A9C 2B              	   456: 	dec		HL
01:8A9D 22D7B0          	   457: 	ld		(EndAddress),HL			; Set start address at the end of code, in case it overlapped
01:8AA0 CBC1            	   458: 	set		0,C						; Flag low address
                        	   459: 
                        	   460: ; CHECK IF RANGE OVERLAPS BIOS AREA
                        	   461: ; ---------------------------------
                        	   462: ValBiosOverlap:
01:8AA2 79              	   463: 	ld		A,C
01:8AA3 FE00            	   464: 	cp		0
01:8AA5 2017            	   465: 	jr		nz,ValCheckIfZeroDataLow
                        	   466: 	; Move EndAddress to the Alternate one
01:8AA7 2AD7B0          	   467: 	ld		HL,(EndAddress)
01:8AAA 22DBB0          	   468: 	ld		(EndAddressAlt),HL
                        	   469: 	; Change low memory EndAddress to beginning of BIOS -1
01:8AAD 210080          	   470: 	ld		HL,StartOfCode		
01:8AB0 2B              	   471: 	dec		HL
01:8AB1 22D7B0          	   472: 	ld		(EndAddress),HL
                        	   473: 	; Change high memory StartAddressAlt to end of BIOS
01:8AB4 21E0B0          	   474: 	ld		HL,EndOfCode
01:8AB7 22D9B0          	   475: 	ld		(StartAddressAlt),HL
01:8ABA CBC1            	   476: 	set		0,C						; Flag low address
01:8ABC CBC9            	   477: 	set		1,C						; Flag high address
                        	   478: 
                        	   479: ; CHECK IF RANGE(S) ARE ZERO, WITH REASSIGNMENT, IT'S POSSIBLE
                        	   480: ; ------------------------------------------------------------
                        	   481: ValCheckIfZeroDataLow:
01:8ABE CB41            	   482: 	bit		0,C
01:8AC0 280C            	   483: 	jr		z,ValCheckIfZeroDataHigh
01:8AC2 2AD5B0          	   484: 	ld		HL,(StartAddress)		; Load start address
01:8AC5 ED5BD7B0        	   485: 	ld		DE,(EndAddress)			; Load end address
01:8AC9 B7              	   486: 	or		A						; Clear carry flag
01:8ACA ED52            	   487: 	sbc		HL,DE					; HL = HL - DE
01:8ACC 2853            	   488: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   489: 
                        	   490: ValCheckIfZeroDataHigh:
01:8ACE CB49            	   491: 	bit		1,C
01:8AD0 280C            	   492: 	jr		z,ValPrintRange
01:8AD2 2AD9B0          	   493: 	ld		HL,(StartAddressAlt)	; Load alternate start address
01:8AD5 ED5BDBB0        	   494: 	ld		DE,(EndAddressAlt)		; Load alternate end address
01:8AD9 B7              	   495: 	or		A						; Clear carry flag
01:8ADA ED52            	   496: 	sbc		HL,DE					; HL = HL - DE
01:8ADC 2843            	   497: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   498: 
                        	   499: 	; PRINTS ADDRESS RANGE
                        	   500: ValPrintRange:
01:8ADE CD18B0          	   501: 	call	Range
                        	   502: 
                        	   503: ValPrintRange1:
01:8AE1 CB41            	   504: 	bit		0,C
01:8AE3 2816            	   505: 	jr		z,ValPrintRange2
01:8AE5 3E20            	   506: 	ld		A," "
01:8AE7 CD7680          	   507: 	call	PrintChar
01:8AEA 2AD5B0          	   508: 	ld		HL,(StartAddress)
01:8AED CDBE80          	   509: 	call	PrintWord
01:8AF0 3E2D            	   510: 	ld		A,"-"
01:8AF2 CD7680          	   511: 	call	PrintChar
01:8AF5 2AD7B0          	   512: 	ld		HL,(EndAddress)
01:8AF8 CDBE80          	   513: 	call	PrintWord
                        	   514: 	
                        	   515: ValPrintRange2:
01:8AFB CB49            	   516: 	bit		1,C
01:8AFD 2816            	   517: 	jr		z,ValPrintRangeEnd
01:8AFF 3E20            	   518: 	ld		A," "
01:8B01 CD7680          	   519: 	call	PrintChar
01:8B04 2AD9B0          	   520: 	ld		HL,(StartAddressAlt)
01:8B07 CDBE80          	   521: 	call	PrintWord
01:8B0A 3E2D            	   522: 	ld		A,"-"
01:8B0C CD7680          	   523: 	call	PrintChar
01:8B0F 2ADBB0          	   524: 	ld		HL,(EndAddressAlt)
01:8B12 CDBE80          	   525: 	call	PrintWord	
                        	   526: 
                        	   527: ValPrintRangeEnd:
01:8B15 CD8180          	   528: 	call	PrintCRLF
01:8B18 37              	   529: 	scf								; Set carry
01:8B19 1816            	   530: 	jr		RangeValidationEnd
                        	   531: 
                        	   532: ValBiosRangeError:
01:8B1B CD33B0          	   533: 	call	BiosRange
01:8B1E B7              	   534: 	or		A
01:8B1F 1810            	   535: 	jr		RangeValidationEnd
                        	   536: 
                        	   537: ValRangeTooSmallError:
01:8B21 CD2AB0          	   538: 	call	RangeTooSmall
01:8B24 B7              	   539: 	or		A
01:8B25 180A            	   540: 	jr		RangeValidationEnd
                        	   541: 
                        	   542: ValInvertedError:
01:8B27 CD3CB0          	   543: 	call	RangeInverted
01:8B2A B7              	   544: 	or		A
01:8B2B 1804            	   545: 	jr		RangeValidationEnd
                        	   546: 	
                        	   547: RangeValidationError:
01:8B2D CD21B0          	   548: 	call	InvalidVectorRange
01:8B30 B7              	   549: 	or		A						; Clear Carry
                        	   550: 
                        	   551: RangeValidationEnd:
01:8B31 E1              	   552: 	pop		HL
01:8B32 D1              	   553: 	pop		DE
01:8B33 F1              	   554: 	pop		AF
                        	   555: 
01:8B34 C9              	   556: 	ret
                        	   557: 
                        	   558: 
                        	   559: ;  ____                        _     _____                                ____            _           _                
                        	   560: ; |  _ \    ___   ___    ___  | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __
                        	   561: ; | |_) |  / _ \ / __|  / _ \ | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__
                        	   562: ; |  _ <  |  __/ \__ \ |  __/ | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |  
                        	   563: ; |_| \_\  \___| |___/  \___|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|  
                        	   564: ;
                        	   565: ;
                        	   566: ; *********************************************************************************************************************
                        	   567: ; Increment error pointer by one
                        	   568: ; *********************************************************************************************************************
                        	   569: 
                        	   570: ResetErrorPointer:
01:8B35 F5              	   571: 	push	AF
01:8B36 3E09            	   572: 	ld		A,ErrorPtrOffset
01:8B38 32B7B0          	   573: 	ld		(CmdErrorPointer),A
01:8B3B F1              	   574: 	pop		AF
01:8B3C C9              	   575: 	ret
                        	   576: 
                        	   577: 
                        	   578: ;  ____    _      _           ____                                      
                        	   579: ; / ___|  | | __ (_)  _ __   / ___|   _ __     __ _    ___    ___   ___ 
                        	   580: ; \___ \  | |/ / | | | '_ \  \___ \  | '_ \   / _` |  / __|  / _ \ / __|
                        	   581: ;  ___) | |   <  | | | |_) |  ___) | | |_) | | (_| | | (__  |  __/ \__ \
                        	   582: ; |____/  |_|\_\ |_| | .__/  |____/  | .__/   \__,_|  \___|  \___| |___/
                        	   583: ;                    |_|             |_|                                
                        	   584: ;
                        	   585: ; *********************************************************************************************************************
                        	   586: ; Removes leading spaces for parsing commands
                        	   587: ;	- Input:	HL pointing to command string
                        	   588: ;	- Output:	HL points to the next delimiterless position
                        	   589: ; *********************************************************************************************************************
                        	   590: 
                        	   591: SkipSpaces:
01:8B3D F5              	   592: 	push	AF
                        	   593: SkipSpacesLoop:
01:8B3E 7E              	   594: 	ld		A,(HL)					; Read the contents of HL, where the 
01:8B3F FE20            	   595: 	cp		" "						; Is it a space?
01:8B41 2006            	   596: 	jr		nz,SkipSpacesEnd		; It's not a space, so end routine
01:8B43 23              	   597: 	inc		HL						; It's a space, so move to next character
01:8B44 CD5089          	   598: 	call	IncErrorPointer			; Increment command line error pointer
01:8B47 18F5            	   599: 	jr		SkipSpacesLoop			; Check for other spaces, just in case
                        	   600: SkipSpacesEnd:
01:8B49 F1              	   601: 	pop		AF
01:8B4A C9              	   602: 	ret
                        	   603: 
                        	   604: 

Source: "main.asm"
                        	   274: 	.include	"basic.asm"			; Nascom Microsoft Basic (from Grant Searle)

Source: "basic.asm"
                        	     1: ;==================================================================================
                        	     2: ; The updates to the original BASIC within this file are copyright Grant Searle
                        	     3: ;
                        	     4: ; You have permission to use this for NON COMMERCIAL USE ONLY
                        	     5: ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        	     6: ;
                        	     7: ; http://searle.hostei.com/grant/index.html
                        	     8: ;
                        	     9: ; eMail: home.micros01@btinternet.com
                        	    10: ;
                        	    11: ; If the above don't work, please perform an Internet search to see if I have
                        	    12: ; updated the web page hosting service.
                        	    13: ;
                        	    14: ;==================================================================================
                        	    15: 
                        	    16: ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        	    17: ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        	    18: ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        	    19: ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        	    20: ; the original ROM code (checksum A934H). PA
                        	    21: ;
                        	    22: ;==================================================================================
                        	    23: 
                        	    24: ; BASIC ERROR CODE VALUES
                        	    25: 
                        	    26: NF		.EQU	00H				; NEXT without FOR
                        	    27: SN		.EQU	02H				; Syntax error
                        	    28: RG		.EQU	04H				; RETURN without GOSUB
                        	    29: OD		.EQU	06H				; Out of DATA
                        	    30: FC		.EQU	08H				; Function call error
                        	    31: OV		.EQU	0AH				; Overflow
                        	    32: OM		.EQU	0CH				; Out of memory
                        	    33: UL		.EQU	0EH				; Undefined line number
                        	    34: BS		.EQU	10H				; Bad subscript
                        	    35: DD		.EQU	12H				; Re-DIMensioned array
                        	    36: DZ		.EQU	14H				; Division by zero (/0)
                        	    37: ID		.EQU	16H				; Illegal direct
                        	    38: TM		.EQU	18H				; Type miss-match
                        	    39: OS		.EQU	1AH				; Out of string space
                        	    40: LS		.EQU	1CH				; String too long
                        	    41: ST		.EQU	1EH				; String formula too complex
                        	    42: CN		.EQU	20H				; Can't CONTinue
                        	    43: UF		.EQU	22H				; UnDEFined FN function
                        	    44: MO		.EQU	24H				; Missing operand
                        	    45: HX		.EQU	26H				; HEX error
                        	    46: BN		.EQU	28H				; BIN error
                        	    47: 
                        	    48: 
                        	    49: ; BASIC WORK SPACE LOCATIONS
                        	    50: 
                        	    51: ;WRKSPC	.EQU	2045H			  ; BASIC Work space
                        	    52: WRKSPC	.EQU	$1000			  ; BASIC Work space
                        	    53: USR		.EQU	WRKSPC+3H			; "USR (x)" jump
                        	    54: OUTSUB	.EQU	WRKSPC+6H			; "OUT p,n"
                        	    55: OTPORT	.EQU	WRKSPC+7H			; Port (p)
                        	    56: DIVSUP	.EQU	WRKSPC+9H			; Division support routine
                        	    57: DIV1	.EQU	WRKSPC+0AH			 ; <- Values
                        	    58: DIV2	.EQU	WRKSPC+0EH			 ; <-	to
                        	    59: DIV3	.EQU	WRKSPC+12H			 ; <-	be
                        	    60: DIV4	.EQU	WRKSPC+15H			 ; <-inserted
                        	    61: SEED	.EQU	WRKSPC+17H			 ; Random number seed
                        	    62: LSTRND	.EQU	WRKSPC+3AH			 ; Last random number
                        	    63: INPSUB	.EQU	WRKSPC+3EH			 ; #INP (x)" Routine
                        	    64: INPORT	.EQU	WRKSPC+3FH			 ; PORT (x)
                        	    65: NULLS	.EQU	WRKSPC+41H			 ; Number of nulls
                        	    66: LWIDTH	.EQU	WRKSPC+42H			 ; Terminal width
                        	    67: COMMAN	.EQU	WRKSPC+43H			 ; Width for commas
                        	    68: NULFLG	.EQU	WRKSPC+44H			 ; Null after input byte flag
                        	    69: CTLOFG	.EQU	WRKSPC+45H			 ; Control "O" flag
                        	    70: LINESC	.EQU	WRKSPC+46H			 ; Lines counter
                        	    71: LINESN	.EQU	WRKSPC+48H			 ; Lines number
                        	    72: CHKSUM	.EQU	WRKSPC+4AH			 ; Array load/save check sum
                        	    73: NMIFLG	.EQU	WRKSPC+4CH			 ; Flag for NMI break routine
                        	    74: BRKFLG	.EQU	WRKSPC+4DH			 ; Break flag
                        	    75: RINPUT	.EQU	WRKSPC+4EH			 ; Input reflection
                        	    76: POINT	.EQU	WRKSPC+51H			 ; "POINT" reflection (unused)
                        	    77: PSET	.EQU	WRKSPC+54H			 ; "SET"   reflection
                        	    78: RESET	.EQU	WRKSPC+57H			 ; "RESET" reflection
                        	    79: STRSPC	.EQU	WRKSPC+5AH			 ; Bottom of string space
                        	    80: LINEAT	.EQU	WRKSPC+5CH			 ; Current line number
                        	    81: BASTXT	.EQU	WRKSPC+5EH			 ; Pointer to start of program
                        	    82: BUFFER	.EQU	WRKSPC+61H			 ; Input buffer
                        	    83: STACK	.EQU	WRKSPC+66H			 ; Initial stack
                        	    84: CURPOS	.EQU	WRKSPC+0ABH			 ; Character position on line
                        	    85: LCRFLG	.EQU	WRKSPC+0ACH			 ; Locate/Create flag
                        	    86: TYPE	.EQU	WRKSPC+0ADH			 ; Data type flag
                        	    87: DATFLG	.EQU	WRKSPC+0AEH			 ; Literal statement flag
                        	    88: LSTRAM	.EQU	WRKSPC+0AFH			 ; Last available RAM
                        	    89: TMSTPT	.EQU	WRKSPC+0B1H			 ; Temporary string pointer
                        	    90: TMSTPL	.EQU	WRKSPC+0B3H			 ; Temporary string pool
                        	    91: TMPSTR	.EQU	WRKSPC+0BFH			 ; Temporary string
                        	    92: STRBOT	.EQU	WRKSPC+0C3H			 ; Bottom of string space
                        	    93: CUROPR	.EQU	WRKSPC+0C5H			 ; Current operator in EVAL
                        	    94: LOOPST	.EQU	WRKSPC+0C7H			 ; First statement of loop
                        	    95: DATLIN	.EQU	WRKSPC+0C9H			 ; Line of current DATA item
                        	    96: FORFLG	.EQU	WRKSPC+0CBH			 ; "FOR" loop flag
                        	    97: LSTBIN	.EQU	WRKSPC+0CCH			 ; Last byte entered
                        	    98: READFG	.EQU	WRKSPC+0CDH			 ; Read/Input flag
                        	    99: BRKLIN	.EQU	WRKSPC+0CEH			 ; Line of break
                        	   100: NXTOPR	.EQU	WRKSPC+0D0H			 ; Next operator in EVAL
                        	   101: ERRLIN	.EQU	WRKSPC+0D2H			 ; Line of error
                        	   102: CONTAD	.EQU	WRKSPC+0D4H			 ; Where to CONTinue
                        	   103: PROGND	.EQU	WRKSPC+0D6H			 ; End of program
                        	   104: VAREND	.EQU	WRKSPC+0D8H			 ; End of variables
                        	   105: ARREND	.EQU	WRKSPC+0DAH			 ; End of arrays
                        	   106: NXTDAT	.EQU	WRKSPC+0DCH			 ; Next data item
                        	   107: FNRGNM	.EQU	WRKSPC+0DEH			 ; Name of FN argument
                        	   108: FNARG	.EQU	WRKSPC+0E0H			 ; FN argument value
                        	   109: FPREG	.EQU	WRKSPC+0E4H			 ; Floating point register
                        	   110: FPEXP	.EQU	FPREG+3			; Floating point exponent
                        	   111: SGNRES	.EQU	WRKSPC+0E8H		; Sign of result
                        	   112: PBUFF	.EQU	WRKSPC+0E9H		; Number print buffer
                        	   113: MULVAL	.EQU	WRKSPC+0F6H		; Multiplier
                        	   114: PROGST	.EQU	WRKSPC+0F9H		; Start of program text area
                        	   115: STLOOK	.EQU	WRKSPC+15DH		; Start of memory test
                        	   116: 
                        	   117: 
                        	   118: ;TEMPSTACK	.EQU	$20ED ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   119: TEMPSTACK	.EQU	$7FFF ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   120: 
                        	   121: 
                        	   122: ;  ____       _      ____    ___    ____ 
                        	   123: ; | __ )     / \    / ___|  |_ _|  / ___|
                        	   124: ; |  _ \    / _ \   \___ \   | |  | |    
                        	   125: ; | |_) |  / ___ \   ___) |  | |  | |___ 
                        	   126: ; |____/  /_/   \_\ |____/  |___|  \____|
                        	   127: ;
                        	   128: ;
                        	   129: ; *********************************************************************************************************************
                        	   130: 
                        	   131: BASIC:
01:8B4B CDAC82          	   132: 	call	ClearScreen				; Clear screen
01:8B4E 21748B          	   133: 	ld		HL,SignOnMsg			; Sign-on message
01:8B51 CDB080          	   134: 	call	PrintString				; Output string
                        	   135: 
                        	   136: ColdOrWarm:
01:8B54 CDC980          	   137: 	call	ReadChar				; Read a character
01:8B57 CDA182          	   138: 	call	Uppercase				; Convert to uppercase
                        	   139: 
                        	   140: CheckIfCold:
01:8B5A FE43            	   141: 	cp		"C"						; Is it C for Coldstart?
01:8B5C 2009            	   142: 	jr		nz,CheckIfWarm			; No, then check if it's Warmstart
01:8B5E CD7680          	   143: 	call	PrintChar				; Print the C
01:8B61 CD8180          	   144: 	call	PrintCRLF				; Print carriage return and linefeed
01:8B64 C3D08B          	   145: 	jp		COLD					; Start BASIC COLD
                        	   146: 
                        	   147: CheckIfWarm:
01:8B67 FE57            	   148: 	cp		"W"						
01:8B69 20E9            	   149: 	jr		nz,ColdOrWarm
01:8B6B CD7680          	   150: 	call	PrintChar
01:8B6E CD8180          	   151: 	call	PrintCRLF
01:8B71 C36E8C          	   152: 	jp		WARM					; Start BASIC WARM
                        	   153: 			  
                        	   154: SignOnMsg:
01:8B74 5570646174657320	   155: 	db		"Updates to BASIC by Grant Searle",CR,LF
01:8B7C 746F204241534943
01:8B84 206279204772616E
01:8B8C 7420536561726C65
01:8B94 0D
01:8B95 0A
01:8B96 4164617074656420	   156: 	db		"Adapted by Frederic Segard",CR,LF
01:8B9E 6279204672656465
01:8BA6 7269632053656761
01:8BAE 7264
01:8BB0 0D
01:8BB1 0A
01:8BB2 436F6C64206F7220	   157: 	db		"Cold or warm start (C or W)? ",0
01:8BBA 7761726D20737461
01:8BC2 7274202843206F72
01:8BCA 2057293F20
01:8BCF 00
                        	   158: 
                        	   159: ; COLD START SEQUENCE
                        	   160: COLD:
01:8BD0 DD210000        	   161: 	LD		IX,0					; Flag cold start
01:8BD4 C3DB8B          	   162: 	jp		CSTART					; Jump to initialise
                        	   163: 
01:8BD7 8994            	   164: 	dw		DEINT					; Get integer -32768 to 32767
01:8BD9 F89B            	   165: 	dw		ABPASS					; Return integer in AB
                        	   166: 
                        	   167: CSTART:
01:8BDB 210010          	   168: 	ld		HL,WRKSPC				; Start of workspace RAM
01:8BDE F9              	   169: 	ld		SP,HL					; Set up a temporary stack
01:8BDF C31BA8          	   170: 	jp		INITST					; Go to initialise
                        	   171: 
                        	   172: INIT:
01:8BE2 11AD8E          	   173: 	ld		DE,INITAB				; Initialise workspace
01:8BE5 0663            	   174: 	ld		B,INITBE-INITAB+3		; Bytes to copy
01:8BE7 210010          	   175: 	ld		HL,WRKSPC				; Into workspace RAM
                        	   176: COPYY:
01:8BEA 1A              	   177: 	ld		A,(DE)					; Get source
01:8BEB 77              	   178: 	ld		(HL),A					; To destination
01:8BEC 23              	   179: 	inc		HL						; Next destination
01:8BED 13              	   180: 	inc		DE						; Next source
01:8BEE 05              	   181: 	dec		B						; Count bytes
01:8BEF C2EA8B          	   182: 	jp		NZ,COPYY				; More to move
01:8BF2 F9              	   183: 	ld		SP,HL					; Temporary stack
01:8BF3 CDAE90          	   184: 	call	CLREG					; Clear registers and stack
01:8BF6 CD8180          	   185: 	call	PrintCRLF				; Output CRLF
01:8BF9 32AA10          	   186: 	ld		(BUFFER+72+1),A 		; Mark end of buffer
01:8BFC 32F910          	   187: 	ld		(PROGST),A				; Initialise program area
                        	   188: MSIZE:
01:8BFF 21BC8C          	   189: 	ld		HL,MEMMSG				; Point to message
01:8C02 CD169D          	   190: 	call	PRS						; Output "Memory size"
01:8C05 CDCB90          	   191: 	call	PROMPT					; Get input with '?'
01:8C08 CDD493          	   192: 	call	GETCHR					; Get next character
01:8C0B B7              	   193: 	or		A						; Set flags
01:8C0C C2248C          	   194: 	jp		NZ,TSTMEM				; If number - Test if RAM there
01:8C0F 215D11          	   195: 	ld		HL,STLOOK				; Point to start of RAM
                        	   196: MLOOP:
01:8C12 23              	   197: 	inc		HL						; Next byte
01:8C13 7C              	   198: 	ld		A,H						; Above address FFFF ?
01:8C14 B5              	   199: 	or		L
01:8C15 CA368C          	   200: 	jp		Z,SETTOP				; Yes - 64K RAM
01:8C18 7E              	   201: 	ld		A,(HL)					; Get contents
01:8C19 47              	   202: 	ld		B,A						; Save it
01:8C1A 2F              	   203: 	cpl								; Flip all bits
01:8C1B 77              	   204: 	ld		(HL),A					; Put it back
01:8C1C BE              	   205: 	cp		(HL)					; RAM there if same
01:8C1D 70              	   206: 	ld		(HL),B					; Restore old contents
01:8C1E CA128C          	   207: 	jp		Z,MLOOP					; If RAM - test next byte
01:8C21 C3368C          	   208: 	jp		SETTOP					; Top of RAM found
                        	   209: 
                        	   210: TSTMEM:
01:8C24 CDA394          	   211: 	call	ATOH					; Get high memory into DE
01:8C27 B7              	   212: 	or		A						; Set flags on last byte
01:8C28 C27C8F          	   213: 	jp		NZ,SNERR				; ?SN Error if bad character
01:8C2B EB              	   214: 	ex		DE,HL					; Address into HL
01:8C2C 2B              	   215: 	dec		HL						; Back one byte
01:8C2D 3ED9            	   216: 	ld		A,11011001B				; Test byte
01:8C2F 46              	   217: 	ld		B,(HL)					; Get old contents
01:8C30 77              	   218: 	ld		(HL),A					; Load test byte
01:8C31 BE              	   219: 	cp		(HL)					; RAM there if same
01:8C32 70              	   220: 	ld		(HL),B					; Restore old contents
01:8C33 C2FF8B          	   221: 	jp		NZ,MSIZE				; Ask again if no RAM
                        	   222: 
                        	   223: SETTOP:
01:8C36 2B              	   224: 	dec		HL						; Back one byte
01:8C37 115C11          	   225: 	ld		DE,STLOOK-1				; See if enough RAM
01:8C3A CD4492          	   226: 	call	CPDEHL					; Compare DE with HL
01:8C3D DAFF8B          	   227: 	jp		C,MSIZE					; Ask again if not enough RAM
01:8C40 11CEFF          	   228: 	ld		DE,0-50					; 50 Bytes string space
01:8C43 22AF10          	   229: 	ld		(LSTRAM),HL				; Save last available RAM
01:8C46 19              	   230: 	add		HL,DE					; Allocate string space
01:8C47 225A10          	   231: 	ld		(STRSPC),HL				; Save string space
01:8C4A CD8990          	   232: 	call	CLRPTR					; Clear program area
01:8C4D 2A5A10          	   233: 	ld		HL,(STRSPC)				; Get end of memory
01:8C50 11EFFF          	   234: 	ld		DE,0-17					; Offset for free bytes
01:8C53 19              	   235: 	add		HL,DE					; Adjust HL
01:8C54 11F910          	   236: 	ld		DE,PROGST				; Start of program text
01:8C57 7D              	   237: 	ld		A,L						; Get LSB
01:8C58 93              	   238: 	sub		E						; Adjust it
01:8C59 6F              	   239: 	ld		L,A						; Re-save
01:8C5A 7C              	   240: 	ld		A,H						; Get MSB
01:8C5B 9A              	   241: 	sbc		A,D						; Adjust it
01:8C5C 67              	   242: 	ld		H,A						; Re-save
01:8C5D E5              	   243: 	push	HL						; Save bytes free
01:8C5E 21868C          	   244: 	ld		HL,SIGNON				; Sign-on message
01:8C61 CD169D          	   245: 	call	PRS						; Output string
01:8C64 E1              	   246: 	pop		HL						; Get bytes free back
01:8C65 CDB9A3          	   247: 	call	PRNTHL					; Output amount of free memory
01:8C68 21778C          	   248: 	ld		HL,BFREE				; " Bytes free" message
01:8C6B CD169D          	   249: 	call	PRS						; Output string
                        	   250: 
                        	   251: WARM:								; WARM START
01:8C6E 316610          	   252: 	ld		SP,STACK				; Temporary stack
                        	   253: BRKRET:
01:8C71 CDAE90          	   254: 	call	CLREG					; Clear registers and stack
01:8C74 C3C78F          	   255: 	jp		PRNTOK					; Go to get command line
                        	   256: 
                        	   257: BFREE:	
01:8C77 2042797465732066	   258: 	db		" Bytes free",CR,LF,0,0
01:8C7F 726565
01:8C82 0D
01:8C83 0A
01:8C84 00
01:8C85 00
                        	   259: 
                        	   260: SIGNON: 
01:8C86 5A38302042415349	   261: 	db		"Z80 BASIC Ver 4.7b",CR,LF
01:8C8E 432056657220342E
01:8C96 3762
01:8C98 0D
01:8C99 0A
01:8C9A 436F707972696768	   262: 	db		"Copyright (C) 1978 by Microsoft",CR,LF,0
01:8CA2 7420284329203139
01:8CAA 3738206279204D69
01:8CB2 63726F736F6674
01:8CB9 0D
01:8CBA 0A
01:8CBB 00
                        	   263: 
                        	   264: MEMMSG:
01:8CBC 4D656D6F72792074	   265: 	db		"Memory top",0
01:8CC4 6F70
01:8CC6 00
                        	   266: 
                        	   267: 
                        	   268: ; FUNCTION ADDRESS TABLE
                        	   269: 
                        	   270: FNCTAB:
01:8CC7 2EA2            	   271: 	dw		SGN
01:8CC9 F2A2            	   272: 	dw		INT
01:8CCB 44A2            	   273: 	dw		ABS
01:8CCD 0310            	   274: 	dw		USR
01:8CCF D69B            	   275: 	dw		FRE
01:8CD1 5B9F            	   276: 	dw		INP
01:8CD3 049C            	   277: 	dw		POS
01:8CD5 B8A4            	   278: 	dw		SQR
01:8CD7 97A5            	   279: 	dw		RND
01:8CD9 D3A0            	   280: 	dw		LOG
01:8CDB 06A5            	   281: 	dw		EXPP
01:8CDD 0CA6            	   282: 	dw		COS
01:8CDF 12A6            	   283: 	dw		SIN
01:8CE1 73A6            	   284: 	dw		TAN
01:8CE3 88A6            	   285: 	dw		ATN
01:8CE5 AF9F            	   286: 	dw		PEEK
01:8CE7 F3A6            	   287: 	dw		DEEK
01:8CE9 5110            	   288: 	dw		POINT
01:8CEB 889E            	   289: 	dw		LEN
01:8CED A09C            	   290: 	dw		STRR
01:8CEF 229F            	   291: 	dw		VAL
01:8CF1 979E            	   292: 	dw		ASCC
01:8CF3 A89E            	   293: 	dw		CHR
01:8CF5 15A7            	   294: 	dw		HEX
01:8CF7 ACA7            	   295: 	dw		BIN
01:8CF9 B89E            	   296: 	dw		LEFT
01:8CFB E89E            	   297: 	dw		RIGHT
01:8CFD F29E            	   298: 	dw		MID
                        	   299: 
                        	   300: 
                        	   301: ; RESERVED WORD LIST
                        	   302: 
                        	   303: WORDS:
01:8CFF C5              	   304: 	db		'E'+80H,"ND"
01:8D00 4E44
01:8D02 C6              	   305: 	db		'F'+80H,"OR"
01:8D03 4F52
01:8D05 CE              	   306: 	db		'N'+80H,"EXT"
01:8D06 455854
01:8D09 C4              	   307: 	db		'D'+80H,"ATA"
01:8D0A 415441
01:8D0D C9              	   308: 	db		'I'+80H,"NPUT"
01:8D0E 4E505554
01:8D12 C4              	   309: 	db		'D'+80H,"IM"
01:8D13 494D
01:8D15 D2              	   310: 	db		'R'+80H,"EAD"
01:8D16 454144
01:8D19 CC              	   311: 	db		'L'+80H,"ET"
01:8D1A 4554
01:8D1C C7              	   312: 	db		'G'+80H,"OTO"
01:8D1D 4F544F
01:8D20 D2              	   313: 	db		'R'+80H,"UN"
01:8D21 554E
01:8D23 C9              	   314: 	db		'I'+80H,"F"
01:8D24 46
01:8D25 D2              	   315: 	db		'R'+80H,"ESTORE"
01:8D26 4553544F5245
01:8D2C C7              	   316: 	db		'G'+80H,"OSUB"
01:8D2D 4F535542
01:8D31 D2              	   317: 	db		'R'+80H,"ETURN"
01:8D32 455455524E
01:8D37 D2              	   318: 	db		'R'+80H,"EM"
01:8D38 454D
01:8D3A D3              	   319: 	db		'S'+80H,"TOP"
01:8D3B 544F50
01:8D3E CF              	   320: 	db		'O'+80H,"UT"
01:8D3F 5554
01:8D41 CF              	   321: 	db		'O'+80H,"N"
01:8D42 4E
01:8D43 CE              	   322: 	db		'N'+80H,"ULL"
01:8D44 554C4C
01:8D47 D7              	   323: 	db		'W'+80H,"AIT"
01:8D48 414954
01:8D4B C4              	   324: 	db		'D'+80H,"EF"
01:8D4C 4546
01:8D4E D0              	   325: 	db		'P'+80H,"OKE"
01:8D4F 4F4B45
01:8D52 C4              	   326: 	db		'D'+80H,"OKE"
01:8D53 4F4B45
01:8D56 D3              	   327: 	db		'S'+80H,"CREEN"
01:8D57 435245454E
01:8D5C CC              	   328: 	db		'L'+80H,"INES"
01:8D5D 494E4553
01:8D61 C3              	   329: 	db		'C'+80H,"LS"
01:8D62 4C53
01:8D64 D7              	   330: 	db		'W'+80H,"IDTH"
01:8D65 49445448
01:8D69 CD              	   331: 	db		'M'+80H,"ONITOR"
01:8D6A 4F4E49544F52
01:8D70 D3              	   332: 	db		'S'+80H,"ET"
01:8D71 4554
01:8D73 D2              	   333: 	db		'R'+80H,"ESET"
01:8D74 45534554
01:8D78 D0              	   334: 	db		'P'+80H,"RINT"
01:8D79 52494E54
01:8D7D C3              	   335: 	db		'C'+80H,"ONT"
01:8D7E 4F4E54
01:8D81 CC              	   336: 	db		'L'+80H,"IST"
01:8D82 495354
01:8D85 C3              	   337: 	db		'C'+80H,"LEAR"
01:8D86 4C454152
01:8D8A C3              	   338: 	db		'C'+80H,"LOAD"
01:8D8B 4C4F4144
01:8D8F C3              	   339: 	db		'C'+80H,"SAVE"
01:8D90 53415645
01:8D94 CE              	   340: 	db		'N'+80H,"EW"
01:8D95 4557
01:8D97 C5              	   341: 	db		'E'+80H,"XIT"			; Exit BASIC
01:8D98 584954
                        	   342: 	
01:8D9B D4              	   343: 	db		'T'+80H,"AB("
01:8D9C 414228
01:8D9F D4              	   344: 	db		'T'+80H,"O"
01:8DA0 4F
01:8DA1 C6              	   345: 	db		'F'+80H,"N"
01:8DA2 4E
01:8DA3 D3              	   346: 	db		'S'+80H,"PC("
01:8DA4 504328
01:8DA7 D4              	   347: 	db		'T'+80H,"HEN"
01:8DA8 48454E
01:8DAB CE              	   348: 	db		'N'+80H,"OT"
01:8DAC 4F54
01:8DAE D3              	   349: 	db		'S'+80H,"TEP"
01:8DAF 544550
                        	   350: 
01:8DB2 AB              	   351: 	db		'+'+80H
01:8DB3 AD              	   352: 	db		'-'+80H
01:8DB4 AA              	   353: 	db		'*'+80H
01:8DB5 AF              	   354: 	db		'/'+80H
01:8DB6 DE              	   355: 	db		'^'+80H
01:8DB7 C1              	   356: 	db		'A'+80H,"ND"
01:8DB8 4E44
01:8DBA CF              	   357: 	db		'O'+80H,"R"
01:8DBB 52
01:8DBC BE              	   358: 	db		'>'+80H
01:8DBD BD              	   359: 	db		'='+80H
01:8DBE BC              	   360: 	db		'<'+80H
                        	   361: 
01:8DBF D3              	   362: 	db		'S'+80H,"GN"
01:8DC0 474E
01:8DC2 C9              	   363: 	db		'I'+80H,"NT"
01:8DC3 4E54
01:8DC5 C1              	   364: 	db		'A'+80H,"BS"
01:8DC6 4253
01:8DC8 D5              	   365: 	db		'U'+80H,"SR"
01:8DC9 5352
01:8DCB C6              	   366: 	db		'F'+80H,"RE"
01:8DCC 5245
01:8DCE C9              	   367: 	db		'I'+80H,"NP"
01:8DCF 4E50
01:8DD1 D0              	   368: 	db		'P'+80H,"OS"
01:8DD2 4F53
01:8DD4 D3              	   369: 	db		'S'+80H,"QR"
01:8DD5 5152
01:8DD7 D2              	   370: 	db		'R'+80H,"ND"
01:8DD8 4E44
01:8DDA CC              	   371: 	db		'L'+80H,"OG"
01:8DDB 4F47
01:8DDD C5              	   372: 	db		'E'+80H,"XP"
01:8DDE 5850
01:8DE0 C3              	   373: 	db		'C'+80H,"OS"
01:8DE1 4F53
01:8DE3 D3              	   374: 	db		'S'+80H,"IN"
01:8DE4 494E
01:8DE6 D4              	   375: 	db		'T'+80H,"AN"
01:8DE7 414E
01:8DE9 C1              	   376: 	db		'A'+80H,"TN"
01:8DEA 544E
01:8DEC D0              	   377: 	db		'P'+80H,"EEK"
01:8DED 45454B
01:8DF0 C4              	   378: 	db		'D'+80H,"EEK"
01:8DF1 45454B
01:8DF4 D0              	   379: 	db		'P'+80H,"OINT"
01:8DF5 4F494E54
01:8DF9 CC              	   380: 	db		'L'+80H,"EN"
01:8DFA 454E
01:8DFC D3              	   381: 	db		'S'+80H,"TR$"
01:8DFD 545224
01:8E00 D6              	   382: 	db		'V'+80H,"AL"
01:8E01 414C
01:8E03 C1              	   383: 	db		'A'+80H,"SC"
01:8E04 5343
01:8E06 C3              	   384: 	db		'C'+80H,"HR$"
01:8E07 485224
01:8E0A C8              	   385: 	db		'H'+80H,"EX$"
01:8E0B 455824
01:8E0E C2              	   386: 	db		'B'+80H,"IN$"
01:8E0F 494E24
01:8E12 CC              	   387: 	db		'L'+80H,"EFT$"
01:8E13 45465424
01:8E17 D2              	   388: 	db		'R'+80H,"IGHT$"
01:8E18 4947485424
01:8E1D CD              	   389: 	db		'M'+80H,"ID$"
01:8E1E 494424
                        	   390: 
01:8E21 80              	   391: 	db		80H				; End of list marker
                        	   392: 
                        	   393: ; KEYWORD ADDRESS TABLE
                        	   394: 
                        	   395: WORDTB:
01:8E22 2194            	   396: 	dw		PEND
01:8E24 1B93            	   397: 	dw		FOR
01:8E26 F297            	   398: 	dw		NEXT
01:8E28 6E95            	   399: 	dw		DATAA
01:8E2A F996            	   400: 	dw		INPUT
01:8E2C 2E9A            	   401: 	dw		DIM
01:8E2E 2897            	   402: 	dw		READ
01:8E30 8595            	   403: 	dw		LET
01:8E32 2B95            	   404: 	dw		GOTO
01:8E34 0E95            	   405: 	dw		RUN
01:8E36 FD95            	   406: 	dw		IFF
01:8E38 E493            	   407: 	dw		RESTOR
01:8E3A 1A95            	   408: 	dw		GOSUB
01:8E3C 4995            	   409: 	dw		RETURN
01:8E3E 7095            	   410: 	dw		REM
01:8E40 1F94            	   411: 	dw		STOPP
01:8E42 679F            	   412: 	dw		POUT
01:8E44 DF95            	   413: 	dw		ON
01:8E46 6094            	   414: 	dw		NULLL
01:8E48 6D9F            	   415: 	dw		WAIT
01:8E4A 0C9C            	   416: 	dw		DEF
01:8E4C B69F            	   417: 	dw		POKE
01:8E4E FEA6            	   418: 	dw		DOKE
01:8E50 7095            	   419: 	dw		REM
01:8E52 E4A6            	   420: 	dw		LINES
01:8E54 D9A6            	   421: 	dw		CLS
01:8E56 DCA6            	   422: 	dw		WIDTH
01:8E58 18A8            	   423: 	dw		MONITR
01:8E5A 5410            	   424: 	dw		PSET
01:8E5C 5710            	   425: 	dw		RESET
01:8E5E 2196            	   426: 	dw		PRINTT
01:8E60 4D94            	   427: 	dw		CONT
01:8E62 9092            	   428: 	dw		LISTT
01:8E64 C894            	   429: 	dw		CLEAR
01:8E66 7095            	   430: 	dw		REM
01:8E68 7095            	   431: 	dw		REM
01:8E6A 8890            	   432: 	dw		NEW
01:8E6C 32A8            	   433: 	dw		EXIT					; Exit BASIC
                        	   434: 
                        	   435: ; RESERVED WORD TOKEN VALUES
                        	   436: 
                        	   437: ZEND	.EQU	080H			; END
                        	   438: ZFOR	.EQU	081H			; FOR
                        	   439: ZDATA	.EQU	083H			; DATA
                        	   440: ZGOTO	.EQU	088H			; GOTO
                        	   441: ZGOSUB	.EQU	08CH			; GOSUB
                        	   442: ZREM	.EQU	08EH			; REM
                        	   443: ZPRINT	.EQU	09EH			; PRINT
                        	   444: ZNEW	.EQU	0A4H			; NEW
                        	   445: 
                        	   446: ZTAB	.EQU	0A5H			; TAB
                        	   447: ZTO		.EQU	0A6H			; TO
                        	   448: ZFN		.EQU	0A7H			; FN
                        	   449: ZSPC	.EQU	0A8H			; SPC
                        	   450: ZTHEN	.EQU	0A9H			; THEN
                        	   451: ZNOT	.EQU	0AAH			; NOT
                        	   452: ZSTEP	.EQU	0ABH			; STEP
                        	   453: 
                        	   454: ZPLUS	.EQU	0ACH			; +
                        	   455: ZMINUS	.EQU	0ADH			; -
                        	   456: ZTIMES	.EQU	0AEH			; *
                        	   457: ZDIV	.EQU	0AFH			; /
                        	   458: ZOR		.EQU	0B2H			; OR
                        	   459: ZGTR	.EQU	0B3H			; >
                        	   460: ZEQUAL	.EQU	0B4H			; M
                        	   461: ZLTH	.EQU	0B5H			; <
                        	   462: ZSGN	.EQU	0B6H			; SGN
                        	   463: ZPOINT	.EQU	0C7H			; POINT
                        	   464: ZLEFT	.EQU	0CDH +2			; LEFT$
                        	   465: 
                        	   466: ; ARITHMETIC PRECEDENCE TABLE
                        	   467: 
01:8E6E 79              	   468: PRITAB: db		79H				; Precedence value
01:8E6F A0A3            	   469: 		dw		PADD			; FPREG = <last> + FPREG
                        	   470: 
01:8E71 79              	   471: 		db		79H				; Precedence value
01:8E72 D49F            	   472: 		dw		PSUB			; FPREG = <last> - FPREG
                        	   473: 
01:8E74 7C              	   474: 		db		7CH				; Precedence value
01:8E75 12A1            	   475: 		dw		MULTT			; PPREG = <last> * FPREG
                        	   476: 
01:8E77 7C              	   477: 		db		7CH				; Precedence value
01:8E78 73A1            	   478: 		dw		DIV				; FPREG = <last> / FPREG
                        	   479: 
01:8E7A 7F              	   480: 		db		7FH				; Precedence value
01:8E7B C1A4            	   481: 		dw		POWER			; FPREG = <last> ^ FPREG
                        	   482: 
01:8E7D 50              	   483: 		db		50H				; Precedence value
01:8E7E 8799            	   484: 		dw		PAND			; FPREG = <last> AND FPREG
                        	   485: 
01:8E80 46              	   486: 		db		46H				; Precedence value
01:8E81 8699            	   487: 		dw		POR				; FPREG = <last> OR FPREG
                        	   488: 
                        	   489: ; BASIC ERROR CODE LIST
                        	   490: 
01:8E83 4E46            	   491: ERRORS: db		"NF"			; NEXT without FOR
01:8E85 534E            	   492: 		db		"SN"			; Syntax error
01:8E87 5247            	   493: 		db		"RG"			; RETURN without GOSUB
01:8E89 4F44            	   494: 		db		"OD"			; Out of DATA
01:8E8B 4643            	   495: 		db		"FC"			; Illegal function call
01:8E8D 4F56            	   496: 		db		"OV"			; Overflow error
01:8E8F 4F4D            	   497: 		db		"OM"			; Out of memory
01:8E91 554C            	   498: 		db		"UL"			; Undefined line
01:8E93 4253            	   499: 		db		"BS"			; Bad subscript
01:8E95 4444            	   500: 		db		"DD"			; Re-DIMensioned array
01:8E97 2F30            	   501: 		db		"/0"			; Division by zero
01:8E99 4944            	   502: 		db		"ID"			; Illegal direct
01:8E9B 544D            	   503: 		db		"TM"			; Type mis-match
01:8E9D 4F53            	   504: 		db		"OS"			; Out of string space
01:8E9F 4C53            	   505: 		db		"LS"			; String too long
01:8EA1 5354            	   506: 		db		"ST"			; String formula too complex
01:8EA3 434E            	   507: 		db		"CN"			; Can't CONTinue
01:8EA5 5546            	   508: 		db		"UF"			; Undefined FN function
01:8EA7 4D4F            	   509: 		db		"MO"			; Missing operand
01:8EA9 4858            	   510: 		db		"HX"			; HEX error
01:8EAB 424E            	   511: 		db		"BN"			; BIN error
                        	   512: 
                        	   513: ; INITIALISATION TABLE -------------------------------------------------------
                        	   514: 
01:8EAD C36E8C          	   515: INITAB: JP		WARM			; Warm start jump
01:8EB0 C39E94          	   516: 		JP		FCERR			; "USR (X)" jump (Set to Error)
01:8EB3 D300            	   517: 		OUT		(0),A			; "OUT p,n" skeleton
01:8EB5 C9              	   518: 		RET
01:8EB6 D600            	   519: 		SUB		0				; Division support routine
01:8EB8 6F              	   520: 		LD		L,A
01:8EB9 7C              	   521: 		LD		A,H
01:8EBA DE00            	   522: 		SBC		A,0
01:8EBC 67              	   523: 		LD		H,A
01:8EBD 78              	   524: 		LD		A,B
01:8EBE DE00            	   525: 		SBC		A,0
01:8EC0 47              	   526: 		LD		B,A
01:8EC1 3E00            	   527: 		LD		A,0
01:8EC3 C9              	   528: 		RET
01:8EC4 00              	   529: 		db		0,0,0					; Random number seed table used by RND
01:8EC5 00
01:8EC6 00
01:8EC7 35              	   530: 		db		035H,04AH,0CAH,099H		;-2.65145E+07
01:8EC8 4A
01:8EC9 CA
01:8ECA 99
01:8ECB 39              	   531: 		db		039H,01CH,076H,098H		; 1.61291E+07
01:8ECC 1C
01:8ECD 76
01:8ECE 98
01:8ECF 22              	   532: 		db		022H,095H,0B3H,098H		;-1.17691E+07
01:8ED0 95
01:8ED1 B3
01:8ED2 98
01:8ED3 0A              	   533: 		db		00AH,0DDH,047H,098H		; 1.30983E+07
01:8ED4 DD
01:8ED5 47
01:8ED6 98
01:8ED7 53              	   534: 		db		053H,0D1H,099H,099H		;-2-01612E+07
01:8ED8 D1
01:8ED9 99
01:8EDA 99
01:8EDB 0A              	   535: 		db		00AH,01AH,09FH,098H		;-1.04269E+07
01:8EDC 1A
01:8EDD 9F
01:8EDE 98
01:8EDF 65              	   536: 		db		065H,0BCH,0CDH,098H		;-1.34831E+07
01:8EE0 BC
01:8EE1 CD
01:8EE2 98
01:8EE3 D6              	   537: 		db		0D6H,077H,03EH,098H		; 1.24825E+07
01:8EE4 77
01:8EE5 3E
01:8EE6 98
01:8EE7 52              	   538: 		db		052H,0C7H,04FH,080H		; Last random number
01:8EE8 C7
01:8EE9 4F
01:8EEA 80
01:8EEB DB00            	   539: 		IN		A,(0)			; INP (x) skeleton
01:8EED C9              	   540: 		RET
01:8EEE 01              	   541: 		db		1				; POS (x) number (1)
01:8EEF FF              	   542: 		db		255				; Terminal width (255 = no auto CRLF)
01:8EF0 1C              	   543: 		db		28				; Width for commas (3 columns)
01:8EF1 00              	   544: 		db		0				; No nulls after input bytes
01:8EF2 00              	   545: 		db		0				; Output enabled (^O off)
01:8EF3 1400            	   546: 		dw		20				; Initial lines counter
01:8EF5 1400            	   547: 		dw		20				; Initial lines number
01:8EF7 0000            	   548: 		dw		0				; Array load/save check sum
01:8EF9 00              	   549: 		db		0				; Break not by NMI
01:8EFA 00              	   550: 		db		0				; Break flag
01:8EFB C3C191          	   551: 		JP		TTYLIN			; Input reflection (set to TTY)
01:8EFE C30000          	   552: 		JP		$0000			; POINT reflection unused
01:8F01 C30000          	   553: 		JP		$0000			; SET reflection
01:8F04 C30000          	   554: 		JP		$0000			; RESET reflection
01:8F07 5D11            	   555: 		dw		STLOOK			; Temp string space
01:8F09 FEFF            	   556: 		dw		-2				; Current line number (cold)
01:8F0B FA10            	   557: 		dw		PROGST+1		; Start of program text
                        	   558: INITBE:							
                        	   559: 
                        	   560: ; END OF INITIALISATION TABLE ---------------------------------------------------
                        	   561: 
01:8F0D 204572726F72    	   562: ERRMSG: db	" Error",0
01:8F13 00
01:8F14 20696E20        	   563: INMSG:	db	" in ",0
01:8F18 00
                        	   564: ZERBYT	.EQU	$-1				; A zero byte
01:8F19 4F6B            	   565: OKMSG:	db	"Ok",CR,LF,0,0
01:8F1B 0D
01:8F1C 0A
01:8F1D 00
01:8F1E 00
01:8F1F 427265616B      	   566: BRKMSG: db	"Break",0
01:8F24 00
                        	   567: 
01:8F25 210400          	   568: BAKSTK: LD		HL,4			; Look for "FOR" block with
01:8F28 39              	   569: 		ADD		HL,SP			; same index as specified
01:8F29 7E              	   570: LOKFOR: LD		A,(HL)			; Get block ID
01:8F2A 23              	   571: 		INC		HL				; Point to index address
01:8F2B FE81            	   572: 		CP		ZFOR			; Is it a "FOR" token
01:8F2D C0              	   573: 		RET		NZ				; No - exit
01:8F2E 4E              	   574: 		LD		C,(HL)			; BC = Address of "FOR" index
01:8F2F 23              	   575: 		INC		HL
01:8F30 46              	   576: 		LD		B,(HL)
01:8F31 23              	   577: 		INC		HL				; Point to sign of STEP
01:8F32 E5              	   578: 		PUSH	HL				; Save pointer to sign
01:8F33 69              	   579: 		LD		L,C				; HL = address of "FOR" index
01:8F34 60              	   580: 		LD		H,B
01:8F35 7A              	   581: 		LD		A,D				; See if an index was specified
01:8F36 B3              	   582: 		OR		E				; DE = 0 if no index specified
01:8F37 EB              	   583: 		EX		DE,HL			; Specified index into HL
01:8F38 CA3F8F          	   584: 		JP		Z,INDFND		; Skip if no index given
01:8F3B EB              	   585: 		EX		DE,HL			; Index back into DE
01:8F3C CD4492          	   586: 		CALL	CPDEHL			; Compare index with one given
01:8F3F 010D00          	   587: INDFND: LD		BC,16-3			; Offset to next block
01:8F42 E1              	   588: 		POP		HL				; Restore pointer to sign
01:8F43 C8              	   589: 		RET		Z				; Return if block found
01:8F44 09              	   590: 		ADD		HL,BC			; Point to next block
01:8F45 C3298F          	   591: 		JP		LOKFOR			; Keep on looking
                        	   592: 
01:8F48 CD628F          	   593: MOVUP:	CALL	ENFMEM			; See if enough memory
01:8F4B C5              	   594: MOVSTR: PUSH	BC				; Save end of source
01:8F4C E3              	   595: 		EX		(SP),HL			; Swap source and dest" end
01:8F4D C1              	   596: 		POP		BC				; Get end of destination
01:8F4E CD4492          	   597: MOVLP:	CALL	CPDEHL			; See if list moved
01:8F51 7E              	   598: 		LD		A,(HL)			; Get byte
01:8F52 02              	   599: 		LD		(BC),A			; Move it
01:8F53 C8              	   600: 		RET		Z				; Exit if all done
01:8F54 0B              	   601: 		DEC		BC				; Next byte to move to
01:8F55 2B              	   602: 		DEC		HL				; Next byte to move
01:8F56 C34E8F          	   603: 		JP		MOVLP			; Loop until all bytes moved
                        	   604: 
01:8F59 E5              	   605: CHKSTK: PUSH	HL				; Save code string address
01:8F5A 2ADA10          	   606: 		LD		HL,(ARREND)		; Lowest free memory
01:8F5D 0600            	   607: 		LD		B,0				; BC = Number of levels to test
01:8F5F 09              	   608: 		ADD		HL,BC			; 2 Bytes for each level
01:8F60 09              	   609: 		ADD		HL,BC
01:8F61 3E              	   610: 		db	3EH				; Skip "PUSH HL"
01:8F62 E5              	   611: ENFMEM: PUSH	HL				; Save code string address
01:8F63 3ED0            	   612: 		LD		A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
01:8F65 95              	   613: 		SUB		L
01:8F66 6F              	   614: 		LD		L,A
01:8F67 3EFF            	   615: 		LD		A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
01:8F69 9C              	   616: 		SBC		A,H
01:8F6A DA718F          	   617: 		JP		C,OMERR			; Not enough - ?OM Error
01:8F6D 67              	   618: 		LD		H,A
01:8F6E 39              	   619: 		ADD		HL,SP			; Test if stack is overflowed
01:8F6F E1              	   620: 		POP		HL				; Restore code string address
01:8F70 D8              	   621: 		RET		C				; Return if enough mmory
01:8F71 1E0C            	   622: OMERR:	LD		E,OM			; ?OM Error
01:8F73 C3908F          	   623: 		JP		ERROR
                        	   624: 
01:8F76 2AC910          	   625: DATSNR: LD		HL,(DATLIN)		; Get line of current DATA item
01:8F79 225C10          	   626: 		LD		(LINEAT),HL		; Save as current line
01:8F7C 1E02            	   627: SNERR:	LD		E,SN			; ?SN Error
01:8F7E 01              	   628: 		db		01H				; Skip "LD E,DZ"
01:8F7F 1E14            	   629: DZERR:	LD		E,DZ			; ?/0 Error
01:8F81 01              	   630: 		db		01H				; Skip "LD E,NF"
01:8F82 1E00            	   631: NFERR:	LD		E,NF			; ?NF Error
01:8F84 01              	   632: 		db		01H				; Skip "LD E,DD"
01:8F85 1E12            	   633: DDERR:	LD		E,DD			; ?DD Error
01:8F87 01              	   634: 		db		01H				; Skip "LD E,UF"
01:8F88 1E22            	   635: UFERR:	LD		E,UF			; ?UF Error
01:8F8A 01              	   636: 		db		01H				; Skip "LD E,OV
01:8F8B 1E0A            	   637: OVERR:	LD		E,OV			; ?OV Error
01:8F8D 01              	   638: 		db		01H				; Skip "LD E,TM"
01:8F8E 1E18            	   639: TMERR:	LD		E,TM			; ?TM Error
                        	   640: 
01:8F90 CDAE90          	   641: ERROR:	CALL	CLREG			; Clear registers and stack
01:8F93 324510          	   642: 		LD		(CTLOFG),A		; Enable output (A is 0)
01:8F96 CD7296          	   643: 		CALL	STTLIN			; Start new line
01:8F99 21838E          	   644: 		LD		HL,ERRORS		; Point to error codes
01:8F9C 57              	   645: 		LD		D,A				; D = 0 (A is 0)
01:8F9D 3E3F            	   646: 		LD		A,'?'
01:8F9F CD5592          	   647: 		CALL	OUTC			; Output '?'
01:8FA2 19              	   648: 		ADD		HL,DE			; Offset to correct error code
01:8FA3 7E              	   649: 		LD		A,(HL)			; First character
01:8FA4 CD5592          	   650: 		CALL	OUTC			; Output it
01:8FA7 CDD493          	   651: 		CALL	GETCHR			; Get next character
01:8FAA CD5592          	   652: 		CALL	OUTC			; Output it
01:8FAD 210D8F          	   653: 		LD		HL,ERRMSG		; "Error" message
01:8FB0 CD169D          	   654: ERRIN:	CALL	PRS				; Output message
01:8FB3 2A5C10          	   655: 		LD		HL,(LINEAT)		; Get line of error
01:8FB6 11FEFF          	   656: 		LD		DE,-2			; Cold start error if -2
01:8FB9 CD4492          	   657: 		CALL	CPDEHL			; See if cold start error
01:8FBC CADB8B          	   658: 		JP		Z,CSTART		; Cold start error - Restart
01:8FBF 7C              	   659: 		LD		A,H				; Was it a direct error?
01:8FC0 A5              	   660: 		AND		L				; Line = -1 if direct error
01:8FC1 3C              	   661: 		INC		A
01:8FC2 C4B1A3          	   662: 		CALL	NZ,LINEIN		; No - output line of error
01:8FC5 3E              	   663: 		db		3EH				; Skip "POP BC"
01:8FC6 C1              	   664: POPNOK: POP		BC				; Drop address in input buffer
                        	   665: 
01:8FC7 AF              	   666: PRNTOK: XOR		A				; Output "Ok" and get command
01:8FC8 324510          	   667: 		LD		(CTLOFG),A		; Enable output
01:8FCB CD7296          	   668: 		CALL	STTLIN			; Start new line
01:8FCE 21198F          	   669: 		LD		HL,OKMSG		; "Ok" message
01:8FD1 CD169D          	   670: 		CALL	PRS				; Output "Ok"
01:8FD4 21FFFF          	   671: GETCMD: LD		HL,-1			; Flag direct mode
01:8FD7 225C10          	   672: 		LD		(LINEAT),HL		; Save as current line
01:8FDA CDC191          	   673: 		CALL	GETLIN			; Get an input line
01:8FDD DAD48F          	   674: 		JP		C,GETCMD		; Get line again if break
01:8FE0 CDD493          	   675: 		CALL	GETCHR			; Get first character
01:8FE3 3C              	   676: 		INC		A				; Test if end of line
01:8FE4 3D              	   677: 		DEC		A				; Without affecting Carry
01:8FE5 CAD48F          	   678: 		JP		Z,GETCMD		; Nothing entered - Get another
01:8FE8 F5              	   679: 		PUSH	AF				; Save Carry status
01:8FE9 CDA394          	   680: 		CALL	ATOH			; Get line number into DE
01:8FEC D5              	   681: 		PUSH	DE				; Save line number
01:8FED CDD890          	   682: 		CALL	CRUNCH			; Tokenise rest of line
01:8FF0 47              	   683: 		LD		B,A				; Length of tokenised line
01:8FF1 D1              	   684: 		POP		DE				; Restore line number
01:8FF2 F1              	   685: 		POP		AF				; Restore Carry
01:8FF3 D2B493          	   686: 		JP		NC,EXCUTE		; No line number - Direct mode
01:8FF6 D5              	   687: 		PUSH	DE				; Save line number
01:8FF7 C5              	   688: 		PUSH	BC				; Save length of tokenised line
01:8FF8 AF              	   689: 		XOR		A
01:8FF9 32CC10          	   690: 		LD		(LSTBIN),A		; Clear last byte input
01:8FFC CDD493          	   691: 		CALL	GETCHR			; Get next character
01:8FFF B7              	   692: 		OR		A				; Set flags
01:9000 F5              	   693: 		PUSH	AF				; And save them
01:9001 CD6890          	   694: 		CALL	SRCHLN			; Search for line number in DE
01:9004 DA0D90          	   695: 		JP		C,LINFND		; Jump if line found
01:9007 F1              	   696: 		POP		AF				; Get status
01:9008 F5              	   697: 		PUSH	AF				; And re-save
01:9009 CA4495          	   698: 		JP		Z,ULERR			; Nothing after number - Error
01:900C B7              	   699: 		OR		A				; Clear Carry
01:900D C5              	   700: LINFND: PUSH	BC				; Save address of line in prog
01:900E D22490          	   701: 		JP		NC,INEWLN		; Line not found - Insert new
01:9011 EB              	   702: 		EX		DE,HL			; Next line address in DE
01:9012 2AD610          	   703: 		LD		HL,(PROGND)		; End of program
01:9015 1A              	   704: SFTPRG: LD		A,(DE)			; Shift rest of program down
01:9016 02              	   705: 		LD		(BC),A
01:9017 03              	   706: 		INC		BC				; Next destination
01:9018 13              	   707: 		INC		DE				; Next source
01:9019 CD4492          	   708: 		CALL	CPDEHL			; All done?
01:901C C21590          	   709: 		JP		NZ,SFTPRG		; More to do
01:901F 60              	   710: 		LD		H,B				; HL - New end of program
01:9020 69              	   711: 		LD		L,C
01:9021 22D610          	   712: 		LD		(PROGND),HL		; Update end of program
                        	   713: 
01:9024 D1              	   714: INEWLN: POP		DE				; Get address of line,
01:9025 F1              	   715: 		POP		AF				; Get status
01:9026 CA4B90          	   716: 		JP		Z,SETPTR		; No text - Set up pointers
01:9029 2AD610          	   717: 		LD		HL,(PROGND)		; Get end of program
01:902C E3              	   718: 		EX		(SP),HL			; Get length of input line
01:902D C1              	   719: 		POP		BC				; End of program to BC
01:902E 09              	   720: 		ADD		HL,BC			; Find new end
01:902F E5              	   721: 		PUSH	HL				; Save new end
01:9030 CD488F          	   722: 		CALL	MOVUP			; Make space for line
01:9033 E1              	   723: 		POP		HL				; Restore new end
01:9034 22D610          	   724: 		LD		(PROGND),HL		; Update end of program pointer
01:9037 EB              	   725: 		EX		DE,HL			; Get line to move up in HL
01:9038 74              	   726: 		LD		(HL),H			; Save MSB
01:9039 D1              	   727: 		POP		DE				; Get new line number
01:903A 23              	   728: 		INC		HL				; Skip pointer
01:903B 23              	   729: 		INC		HL
01:903C 73              	   730: 		LD		(HL),E			; Save LSB of line number
01:903D 23              	   731: 		INC		HL
01:903E 72              	   732: 		LD		(HL),D			; Save MSB of line number
01:903F 23              	   733: 		INC		HL				; To first byte in line
01:9040 116110          	   734: 		LD		DE,BUFFER		; Copy buffer to program
01:9043 1A              	   735: MOVBUF: LD		A,(DE)			; Get source
01:9044 77              	   736: 		LD		(HL),A			; Save destinations
01:9045 23              	   737: 		INC		HL				; Next source
01:9046 13              	   738: 		INC		DE				; Next destination
01:9047 B7              	   739: 		OR		A				; Done?
01:9048 C24390          	   740: 		JP		NZ,MOVBUF		; No - Repeat
01:904B CD9490          	   741: SETPTR: CALL	RUNFST			; Set line pointers
01:904E 23              	   742: 		INC		HL				; To LSB of pointer
01:904F EB              	   743: 		EX		DE,HL			; Address to DE
01:9050 62              	   744: PTRLP:	LD		H,D				; Address to HL
01:9051 6B              	   745: 		LD		L,E
01:9052 7E              	   746: 		LD		A,(HL)			; Get LSB of pointer
01:9053 23              	   747: 		INC		HL				; To MSB of pointer
01:9054 B6              	   748: 		OR		(HL)			; Compare with MSB pointer
01:9055 CAD48F          	   749: 		JP		Z,GETCMD		; Get command line if end
01:9058 23              	   750: 		INC		HL				; To LSB of line number
01:9059 23              	   751: 		INC		HL				; Skip line number
01:905A 23              	   752: 		INC		HL				; Point to first byte in line
01:905B AF              	   753: 		XOR		A				; Looking for 00 byte
01:905C BE              	   754: FNDEND: CP		(HL)			; Found end of line?
01:905D 23              	   755: 		INC		HL				; Move to next byte
01:905E C25C90          	   756: 		JP		NZ,FNDEND		; No - Keep looking
01:9061 EB              	   757: 		EX		DE,HL			; Next line address to HL
01:9062 73              	   758: 		LD		(HL),E			; Save LSB of pointer
01:9063 23              	   759: 		INC		HL
01:9064 72              	   760: 		LD		(HL),D			; Save MSB of pointer
01:9065 C35090          	   761: 		JP		PTRLP			; Do next line
                        	   762: 
01:9068 2A5E10          	   763: SRCHLN: LD		HL,(BASTXT)		; Start of program text
01:906B 44              	   764: SRCHLP: LD		B,H				; BC = Address to look at
01:906C 4D              	   765: 		LD		C,L
01:906D 7E              	   766: 		LD		A,(HL)			; Get address of next line
01:906E 23              	   767: 		INC		HL
01:906F B6              	   768: 		OR		(HL)			; End of program found?
01:9070 2B              	   769: 		DEC		HL
01:9071 C8              	   770: 		RET		Z				; Yes - Line not found
01:9072 23              	   771: 		INC		HL
01:9073 23              	   772: 		INC		HL
01:9074 7E              	   773: 		LD		A,(HL)			; Get LSB of line number
01:9075 23              	   774: 		INC		HL
01:9076 66              	   775: 		LD		H,(HL)			; Get MSB of line number
01:9077 6F              	   776: 		LD		L,A
01:9078 CD4492          	   777: 		CALL	CPDEHL			; Compare with line in DE
01:907B 60              	   778: 		LD		H,B				; HL = Start of this line
01:907C 69              	   779: 		LD		L,C
01:907D 7E              	   780: 		LD		A,(HL)			; Get LSB of next line address
01:907E 23              	   781: 		INC		HL
01:907F 66              	   782: 		LD		H,(HL)			; Get MSB of next line address
01:9080 6F              	   783: 		LD		L,A				; Next line to HL
01:9081 3F              	   784: 		CCF
01:9082 C8              	   785: 		RET		Z				; Lines found - Exit
01:9083 3F              	   786: 		CCF
01:9084 D0              	   787: 		RET		NC				; Line not found,at line after
01:9085 C36B90          	   788: 		JP		SRCHLP			; Keep looking
                        	   789: 
01:9088 C0              	   790: NEW:	RET		NZ				; Return if any more on line
01:9089 2A5E10          	   791: CLRPTR: LD		HL,(BASTXT)		; Point to start of program
01:908C AF              	   792: 		XOR		A				; Set program area to empty
01:908D 77              	   793: 		LD		(HL),A			; Save LSB = 00
01:908E 23              	   794: 		INC		HL
01:908F 77              	   795: 		LD		(HL),A			; Save MSB = 00
01:9090 23              	   796: 		INC		HL
01:9091 22D610          	   797: 		LD		(PROGND),HL		; Set program end
                        	   798: 
01:9094 2A5E10          	   799: RUNFST: LD		HL,(BASTXT)		; Clear all variables
01:9097 2B              	   800: 		DEC		HL
                        	   801: 
01:9098 22CE10          	   802: INTVAR: LD		(BRKLIN),HL		; Initialise RUN variables
01:909B 2AAF10          	   803: 		LD		HL,(LSTRAM)		; Get end of RAM
01:909E 22C310          	   804: 		LD		(STRBOT),HL		; Clear string space
01:90A1 AF              	   805: 		XOR		A
01:90A2 CDE493          	   806: 		CALL	RESTOR			; Reset DATA pointers
01:90A5 2AD610          	   807: 		LD		HL,(PROGND)		; Get end of program
01:90A8 22D810          	   808: 		LD		(VAREND),HL		; Clear variables
01:90AB 22DA10          	   809: 		LD		(ARREND),HL		; Clear arrays
                        	   810: 
01:90AE C1              	   811: CLREG:	POP		BC				; Save return address
01:90AF 2A5A10          	   812: 		LD		HL,(STRSPC)		; Get end of working RAN
01:90B2 F9              	   813: 		LD		SP,HL			; Set stack
01:90B3 21B310          	   814: 		LD		HL,TMSTPL		; Temporary string pool
01:90B6 22B110          	   815: 		LD		(TMSTPT),HL		; Reset temporary string ptr
01:90B9 AF              	   816: 		XOR		A				; A = 00
01:90BA 6F              	   817: 		LD		L,A				; HL = 0000
01:90BB 67              	   818: 		LD		H,A
01:90BC 22D410          	   819: 		LD		(CONTAD),HL		; No CONTinue
01:90BF 32CB10          	   820: 		LD		(FORFLG),A		; Clear FOR flag
01:90C2 22DE10          	   821: 		LD		(FNRGNM),HL		; Clear FN argument
01:90C5 E5              	   822: 		PUSH	HL				; HL = 0000
01:90C6 C5              	   823: 		PUSH	BC				; Put back return
01:90C7 2ACE10          	   824: DOAGN:	LD		HL,(BRKLIN)		; Get address of code to RUN
01:90CA C9              	   825: 		RET						; Return to execution driver
                        	   826: 
01:90CB 3E3F            	   827: PROMPT: LD		A,'?'			; '?'
01:90CD CD5592          	   828: 		CALL	OUTC			; Output character
01:90D0 3E20            	   829: 		LD		A,' '			; Space
01:90D2 CD5592          	   830: 		CALL	OUTC			; Output character
01:90D5 C34E10          	   831: 		JP		RINPUT			; Get input line
                        	   832: 
01:90D8 AF              	   833: CRUNCH: XOR		A				; Tokenise line @ HL to BUFFER
01:90D9 32AE10          	   834: 		LD		(DATFLG),A		; Reset literal flag
01:90DC 0E05            	   835: 		LD		C,2+3			; 2 byte number and 3 nulls
01:90DE 116110          	   836: 		LD		DE,BUFFER		; Start of input buffer
01:90E1 7E              	   837: CRNCLP: LD		A,(HL)			; Get byte
01:90E2 FE20            	   838: 		CP		' '				; Is it a space?
01:90E4 CA6091          	   839: 		JP		Z,MOVDIR		; Yes - Copy direct
01:90E7 47              	   840: 		LD		B,A				; Save character
01:90E8 FE22            	   841: 		CP		'"'				; Is it a quote?"
01:90EA CA8091          	   842: 		JP		Z,CPYLIT		; Yes - Copy literal string
01:90ED B7              	   843: 		OR		A				; Is it end of buffer?
01:90EE CA8791          	   844: 		JP		Z,ENDBUF		; Yes - End buffer
01:90F1 3AAE10          	   845: 		LD		A,(DATFLG)		; Get data type
01:90F4 B7              	   846: 		OR		A				; Literal?
01:90F5 7E              	   847: 		LD		A,(HL)			; Get byte to copy
01:90F6 C26091          	   848: 		JP		NZ,MOVDIR		; Literal - Copy direct
01:90F9 FE3F            	   849: 		CP		'?'				; Is it '?' short for PRINT
01:90FB 3E9E            	   850: 		LD		A,ZPRINT		; "PRINT" token
01:90FD CA6091          	   851: 		JP		Z,MOVDIR		; Yes - replace it
01:9100 7E              	   852: 		LD		A,(HL)			; Get byte again
01:9101 FE30            	   853: 		CP		'0'				; Is it less than '0'
01:9103 DA0B91          	   854: 		JP		C,FNDWRD		; Yes - Look for reserved words
01:9106 FE3C            	   855: 		CP		60; ";"+1			; Is it "0123456789:;" ?
01:9108 DA6091          	   856: 		JP		C,MOVDIR		; Yes - copy it direct
01:910B D5              	   857: FNDWRD: PUSH	DE				; Look for reserved words
01:910C 11FE8C          	   858: 		LD		DE,WORDS-1		; Point to table
01:910F C5              	   859: 		PUSH	BC				; Save count
01:9110 015C91          	   860: 		LD		BC,RETNAD		; Where to return to
01:9113 C5              	   861: 		PUSH	BC				; Save return address
01:9114 067F            	   862: 		LD		B,ZEND-1		; First token value -1
01:9116 7E              	   863: 		LD		A,(HL)			; Get byte
01:9117 FE61            	   864: 		CP		'a'				; Less than 'a' ?
01:9119 DA2491          	   865: 		JP		C,SEARCH		; Yes - search for words
01:911C FE7B            	   866: 		CP		'z'+1			; Greater than 'z' ?
01:911E D22491          	   867: 		JP		NC,SEARCH		; Yes - search for words
01:9121 E65F            	   868: 		AND		01011111B		; Force upper case
01:9123 77              	   869: 		LD		(HL),A			; Replace byte
01:9124 4E              	   870: SEARCH: LD		C,(HL)			; Search for a word
01:9125 EB              	   871: 		EX		DE,HL
01:9126 23              	   872: GETNXT: INC		HL				; Get next reserved word
01:9127 B6              	   873: 		OR		(HL)			; Start of word?
01:9128 F22691          	   874: 		JP		P,GETNXT		; No - move on
01:912B 04              	   875: 		INC		B				; Increment token value
01:912C 7E              	   876: 		LD		A, (HL)			; Get byte from table
01:912D E67F            	   877: 		AND		01111111B		; Strip bit 7
01:912F C8              	   878: 		RET		Z				; Return if end of list
01:9130 B9              	   879: 		CP		C				; Same character as in buffer?
01:9131 C22691          	   880: 		JP		NZ,GETNXT		; No - get next word
01:9134 EB              	   881: 		EX		DE,HL
01:9135 E5              	   882: 		PUSH	HL				; Save start of word
                        	   883: 
01:9136 13              	   884: NXTBYT: INC		DE				; Look through rest of word
01:9137 1A              	   885: 		LD		A,(DE)			; Get byte from table
01:9138 B7              	   886: 		OR		A				; End of word ?
01:9139 FA5891          	   887: 		JP		M,MATCH			; Yes - Match found
01:913C 4F              	   888: 		LD		C,A				; Save it
01:913D 78              	   889: 		LD		A,B				; Get token value
01:913E FE88            	   890: 		CP		ZGOTO			; Is it "GOTO" token ?
01:9140 C24791          	   891: 		JP		NZ,NOSPC		; No - Don't allow spaces
01:9143 CDD493          	   892: 		CALL	GETCHR			; Get next character
01:9146 2B              	   893: 		DEC		HL				; Cancel increment from GETCHR
01:9147 23              	   894: NOSPC:	INC		HL				; Next byte
01:9148 7E              	   895: 		LD		A,(HL)			; Get byte
01:9149 FE61            	   896: 		CP		'a'				; Less than 'a' ?
01:914B DA5091          	   897: 		JP		C,NOCHNG		; Yes - don't change
01:914E E65F            	   898: 		AND		01011111B		; Make upper case
01:9150 B9              	   899: NOCHNG: CP		C				; Same as in buffer ?
01:9151 CA3691          	   900: 		JP		Z,NXTBYT		; Yes - keep testing
01:9154 E1              	   901: 		POP		HL				; Get back start of word
01:9155 C32491          	   902: 		JP		SEARCH			; Look at next word
                        	   903: 
01:9158 48              	   904: MATCH:	LD		C,B				; Word found - Save token value
01:9159 F1              	   905: 		POP		AF				; Throw away return
01:915A EB              	   906: 		EX		DE,HL
01:915B C9              	   907: 		RET						; Return to "RETNAD"
01:915C EB              	   908: RETNAD: EX		DE,HL			; Get address in string
01:915D 79              	   909: 		LD		A,C				; Get token value
01:915E C1              	   910: 		POP		BC				; Restore buffer length
01:915F D1              	   911: 		POP		DE				; Get destination address
01:9160 23              	   912: MOVDIR: INC		HL				; Next source in buffer
01:9161 12              	   913: 		LD		(DE),A			; Put byte in buffer
01:9162 13              	   914: 		INC		DE				; Move up buffer
01:9163 0C              	   915: 		INC		C				; Increment length of buffer
01:9164 D63A            	   916: 		SUB		':'				; End of statement?
01:9166 CA6E91          	   917: 		JP		Z,SETLIT		; Jump if multi-statement line
01:9169 FE49            	   918: 		CP		ZDATA-3AH		; Is it DATA statement ?
01:916B C27191          	   919: 		JP		NZ,TSTREM		; No - see if REM
01:916E 32AE10          	   920: SETLIT: LD		(DATFLG),A		; Set literal flag
01:9171 D654            	   921: TSTREM: SUB		ZREM-3AH		; Is it REM?
01:9173 C2E190          	   922: 		JP		NZ,CRNCLP		; No - Leave flag
01:9176 47              	   923: 		LD		B,A				; Copy rest of buffer
01:9177 7E              	   924: NXTCHR: LD		A,(HL)			; Get byte
01:9178 B7              	   925: 		OR		A				; End of line ?
01:9179 CA8791          	   926: 		JP		Z,ENDBUF		; Yes - Terminate buffer
01:917C B8              	   927: 		CP		B				; End of statement ?
01:917D CA6091          	   928: 		JP		Z,MOVDIR		; Yes - Get next one
01:9180 23              	   929: CPYLIT: INC		HL				; Move up source string
01:9181 12              	   930: 		LD		(DE),A			; Save in destination
01:9182 0C              	   931: 		INC		C				; Increment length
01:9183 13              	   932: 		INC		DE				; Move up destination
01:9184 C37791          	   933: 		JP		NXTCHR			; Repeat
                        	   934: 
01:9187 216010          	   935: ENDBUF: LD		HL,BUFFER-1		; Point to start of buffer
01:918A 12              	   936: 		LD		(DE),A			; Mark end of buffer (A = 00)
01:918B 13              	   937: 		INC		DE
01:918C 12              	   938: 		LD		(DE),A			; A = 00
01:918D 13              	   939: 		INC		DE
01:918E 12              	   940: 		LD		(DE),A			; A = 00
01:918F C9              	   941: 		RET
                        	   942: 
01:9190 3A4410          	   943: DODEL:	LD		A,(NULFLG)		; Get null flag status
01:9193 B7              	   944: 		OR		A				; Is it zero?
01:9194 3E00            	   945: 		LD		A,0				; Zero A - Leave flags
01:9196 324410          	   946: 		LD		(NULFLG),A		; Zero null flag
01:9199 C2A491          	   947: 		JP		NZ,ECHDEL		; Set - Echo it
01:919C 05              	   948: 		DEC		B				; Decrement length
01:919D CAC191          	   949: 		JP		Z,GETLIN		; Get line again if empty
01:91A0 CD5592          	   950: 		CALL	OUTC			; Output null character
01:91A3 3E              	   951: 		db	3EH				; Skip "DEC B"
01:91A4 05              	   952: ECHDEL: DEC		B				; Count bytes in buffer
01:91A5 2B              	   953: 		DEC		HL				; Back space buffer
01:91A6 CAB891          	   954: 		JP		Z,OTKLN			; No buffer - Try again
01:91A9 7E              	   955: 		LD		A,(HL)			; Get deleted byte
01:91AA CD5592          	   956: 		CALL	OUTC			; Echo it
01:91AD C3CA91          	   957: 		JP		MORINP			; Get more input
                        	   958: 
01:91B0 05              	   959: DELCHR: DEC		B				; Count bytes in buffer
01:91B1 2B              	   960: 		DEC		HL				; Back space buffer
01:91B2 CD5592          	   961: 		CALL	OUTC			; Output character in A
01:91B5 C2CA91          	   962: 		JP		NZ,MORINP		; Not end - Get more
01:91B8 CD5592          	   963: OTKLN:	CALL	OUTC			; Output character in A
01:91BB CD8180          	   964: KILIN:	CALL	PrintCRLF		; Output CRLF
01:91BE C3C191          	   965: 		JP		TTYLIN			; Get line again
                        	   966: 
                        	   967: GETLIN:
01:91C1 216110          	   968: TTYLIN: LD		HL,BUFFER		; Get a line by character
01:91C4 0601            	   969: 		LD		B,1				; Set buffer as empty
01:91C6 AF              	   970: 		XOR		A
01:91C7 324410          	   971: 		LD		(NULFLG),A		; Clear null flag
01:91CA CD7F92          	   972: MORINP: CALL	CLOTST			; Get character and test ^O
01:91CD 4F              	   973: 		LD		C,A				; Save character in C
01:91CE FE7F            	   974: 		CP		DEL				; Delete character?
01:91D0 CA9091          	   975: 		JP		Z,DODEL			; Yes - Process it
01:91D3 3A4410          	   976: 		LD		A,(NULFLG)		; Get null flag
01:91D6 B7              	   977: 		OR		A				; Test null flag status
01:91D7 CAE391          	   978: 		JP		Z,PROCES		; Reset - Process character
01:91DA 3E00            	   979: 		LD		A,0				; Set a null
01:91DC CD5592          	   980: 		CALL	OUTC			; Output null
01:91DF AF              	   981: 		XOR		A				; Clear A
01:91E0 324410          	   982: 		LD		(NULFLG),A		; Reset null flag
01:91E3 79              	   983: PROCES: LD		A,C				; Get character
01:91E4 FE07            	   984: 		CP		CTRLG			; Bell?
01:91E6 CA2792          	   985: 		JP		Z,PUTCTL		; Yes - Save it
01:91E9 FE03            	   986: 		CP		CTRLC			; Is it control "C"?
01:91EB CC8180          	   987: 		CALL	Z,PrintCRLF		; Yes - Output CRLF
01:91EE 37              	   988: 		SCF						; Flag break
01:91EF C8              	   989: 		RET		Z				; Return if control "C"
01:91F0 FE0D            	   990: 		CP		CR				; Is it enter?
01:91F2 CA7A96          	   991: 		JP		Z,ENDINP		; Yes - Terminate input
01:91F5 FE15            	   992: 		CP		CTRLU			; Is it control "U"?
01:91F7 CABB91          	   993: 		JP		Z,KILIN			; Yes - Get another line
01:91FA FE40            	   994: 		CP		'@'				; Is it "kill line"?
01:91FC CAB891          	   995: 		JP		Z,OTKLN			; Yes - Kill line
01:91FF FE5F            	   996: 		CP		'_'				; Is it delete?
01:9201 CAB091          	   997: 		JP		Z,DELCHR		; Yes - Delete character
01:9204 FE08            	   998: 		CP		BKSP			; Is it backspace?
01:9206 CAB091          	   999: 		JP		Z,DELCHR		; Yes - Delete character
01:9209 FE12            	  1000: 		CP		CTRLR			; Is it control "R"?
01:920B C22292          	  1001: 		JP		NZ,PUTBUF		; No - Put in buffer
01:920E C5              	  1002: 		PUSH	BC				; Save buffer length
01:920F D5              	  1003: 		PUSH	DE				; Save DE
01:9210 E5              	  1004: 		PUSH	HL				; Save buffer address
01:9211 3600            	  1005: 		LD		(HL),0			; Mark end of buffer
01:9213 CD2CA8          	  1006: 		CALL	OUTNCR			; Output and do CRLF
01:9216 216110          	  1007: 		LD		HL,BUFFER		; Point to buffer start
01:9219 CD169D          	  1008: 		CALL	PRS				; Output buffer
01:921C E1              	  1009: 		POP		HL				; Restore buffer address
01:921D D1              	  1010: 		POP		DE				; Restore DE
01:921E C1              	  1011: 		POP		BC				; Restore buffer length
01:921F C3CA91          	  1012: 		JP		MORINP			; Get another character
                        	  1013: 
01:9222 FE20            	  1014: PUTBUF: CP		' '				; Is it a control code?
01:9224 DACA91          	  1015: 		JP		C,MORINP		; Yes - Ignore
01:9227 78              	  1016: PUTCTL: LD		A,B				; Get number of bytes in buffer
01:9228 FE49            	  1017: 		CP		72+1			; Test for line overflow
01:922A 3E07            	  1018: 		LD		A,CTRLG			; Set a bell
01:922C D23C92          	  1019: 		JP		NC,OUTNBS		; Ring bell if buffer full
01:922F 79              	  1020: 		LD		A,C				; Get character
01:9230 71              	  1021: 		LD		(HL),C			; Save in buffer
01:9231 32CC10          	  1022: 		LD		(LSTBIN),A		; Save last input byte
01:9234 23              	  1023: 		INC		HL				; Move up buffer
01:9235 04              	  1024: 		INC		B				; Increment length
01:9236 CD5592          	  1025: OUTIT:	CALL	OUTC			; Output the character entered
01:9239 C3CA91          	  1026: 		JP		MORINP			; Get another character
                        	  1027: 
01:923C CD5592          	  1028: OUTNBS: CALL	OUTC			; Output bell and back over it
01:923F 3E08            	  1029: 		LD		A,BKSP			; Set back space
01:9241 C33692          	  1030: 		JP		OUTIT			; Output it and get more
                        	  1031: 
01:9244 7C              	  1032: CPDEHL: LD		A,H				; Get H
01:9245 92              	  1033: 		SUB		D				; Compare with D
01:9246 C0              	  1034: 		RET		NZ				; Different - Exit
01:9247 7D              	  1035: 		LD		A,L				; Get L
01:9248 93              	  1036: 		SUB		E				; Compare with E
01:9249 C9              	  1037: 		RET						; Return status
                        	  1038: 
01:924A 7E              	  1039: CHKSYN: LD		A,(HL)			; Check syntax of character
01:924B E3              	  1040: 		EX		(SP),HL			; Address of test byte
01:924C BE              	  1041: 		CP		(HL)			; Same as in code string?
01:924D 23              	  1042: 		INC		HL				; Return address
01:924E E3              	  1043: 		EX		(SP),HL			; Put it back
01:924F CAD493          	  1044: 		JP		Z,GETCHR		; Yes - Get next character
01:9252 C37C8F          	  1045: 		JP		SNERR			; Different - ?SN Error
                        	  1046: 
01:9255 F5              	  1047: OUTC:	PUSH	AF				; Save character
01:9256 3A4510          	  1048: 		LD		A,(CTLOFG)		; Get control "O" flag
01:9259 B7              	  1049: 		OR		A				; Is it set?
01:925A C24B9D          	  1050: 		JP		NZ,POPAF		; Yes - don't output
01:925D F1              	  1051: 		POP		AF				; Restore character
01:925E C5              	  1052: 		PUSH	BC				; Save buffer length
01:925F F5              	  1053: 		PUSH	AF				; Save character
01:9260 FE20            	  1054: 		CP		' '				; Is it a control code?
01:9262 DA7992          	  1055: 		JP		C,DINPOS		; Yes - Don't INC POS(X)
01:9265 3A4210          	  1056: 		LD		A,(LWIDTH)		; Get line width
01:9268 47              	  1057: 		LD		B,A				; To B
01:9269 3AAB10          	  1058: 		LD		A,(CURPOS)		; Get cursor position
01:926C 04              	  1059: 		INC		B				; Width 255?
01:926D CA7592          	  1060: 		JP		Z,INCLEN		; Yes - No width limit
01:9270 05              	  1061: 		DEC		B				; Restore width
01:9271 B8              	  1062: 		CP		B				; At end of line?
01:9272 CC8180          	  1063: 		CALL	Z,PrintCRLF		; Yes - output CRLF
01:9275 3C              	  1064: INCLEN: INC		A				; Move on one character
01:9276 32AB10          	  1065: 		LD		(CURPOS),A		; Save new position
01:9279 F1              	  1066: DINPOS: POP		AF				; Restore character
01:927A C1              	  1067: 		POP		BC				; Restore buffer length
01:927B CD15A8          	  1068: 		CALL	MONOUT			; Send it
01:927E C9              	  1069: 		RET
                        	  1070: 
01:927F CDD5A6          	  1071: CLOTST: CALL	GETINP			; Get input character
01:9282 E67F            	  1072: 		AND		01111111B		; Strip bit 7
01:9284 FE0F            	  1073: 		CP		CTRLO			; Is it control "O"?
01:9286 C0              	  1074: 		RET		NZ				; No don't flip flag
01:9287 3A4510          	  1075: 		LD		A,(CTLOFG)		; Get flag
01:928A 2F              	  1076: 		CPL						; Flip it
01:928B 324510          	  1077: 		LD		(CTLOFG),A		; Put it back
01:928E AF              	  1078: 		XOR		A				; Null character
01:928F C9              	  1079: 		RET
                        	  1080: 
01:9290 CDA394          	  1081: LISTT:	CALL	ATOH			; ASCII number to DE
01:9293 C0              	  1082: 		RET		NZ				; Return if anything extra
01:9294 C1              	  1083: 		POP		BC				; Rubbish - Not needed
01:9295 CD6890          	  1084: 		CALL	SRCHLN			; Search for line number in DE
01:9298 C5              	  1085: 		PUSH	BC				; Save address of line
01:9299 CDE692          	  1086: 		CALL	SETLIN			; Set up lines counter
01:929C E1              	  1087: LISTLP: POP		HL				; Restore address of line
01:929D 4E              	  1088: 		LD		C,(HL)			; Get LSB of next line
01:929E 23              	  1089: 		INC		HL
01:929F 46              	  1090: 		LD		B,(HL)			; Get MSB of next line
01:92A0 23              	  1091: 		INC		HL
01:92A1 78              	  1092: 		LD		A,B				; BC = 0 (End of program)?
01:92A2 B1              	  1093: 		OR		C
01:92A3 CAC78F          	  1094: 		JP		Z,PRNTOK		; Yes - Go to command mode
01:92A6 CDEF92          	  1095: 		CALL	COUNT			; Count lines
01:92A9 CDFF93          	  1096: 		CALL	TSTBRK			; Test for break key
01:92AC C5              	  1097: 		PUSH	BC				; Save address of next line
01:92AD CD8180          	  1098: 		CALL	PrintCRLF		; Output CRLF
01:92B0 5E              	  1099: 		LD		E,(HL)			; Get LSB of line number
01:92B1 23              	  1100: 		INC		HL
01:92B2 56              	  1101: 		LD		D,(HL)			; Get MSB of line number
01:92B3 23              	  1102: 		INC		HL
01:92B4 E5              	  1103: 		PUSH	HL				; Save address of line start
01:92B5 EB              	  1104: 		EX		DE,HL			; Line number to HL
01:92B6 CDB9A3          	  1105: 		CALL	PRNTHL			; Output line number in decimal
01:92B9 3E20            	  1106: 		LD		A,' '			; Space after line number
01:92BB E1              	  1107: 		POP		HL				; Restore start of line address
01:92BC CD5592          	  1108: LSTLP2: CALL	OUTC			; Output character in A
01:92BF 7E              	  1109: LSTLP3: LD		A,(HL)			; Get next byte in line
01:92C0 B7              	  1110: 		OR		A				; End of line?
01:92C1 23              	  1111: 		INC		HL				; To next byte in line
01:92C2 CA9C92          	  1112: 		JP		Z,LISTLP		; Yes - get next line
01:92C5 F2BC92          	  1113: 		JP		P,LSTLP2		; No token - output it
01:92C8 D67F            	  1114: 		SUB		ZEND-1			; Find and output word
01:92CA 4F              	  1115: 		LD		C,A				; Token offset+1 to C
01:92CB 11FF8C          	  1116: 		LD		DE,WORDS		; Reserved word list
01:92CE 1A              	  1117: FNDTOK: LD		A,(DE)			; Get character in list
01:92CF 13              	  1118: 		INC		DE				; Move on to next
01:92D0 B7              	  1119: 		OR		A				; Is it start of word?
01:92D1 F2CE92          	  1120: 		JP		P,FNDTOK		; No - Keep looking for word
01:92D4 0D              	  1121: 		DEC		C				; Count words
01:92D5 C2CE92          	  1122: 		JP		NZ,FNDTOK		; Not there - keep looking
01:92D8 E67F            	  1123: OUTWRD: AND		01111111B		; Strip bit 7
01:92DA CD5592          	  1124: 		CALL	OUTC			; Output first character
01:92DD 1A              	  1125: 		LD		A,(DE)			; Get next character
01:92DE 13              	  1126: 		INC		DE				; Move on to next
01:92DF B7              	  1127: 		OR		A				; Is it end of word?
01:92E0 F2D892          	  1128: 		JP		P,OUTWRD		; No - output the rest
01:92E3 C3BF92          	  1129: 		JP		LSTLP3			; Next byte in line
                        	  1130: 
01:92E6 E5              	  1131: SETLIN: PUSH	HL				; Set up LINES counter
01:92E7 2A4810          	  1132: 		LD		HL,(LINESN)		; Get LINES number
01:92EA 224610          	  1133: 		LD		(LINESC),HL		; Save in LINES counter
01:92ED E1              	  1134: 		POP		HL
01:92EE C9              	  1135: 		RET
                        	  1136: 
01:92EF E5              	  1137: COUNT:	PUSH	HL				; Save code string address
01:92F0 D5              	  1138: 		PUSH	DE
01:92F1 2A4610          	  1139: 		LD		HL,(LINESC)		; Get LINES counter
01:92F4 11FFFF          	  1140: 		LD		DE,-1
01:92F7 ED5A            	  1141: 		ADC		HL,DE			; Decrement
01:92F9 224610          	  1142: 		LD		(LINESC),HL		; Put it back
01:92FC D1              	  1143: 		POP		DE
01:92FD E1              	  1144: 		POP		HL				; Restore code string address
01:92FE F0              	  1145: 		RET		P				; Return if more lines to go
01:92FF E5              	  1146: 		PUSH	HL				; Save code string address
01:9300 2A4810          	  1147: 		LD		HL,(LINESN)		; Get LINES number
01:9303 224610          	  1148: 		LD		(LINESC),HL		; Reset LINES counter
01:9306 CDD5A6          	  1149: 		CALL	GETINP			; Get input character
01:9309 FE03            	  1150: 		CP		CTRLC			; Is it control "C"?
01:930B CA1293          	  1151: 		JP		Z,RSLNBK		; Yes - Reset LINES and break
01:930E E1              	  1152: 		POP		HL				; Restore code string address
01:930F C3EF92          	  1153: 		JP		COUNT			; Keep on counting
                        	  1154: 
01:9312 2A4810          	  1155: RSLNBK: LD		HL,(LINESN)		; Get LINES number
01:9315 224610          	  1156: 		LD		(LINESC),HL		; Reset LINES counter
01:9318 C3718C          	  1157: 		JP		BRKRET			; Go and output "Break"
                        	  1158: 
01:931B 3E64            	  1159: FOR:	LD		A,64H			; Flag "FOR" assignment
01:931D 32CB10          	  1160: 		LD		(FORFLG),A		; Save "FOR" flag
01:9320 CD8595          	  1161: 		CALL	LET				; Set up initial index
01:9323 C1              	  1162: 		POP		BC				; Drop RETurn address
01:9324 E5              	  1163: 		PUSH	HL				; Save code string address
01:9325 CD6E95          	  1164: 		CALL	DATAA			; Get next statement address
01:9328 22C710          	  1165: 		LD		(LOOPST),HL		; Save it for start of loop
01:932B 210200          	  1166: 		LD		HL,2			; Offset for "FOR" block
01:932E 39              	  1167: 		ADD		HL,SP			; Point to it
01:932F CD298F          	  1168: FORSLP: CALL	LOKFOR			; Look for existing "FOR" block
01:9332 D1              	  1169: 		POP		DE				; Get code string address
01:9333 C24B93          	  1170: 		JP		NZ,FORFND		; No nesting found
01:9336 09              	  1171: 		ADD		HL,BC			; Move into "FOR" block
01:9337 D5              	  1172: 		PUSH	DE				; Save code string address
01:9338 2B              	  1173: 		DEC		HL
01:9339 56              	  1174: 		LD		D,(HL)			; Get MSB of loop statement
01:933A 2B              	  1175: 		DEC		HL
01:933B 5E              	  1176: 		LD		E,(HL)			; Get LSB of loop statement
01:933C 23              	  1177: 		INC		HL
01:933D 23              	  1178: 		INC		HL
01:933E E5              	  1179: 		PUSH	HL				; Save block address
01:933F 2AC710          	  1180: 		LD		HL,(LOOPST)		; Get address of loop statement
01:9342 CD4492          	  1181: 		CALL	CPDEHL			; Compare the FOR loops
01:9345 E1              	  1182: 		POP		HL				; Restore block address
01:9346 C22F93          	  1183: 		JP		NZ,FORSLP		; Different FORs - Find another
01:9349 D1              	  1184: 		POP		DE				; Restore code string address
01:934A F9              	  1185: 		LD		SP,HL			; Remove all nested loops
                        	  1186: 
01:934B EB              	  1187: FORFND: EX		DE,HL			; Code string address to HL
01:934C 0E08            	  1188: 		LD		C,8
01:934E CD598F          	  1189: 		CALL	CHKSTK			; Check for 8 levels of stack
01:9351 E5              	  1190: 		PUSH	HL				; Save code string address
01:9352 2AC710          	  1191: 		LD		HL,(LOOPST)		; Get first statement of loop
01:9355 E3              	  1192: 		EX		(SP),HL			; Save and restore code string
01:9356 E5              	  1193: 		PUSH	HL				; Re-save code string address
01:9357 2A5C10          	  1194: 		LD		HL,(LINEAT)		; Get current line number
01:935A E3              	  1195: 		EX		(SP),HL			; Save and restore code string
01:935B CD4098          	  1196: 		CALL	TSTNUM			; Make sure it's a number
01:935E CD4A92          	  1197: 		CALL	CHKSYN			; Make sure "TO" is next
01:9361 A6              	  1198: 		db	ZTO			 ; "TO" token
01:9362 CD3D98          	  1199: 		CALL	GETNUM			; Get "TO" expression value
01:9365 E5              	  1200: 		PUSH	HL				; Save code string address
01:9366 CD6BA2          	  1201: 		CALL	BCDEFP			; Move "TO" value to BCDE
01:9369 E1              	  1202: 		POP		HL				; Restore code string address
01:936A C5              	  1203: 		PUSH	BC				; Save "TO" value in block
01:936B D5              	  1204: 		PUSH	DE
01:936C 010081          	  1205: 		LD		BC,8100H		; BCDE - 1 (default STEP)
01:936F 51              	  1206: 		LD		D,C				; C=0
01:9370 5A              	  1207: 		LD		E,D				; D=0
01:9371 7E              	  1208: 		LD		A,(HL)			; Get next byte in code string
01:9372 FEAB            	  1209: 		CP		ZSTEP			; See if "STEP" is stated
01:9374 3E01            	  1210: 		LD		A,1				; Sign of step = 1
01:9376 C28793          	  1211: 		JP		NZ,SAVSTP		; No STEP given - Default to 1
01:9379 CDD493          	  1212: 		CALL	GETCHR			; Jump over "STEP" token
01:937C CD3D98          	  1213: 		CALL	GETNUM			; Get step value
01:937F E5              	  1214: 		PUSH	HL				; Save code string address
01:9380 CD6BA2          	  1215: 		CALL	BCDEFP			; Move STEP to BCDE
01:9383 CD1FA2          	  1216: 		CALL	TSTSGN			; Test sign of FPREG
01:9386 E1              	  1217: 		POP		HL				; Restore code string address
01:9387 C5              	  1218: SAVSTP: PUSH	BC				; Save the STEP value in block
01:9388 D5              	  1219: 		PUSH	DE
01:9389 F5              	  1220: 		PUSH	AF				; Save sign of STEP
01:938A 33              	  1221: 		INC		SP				; Don't save flags
01:938B E5              	  1222: 		PUSH	HL				; Save code string address
01:938C 2ACE10          	  1223: 		LD		HL,(BRKLIN)		; Get address of index variable
01:938F E3              	  1224: 		EX		(SP),HL			; Save and restore code string
01:9390 0681            	  1225: PUTFID: LD		B,ZFOR			; "FOR" block marker
01:9392 C5              	  1226: 		PUSH	BC				; Save it
01:9393 33              	  1227: 		INC		SP				; Don't save C
                        	  1228: 
01:9394 CDFF93          	  1229: RUNCNT: CALL	TSTBRK			; Execution driver - Test break
01:9397 22CE10          	  1230: 		LD		(BRKLIN),HL		; Save code address for break
01:939A 7E              	  1231: 		LD		A,(HL)			; Get next byte in code string
01:939B FE3A            	  1232: 		CP		':'				; Multi statement line?
01:939D CAB493          	  1233: 		JP		Z,EXCUTE		; Yes - Execute it
01:93A0 B7              	  1234: 		OR		A				; End of line?
01:93A1 C27C8F          	  1235: 		JP		NZ,SNERR		; No - Syntax error
01:93A4 23              	  1236: 		INC		HL				; Point to address of next line
01:93A5 7E              	  1237: 		LD		A,(HL)			; Get LSB of line pointer
01:93A6 23              	  1238: 		INC		HL
01:93A7 B6              	  1239: 		OR		(HL)			; Is it zero (End of prog)?
01:93A8 CA2994          	  1240: 		JP		Z,ENDPRG		; Yes - Terminate execution
01:93AB 23              	  1241: 		INC		HL				; Point to line number
01:93AC 5E              	  1242: 		LD		E,(HL)			; Get LSB of line number
01:93AD 23              	  1243: 		INC		HL
01:93AE 56              	  1244: 		LD		D,(HL)			; Get MSB of line number
01:93AF EB              	  1245: 		EX		DE,HL			; Line number to HL
01:93B0 225C10          	  1246: 		LD		(LINEAT),HL		; Save as current line number
01:93B3 EB              	  1247: 		EX		DE,HL			; Line number back to DE
01:93B4 CDD493          	  1248: EXCUTE: CALL	GETCHR			; Get key word
01:93B7 119493          	  1249: 		LD		DE,RUNCNT		; Where to RETurn to
01:93BA D5              	  1250: 		PUSH	DE				; Save for RETurn
01:93BB C8              	  1251: IFJMP:	RET		Z				; Go to RUNCNT if end of STMT
01:93BC D680            	  1252: ONJMP:	SUB		ZEND			; Is it a token?
01:93BE DA8595          	  1253: 		JP		C,LET			; No - try to assign it
01:93C1 FE25            	  1254: 		CP		ZNEW+1-ZEND		; END to NEW ?
01:93C3 D27C8F          	  1255: 		JP		NC,SNERR		; Not a key word - ?SN Error
01:93C6 07              	  1256: 		RLCA					; Double it
01:93C7 4F              	  1257: 		LD		C,A				; BC = Offset into table
01:93C8 0600            	  1258: 		LD		B,0
01:93CA EB              	  1259: 		EX		DE,HL			; Save code string address
01:93CB 21228E          	  1260: 		LD		HL,WORDTB		; Keyword address table
01:93CE 09              	  1261: 		ADD		HL,BC			; Point to routine address
01:93CF 4E              	  1262: 		LD		C,(HL)			; Get LSB of routine address
01:93D0 23              	  1263: 		INC		HL
01:93D1 46              	  1264: 		LD		B,(HL)			; Get MSB of routine address
01:93D2 C5              	  1265: 		PUSH	BC				; Save routine address
01:93D3 EB              	  1266: 		EX		DE,HL			; Restore code string address
                        	  1267: 
01:93D4 23              	  1268: GETCHR: INC		HL				; Point to next character
01:93D5 7E              	  1269: 		LD		A,(HL)			; Get next code string byte
01:93D6 FE3A            	  1270: 		CP		':'				; Z if ':'
01:93D8 D0              	  1271: 		RET		NC				; NC if > "9"
01:93D9 FE20            	  1272: 		CP		' '
01:93DB CAD493          	  1273: 		JP		Z,GETCHR		; Skip over spaces
01:93DE FE30            	  1274: 		CP		'0'
01:93E0 3F              	  1275: 		CCF						; NC if < '0'
01:93E1 3C              	  1276: 		INC		A				; Test for zero - Leave carry
01:93E2 3D              	  1277: 		DEC		A				; Z if Null
01:93E3 C9              	  1278: 		RET
                        	  1279: 
01:93E4 EB              	  1280: RESTOR: EX		DE,HL			; Save code string address
01:93E5 2A5E10          	  1281: 		LD		HL,(BASTXT)		; Point to start of program
01:93E8 CAF993          	  1282: 		JP		Z,RESTNL		; Just RESTORE - reset pointer
01:93EB EB              	  1283: 		EX		DE,HL			; Restore code string address
01:93EC CDA394          	  1284: 		CALL	ATOH			; Get line number to DE
01:93EF E5              	  1285: 		PUSH	HL				; Save code string address
01:93F0 CD6890          	  1286: 		CALL	SRCHLN			; Search for line number in DE
01:93F3 60              	  1287: 		LD		H,B				; HL = Address of line
01:93F4 69              	  1288: 		LD		L,C
01:93F5 D1              	  1289: 		POP		DE				; Restore code string address
01:93F6 D24495          	  1290: 		JP		NC,ULERR		; ?UL Error if not found
01:93F9 2B              	  1291: RESTNL: DEC		HL				; Byte before DATA statement
01:93FA 22DC10          	  1292: UPDATA: LD		(NXTDAT),HL		; Update DATA pointer
01:93FD EB              	  1293: 		EX		DE,HL			; Restore code string address
01:93FE C9              	  1294: 		RET
                        	  1295: 
                        	  1296: 
                        	  1297: TSTBRK: 
01:93FF CDD280          	  1298: 	call	ReadCharNoWait			; Check for presence of character
01:9402 C8              	  1299: 	ret		z						; Return if nothing is in SIO buffer
                        	  1300: 	
                        	  1301: ;		call	CKINCHAR				; Check input status
                        	  1302: ;		RET		Z				; No key, go back
                        	  1303: ;		call	RXA				; Get the key into A
01:9403 FE1B            	  1304: 		CP		ESC				; Escape key?
01:9405 2813            	  1305: 		JR		Z,BRK			; Yes, break
01:9407 FE03            	  1306: 		CP		CTRLC			; <Ctrl-C>
01:9409 280F            	  1307: 		JR		Z,BRK			; Yes, break
01:940B FE13            	  1308: 		CP		CTRLS			; Stop scrolling?
01:940D C0              	  1309: 		RET		NZ				; Other key, ignore
                        	  1310: 
                        	  1311: 
01:940E CDC980          	  1312: STALL:	call	ReadChar				; Wait for key
01:9411 FE11            	  1313: 		CP		CTRLQ			; Resume scrolling?
01:9413 C8              	  1314: 		RET		 Z				; Release the chokehold
01:9414 FE03            	  1315: 		CP		CTRLC			; Second break?
01:9416 2807            	  1316: 		JR		Z,STOPP			; Break during hold exits prog
01:9418 18F4            	  1317: 		JR		STALL			; Loop until <Ctrl-Q> or <brk>
                        	  1318: 
01:941A 3EFF            	  1319: BRK		LD		A,$FF			; Set BRKFLG
01:941C 324D10          	  1320: 		LD		(BRKFLG),A		; Store it
                        	  1321: 
                        	  1322: 
01:941F C0              	  1323: STOPP:	RET		NZ				; Exit if anything else
01:9420 F6              	  1324: 		db	0F6H			; Flag "STOP"
01:9421 C0              	  1325: PEND:	RET		NZ				; Exit if anything else
01:9422 22CE10          	  1326: 		LD		(BRKLIN),HL		; Save point of break
01:9425 21              	  1327: 		db	21H				; Skip "OR 11111111B"
01:9426 F6FF            	  1328: INPBRK: OR		11111111B		; Flag "Break" wanted
01:9428 C1              	  1329: 		POP		BC				; Return not needed and more
01:9429 2A5C10          	  1330: ENDPRG: LD		HL,(LINEAT)		; Get current line number
01:942C F5              	  1331: 		PUSH	AF				; Save STOP / END status
01:942D 7D              	  1332: 		LD		A,L				; Is it direct break?
01:942E A4              	  1333: 		AND		H
01:942F 3C              	  1334: 		INC		A				; Line is -1 if direct break
01:9430 CA3C94          	  1335: 		JP		Z,NOLIN			; Yes - No line number
01:9433 22D210          	  1336: 		LD		(ERRLIN),HL		; Save line of break
01:9436 2ACE10          	  1337: 		LD		HL,(BRKLIN)		; Get point of break
01:9439 22D410          	  1338: 		LD		(CONTAD),HL		; Save point to CONTinue
01:943C AF              	  1339: NOLIN:	XOR		A
01:943D 324510          	  1340: 		LD		(CTLOFG),A		; Enable output
01:9440 CD7296          	  1341: 		CALL	STTLIN			; Start a new line
01:9443 F1              	  1342: 		POP		AF				; Restore STOP / END status
01:9444 211F8F          	  1343: 		LD		HL,BRKMSG		; "Break" message
01:9447 C2B08F          	  1344: 		JP		NZ,ERRIN		; "in line" wanted?
01:944A C3C78F          	  1345: 		JP		PRNTOK			; Go to command mode
                        	  1346: 
01:944D 2AD410          	  1347: CONT:	LD		HL,(CONTAD)		; Get CONTinue address
01:9450 7C              	  1348: 		LD		A,H				; Is it zero?
01:9451 B5              	  1349: 		OR		L
01:9452 1E20            	  1350: 		LD		E,CN			; ?CN Error
01:9454 CA908F          	  1351: 		JP		Z,ERROR			; Yes - output "?CN Error"
01:9457 EB              	  1352: 		EX		DE,HL			; Save code string address
01:9458 2AD210          	  1353: 		LD		HL,(ERRLIN)		; Get line of last break
01:945B 225C10          	  1354: 		LD		(LINEAT),HL		; Set up current line number
01:945E EB              	  1355: 		EX		DE,HL			; Restore code string address
01:945F C9              	  1356: 		RET						; CONTinue where left off
                        	  1357: 
01:9460 CD9E9F          	  1358: NULLL:	CALL	GETINT			; Get integer 0-255
01:9463 C0              	  1359: 		RET		NZ				; Return if bad value
01:9464 324110          	  1360: 		LD		(NULLS),A		; Set nulls number
01:9467 C9              	  1361: 		RET
                        	  1362: 
                        	  1363: 
01:9468 E5              	  1364: ACCSUM: PUSH	HL				; Save address in array
01:9469 2A4A10          	  1365: 		LD		HL,(CHKSUM)		; Get check sum
01:946C 0600            	  1366: 		LD		B,0				; BC - Value of byte
01:946E 4F              	  1367: 		LD		C,A
01:946F 09              	  1368: 		ADD		HL,BC			; Add byte to check sum
01:9470 224A10          	  1369: 		LD		(CHKSUM),HL		; Re-save check sum
01:9473 E1              	  1370: 		POP		HL				; Restore address in array
01:9474 C9              	  1371: 		RET
                        	  1372: 
01:9475 7E              	  1373: CHKLTR: LD		A,(HL)			; Get byte
01:9476 FE41            	  1374: 		CP		'A'				; < 'a' ?
01:9478 D8              	  1375: 		RET		C				; Carry set if not letter
01:9479 FE5B            	  1376: 		CP		'Z'+1			; > 'z' ?
01:947B 3F              	  1377: 		CCF
01:947C C9              	  1378: 		RET						; Carry set if not letter
                        	  1379: 
01:947D CDD493          	  1380: FPSINT: CALL	GETCHR			; Get next character
01:9480 CD3D98          	  1381: POSINT: CALL	GETNUM			; Get integer 0 to 32767
01:9483 CD1FA2          	  1382: DEPINT: CALL	TSTSGN			; Test sign of FPREG
01:9486 FA9E94          	  1383: 		JP		M,FCERR			; Negative - ?FC Error
01:9489 3AE710          	  1384: DEINT:	LD		A,(FPEXP)		; Get integer value to DE
01:948C FE90            	  1385: 		CP		80H+16			; Exponent in range (16 bits)?
01:948E DAC7A2          	  1386: 		JP		C,FPINT			; Yes - convert it
01:9491 018090          	  1387: 		LD		BC,9080H		; BCDE = -32768
01:9494 110000          	  1388: 		LD		DE,0000
01:9497 E5              	  1389: 		PUSH	HL				; Save code string address
01:9498 CD9AA2          	  1390: 		CALL	CMPNUM			; Compare FPREG with BCDE
01:949B E1              	  1391: 		POP		HL				; Restore code string address
01:949C 51              	  1392: 		LD		D,C				; MSB to D
01:949D C8              	  1393: 		RET		Z				; Return if in range
01:949E 1E08            	  1394: FCERR:	LD		E,FC			; ?FC Error
01:94A0 C3908F          	  1395: 		JP		ERROR			; Output error-
                        	  1396: 
01:94A3 2B              	  1397: ATOH:	DEC		HL				; ASCII number to DE binary
01:94A4 110000          	  1398: GETLN:	LD		DE,0			; Get number to DE
01:94A7 CDD493          	  1399: GTLNLP: CALL	GETCHR			; Get next character
01:94AA D0              	  1400: 		RET		NC				; Exit if not a digit
01:94AB E5              	  1401: 		PUSH	HL				; Save code string address
01:94AC F5              	  1402: 		PUSH	AF				; Save digit
01:94AD 219819          	  1403: 		LD		HL,65529/10		; Largest number 65529
01:94B0 CD4492          	  1404: 		CALL	CPDEHL			; Number in range?
01:94B3 DA7C8F          	  1405: 		JP		C,SNERR			; No - ?SN Error
01:94B6 62              	  1406: 		LD		H,D				; HL = Number
01:94B7 6B              	  1407: 		LD		L,E
01:94B8 19              	  1408: 		ADD		HL,DE			; Times 2
01:94B9 29              	  1409: 		ADD		HL,HL			; Times 4
01:94BA 19              	  1410: 		ADD		HL,DE			; Times 5
01:94BB 29              	  1411: 		ADD		HL,HL			; Times 10
01:94BC F1              	  1412: 		POP		AF				; Restore digit
01:94BD D630            	  1413: 		SUB		'0'				; Make it 0 to 9
01:94BF 5F              	  1414: 		LD		E,A				; DE = Value of digit
01:94C0 1600            	  1415: 		LD		D,0
01:94C2 19              	  1416: 		ADD		HL,DE			; Add to number
01:94C3 EB              	  1417: 		EX		DE,HL			; Number to DE
01:94C4 E1              	  1418: 		POP		HL				; Restore code string address
01:94C5 C3A794          	  1419: 		JP		GTLNLP			; Go to next character
                        	  1420: 
01:94C8 CA9890          	  1421: CLEAR:	JP		Z,INTVAR		; Just "CLEAR" Keep parameters
01:94CB CD8094          	  1422: 		CALL	POSINT			; Get integer 0 to 32767 to DE
01:94CE 2B              	  1423: 		DEC		HL				; Cancel increment
01:94CF CDD493          	  1424: 		CALL	GETCHR			; Get next character
01:94D2 E5              	  1425: 		PUSH	HL				; Save code string address
01:94D3 2AAF10          	  1426: 		LD		HL,(LSTRAM)		; Get end of RAM
01:94D6 CAEB94          	  1427: 		JP		Z,STORED		; No value given - Use stored
01:94D9 E1              	  1428: 		POP		HL				; Restore code string address
01:94DA CD4A92          	  1429: 		CALL	CHKSYN			; Check for comma
01:94DD 2C              	  1430: 		db	   ','
01:94DE D5              	  1431: 		PUSH	DE				; Save number
01:94DF CD8094          	  1432: 		CALL	POSINT			; Get integer 0 to 32767
01:94E2 2B              	  1433: 		DEC		HL				; Cancel increment
01:94E3 CDD493          	  1434: 		CALL	GETCHR			; Get next character
01:94E6 C27C8F          	  1435: 		JP		NZ,SNERR		; ?SN Error if more on line
01:94E9 E3              	  1436: 		EX		(SP),HL			; Save code string address
01:94EA EB              	  1437: 		EX		DE,HL			; Number to DE
01:94EB 7D              	  1438: STORED: LD		A,L				; Get LSB of new RAM top
01:94EC 93              	  1439: 		SUB		E				; Subtract LSB of string space
01:94ED 5F              	  1440: 		LD		E,A				; Save LSB
01:94EE 7C              	  1441: 		LD		A,H				; Get MSB of new RAM top
01:94EF 9A              	  1442: 		SBC		A,D				; Subtract MSB of string space
01:94F0 57              	  1443: 		LD		D,A				; Save MSB
01:94F1 DA718F          	  1444: 		JP		C,OMERR			; ?OM Error if not enough mem
01:94F4 E5              	  1445: 		PUSH	HL				; Save RAM top
01:94F5 2AD610          	  1446: 		LD		HL,(PROGND)		; Get program end
01:94F8 012800          	  1447: 		LD		BC,40			; 40 Bytes minimum working RAM
01:94FB 09              	  1448: 		ADD		HL,BC			; Get lowest address
01:94FC CD4492          	  1449: 		CALL	CPDEHL			; Enough memory?
01:94FF D2718F          	  1450: 		JP		NC,OMERR		; No - ?OM Error
01:9502 EB              	  1451: 		EX		DE,HL			; RAM top to HL
01:9503 225A10          	  1452: 		LD		(STRSPC),HL		; Set new string space
01:9506 E1              	  1453: 		POP		HL				; End of memory to use
01:9507 22AF10          	  1454: 		LD		(LSTRAM),HL		; Set new top of RAM
01:950A E1              	  1455: 		POP		HL				; Restore code string address
01:950B C39890          	  1456: 		JP		INTVAR			; Initialise variables
                        	  1457: 
01:950E CA9490          	  1458: RUN:	JP		Z,RUNFST		; RUN from start if just RUN
01:9511 CD9890          	  1459: 		CALL	INTVAR			; Initialise variables
01:9514 019493          	  1460: 		LD		BC,RUNCNT		; Execution driver loop
01:9517 C32A95          	  1461: 		JP		RUNLIN			; RUN from line number
                        	  1462: 
01:951A 0E03            	  1463: GOSUB:	LD		C,3				; 3 Levels of stack needed
01:951C CD598F          	  1464: 		CALL	CHKSTK			; Check for 3 levels of stack
01:951F C1              	  1465: 		POP		BC				; Get return address
01:9520 E5              	  1466: 		PUSH	HL				; Save code string for RETURN
01:9521 E5              	  1467: 		PUSH	HL				; And for GOSUB routine
01:9522 2A5C10          	  1468: 		LD		HL,(LINEAT)		; Get current line
01:9525 E3              	  1469: 		EX		(SP),HL			; Into stack - Code string out
01:9526 3E8C            	  1470: 		LD		A,ZGOSUB		; "GOSUB" token
01:9528 F5              	  1471: 		PUSH	AF				; Save token
01:9529 33              	  1472: 		INC		SP				; Don't save flags
                        	  1473: 
01:952A C5              	  1474: RUNLIN: PUSH	BC				; Save return address
01:952B CDA394          	  1475: GOTO:	CALL	ATOH			; ASCII number to DE binary
01:952E CD7095          	  1476: 		CALL	REM				; Get end of line
01:9531 E5              	  1477: 		PUSH	HL				; Save end of line
01:9532 2A5C10          	  1478: 		LD		HL,(LINEAT)		; Get current line
01:9535 CD4492          	  1479: 		CALL	CPDEHL			; Line after current?
01:9538 E1              	  1480: 		POP		HL				; Restore end of line
01:9539 23              	  1481: 		INC		HL				; Start of next line
01:953A DC6B90          	  1482: 		CALL	C,SRCHLP		; Line is after current line
01:953D D46890          	  1483: 		CALL	NC,SRCHLN		; Line is before current line
01:9540 60              	  1484: 		LD		H,B				; Set up code string address
01:9541 69              	  1485: 		LD		L,C
01:9542 2B              	  1486: 		DEC		HL				; Incremented after
01:9543 D8              	  1487: 		RET		C				; Line found
01:9544 1E0E            	  1488: ULERR:	LD		E,UL			; ?UL Error
01:9546 C3908F          	  1489: 		JP		ERROR			; Output error message
                        	  1490: 
01:9549 C0              	  1491: RETURN: RET		NZ				; Return if not just RETURN
01:954A 16FF            	  1492: 		LD		D,-1			; Flag "GOSUB" search
01:954C CD258F          	  1493: 		CALL	BAKSTK			; Look "GOSUB" block
01:954F F9              	  1494: 		LD		SP,HL			; Kill all FORs in subroutine
01:9550 FE8C            	  1495: 		CP		ZGOSUB			; Test for "GOSUB" token
01:9552 1E04            	  1496: 		LD		E,RG			; ?RG Error
01:9554 C2908F          	  1497: 		JP		NZ,ERROR		; Error if no "GOSUB" found
01:9557 E1              	  1498: 		POP		HL				; Get RETURN line number
01:9558 225C10          	  1499: 		LD		(LINEAT),HL		; Save as current
01:955B 23              	  1500: 		INC		HL				; Was it from direct statement?
01:955C 7C              	  1501: 		LD		A,H
01:955D B5              	  1502: 		OR		L				; Return to line
01:955E C26895          	  1503: 		JP		NZ,RETLIN		; No - Return to line
01:9561 3ACC10          	  1504: 		LD		A,(LSTBIN)		; Any INPUT in subroutine?
01:9564 B7              	  1505: 		OR		A				; If so buffer is corrupted
01:9565 C2C68F          	  1506: 		JP		NZ,POPNOK		; Yes - Go to command mode
01:9568 219493          	  1507: RETLIN: LD		HL,RUNCNT		; Execution driver loop
01:956B E3              	  1508: 		EX		(SP),HL			; Into stack - Code string out
01:956C 3E              	  1509: 		db	   3EH			   ; Skip "POP HL"
01:956D E1              	  1510: NXTDTA: POP		HL				; Restore code string address
                        	  1511: 
01:956E 01              	  1512: DATAA:	db	   01H,3AH		   ; ':' End of statement
01:956F 3A
01:9570 0E00            	  1513: REM:	LD		C,0				; 00  End of statement
01:9572 0600            	  1514: 		LD		B,0
01:9574 79              	  1515: NXTSTL: LD		A,C				; Statement and byte
01:9575 48              	  1516: 		LD		C,B
01:9576 47              	  1517: 		LD		B,A				; Statement end byte
01:9577 7E              	  1518: NXTSTT: LD		A,(HL)			; Get byte
01:9578 B7              	  1519: 		OR		A				; End of line?
01:9579 C8              	  1520: 		RET		Z				; Yes - Exit
01:957A B8              	  1521: 		CP		B				; End of statement?
01:957B C8              	  1522: 		RET		Z				; Yes - Exit
01:957C 23              	  1523: 		INC		HL				; Next byte
01:957D FE22            	  1524: 		CP		'"'				; Literal string?
01:957F CA7495          	  1525: 		JP		Z,NXTSTL		; Yes - Look for another '"'
01:9582 C37795          	  1526: 		JP		NXTSTT			; Keep looking
                        	  1527: 
01:9585 CD339A          	  1528: LET:	CALL	GETVAR			; Get variable name
01:9588 CD4A92          	  1529: 		CALL	CHKSYN			; Make sure "=" follows
01:958B B4              	  1530: 		db	   ZEQUAL		   ; "=" token
01:958C D5              	  1531: 		PUSH	DE				; Save address of variable
01:958D 3AAD10          	  1532: 		LD		A,(TYPE)		; Get data type
01:9590 F5              	  1533: 		PUSH	AF				; Save type
01:9591 CD4F98          	  1534: 		CALL	EVAL			; Evaluate expression
01:9594 F1              	  1535: 		POP		AF				; Restore type
01:9595 E3              	  1536: 		EX		(SP),HL			; Save code - Get var addr
01:9596 22CE10          	  1537: 		LD		(BRKLIN),HL		; Save address of variable
01:9599 1F              	  1538: 		RRA						; Adjust type
01:959A CD4298          	  1539: 		CALL	CHKTYP			; Check types are the same
01:959D CAD895          	  1540: 		JP		Z,LETNUM		; Numeric - Move value
01:95A0 E5              	  1541: LETSTR: PUSH	HL				; Save address of string var
01:95A1 2AE410          	  1542: 		LD		HL,(FPREG)		; Pointer to string entry
01:95A4 E5              	  1543: 		PUSH	HL				; Save it on stack
01:95A5 23              	  1544: 		INC		HL				; Skip over length
01:95A6 23              	  1545: 		INC		HL
01:95A7 5E              	  1546: 		LD		E,(HL)			; LSB of string address
01:95A8 23              	  1547: 		INC		HL
01:95A9 56              	  1548: 		LD		D,(HL)			; MSB of string address
01:95AA 2A5E10          	  1549: 		LD		HL,(BASTXT)		; Point to start of program
01:95AD CD4492          	  1550: 		CALL	CPDEHL			; Is string before program?
01:95B0 D2C795          	  1551: 		JP		NC,CRESTR		; Yes - Create string entry
01:95B3 2A5A10          	  1552: 		LD		HL,(STRSPC)		; Point to string space
01:95B6 CD4492          	  1553: 		CALL	CPDEHL			; Is string literal in program?
01:95B9 D1              	  1554: 		POP		DE				; Restore address of string
01:95BA D2CF95          	  1555: 		JP		NC,MVSTPT		; Yes - Set up pointer
01:95BD 21BF10          	  1556: 		LD		HL,TMPSTR		; Temporary string pool
01:95C0 CD4492          	  1557: 		CALL	CPDEHL			; Is string in temporary pool?
01:95C3 D2CF95          	  1558: 		JP		NC,MVSTPT		; No - Set up pointer
01:95C6 3E              	  1559: 		db	3EH				; Skip "POP DE"
01:95C7 D1              	  1560: CRESTR: POP		DE				; Restore address of string
01:95C8 CD779E          	  1561: 		CALL	BAKTMP			; Back to last tmp-str entry
01:95CB EB              	  1562: 		EX		DE,HL			; Address of string entry
01:95CC CDB09C          	  1563: 		CALL	SAVSTR			; Save string in string area
01:95CF CD779E          	  1564: MVSTPT: CALL	BAKTMP			; Back to last tmp-str entry
01:95D2 E1              	  1565: 		POP		HL				; Get string pointer
01:95D3 CD7AA2          	  1566: 		CALL	DETHL4			; Move string pointer to var
01:95D6 E1              	  1567: 		POP		HL				; Restore code string address
01:95D7 C9              	  1568: 		RET
                        	  1569: 
01:95D8 E5              	  1570: LETNUM: PUSH	HL				; Save address of variable
01:95D9 CD77A2          	  1571: 		CALL	FPTHL			; Move value to variable
01:95DC D1              	  1572: 		POP		DE				; Restore address of variable
01:95DD E1              	  1573: 		POP		HL				; Restore code string address
01:95DE C9              	  1574: 		RET
                        	  1575: 
01:95DF CD9E9F          	  1576: ON:		CALL	GETINT			; Get integer 0-255
01:95E2 7E              	  1577: 		LD		A,(HL)			; Get "GOTO" or "GOSUB" token
01:95E3 47              	  1578: 		LD		B,A				; Save in B
01:95E4 FE8C            	  1579: 		CP		ZGOSUB			; "GOSUB" token?
01:95E6 CAEE95          	  1580: 		JP		Z,ONGO			; Yes - Find line number
01:95E9 CD4A92          	  1581: 		CALL	CHKSYN			; Make sure it's "GOTO"
01:95EC 88              	  1582: 		db	ZGOTO			; "GOTO" token
01:95ED 2B              	  1583: 		DEC		HL				; Cancel increment
01:95EE 4B              	  1584: ONGO:	LD		C,E				; Integer of branch value
01:95EF 0D              	  1585: ONGOLP: DEC		C				; Count branches
01:95F0 78              	  1586: 		LD		A,B				; Get "GOTO" or "GOSUB" token
01:95F1 CABC93          	  1587: 		JP		Z,ONJMP			; Go to that line if right one
01:95F4 CDA494          	  1588: 		CALL	GETLN			; Get line number to DE
01:95F7 FE2C            	  1589: 		CP		','				; Another line number?
01:95F9 C0              	  1590: 		RET		NZ				; No - Drop through
01:95FA C3EF95          	  1591: 		JP		ONGOLP			; Yes - loop
                        	  1592: 
01:95FD CD4F98          	  1593: IFF:		CALL	EVAL			; Evaluate expression
01:9600 7E              	  1594: 		LD		A,(HL)			; Get token
01:9601 FE88            	  1595: 		CP		ZGOTO			; "GOTO" token?
01:9603 CA0B96          	  1596: 		JP		Z,IFGO			; Yes - Get line
01:9606 CD4A92          	  1597: 		CALL	CHKSYN			; Make sure it's "THEN"
01:9609 A9              	  1598: 		db	   ZTHEN		   ; "THEN" token
01:960A 2B              	  1599: 		DEC		HL				; Cancel increment
01:960B CD4098          	  1600: IFGO:	CALL	TSTNUM			; Make sure it's numeric
01:960E CD1FA2          	  1601: 		CALL	TSTSGN			; Test state of expression
01:9611 CA7095          	  1602: 		JP		Z,REM			; False - Drop through
01:9614 CDD493          	  1603: 		CALL	GETCHR			; Get next character
01:9617 DA2B95          	  1604: 		JP		C,GOTO			; Number - GOTO that line
01:961A C3BB93          	  1605: 		JP		IFJMP			; Otherwise do statement
                        	  1606: 
01:961D 2B              	  1607: MRPRNT: DEC		HL				; DEC 'cos GETCHR INCs
01:961E CDD493          	  1608: 		CALL	GETCHR			; Get next character
01:9621 CA8180          	  1609: PRINTT:	JP		Z,PrintCRLF		; CRLF if just PRINT
01:9624 C8              	  1610: PRNTLP: RET		Z				; End of list - Exit
01:9625 FEA5            	  1611: 		CP		ZTAB			; "TAB(" token?
01:9627 CAAB96          	  1612: 		JP		Z,DOTAB			; Yes - Do TAB routine
01:962A FEA8            	  1613: 		CP		ZSPC			; "SPC(" token?
01:962C CAAB96          	  1614: 		JP		Z,DOTAB			; Yes - Do SPC routine
01:962F E5              	  1615: 		PUSH	HL				; Save code string address
01:9630 FE2C            	  1616: 		CP		','				; Comma?
01:9632 CA9496          	  1617: 		JP		Z,DOCOM			; Yes - Move to next zone
01:9635 FE3B            	  1618: 		CP		59 ;";"			; Semi-colon?
01:9637 CACE96          	  1619: 		JP		Z,NEXITM		; Do semi-colon routine
01:963A C1              	  1620: 		POP		BC				; Code string address to BC
01:963B CD4F98          	  1621: 		CALL	EVAL			; Evaluate expression
01:963E E5              	  1622: 		PUSH	HL				; Save code string address
01:963F 3AAD10          	  1623: 		LD		A,(TYPE)		; Get variable type
01:9642 B7              	  1624: 		OR		A				; Is it a string variable?
01:9643 C26B96          	  1625: 		JP		NZ,PRNTST		; Yes - Output string contents
01:9646 CDC4A3          	  1626: 		CALL	NUMASC			; Convert number to text
01:9649 CDD49C          	  1627: 		CALL	CRTST			; Create temporary string
01:964C 3620            	  1628: 		LD		(HL),' '		; Followed by a space
01:964E 2AE410          	  1629: 		LD		HL,(FPREG)		; Get length of output
01:9651 34              	  1630: 		INC		(HL)			; Plus 1 for the space
01:9652 2AE410          	  1631: 		LD		HL,(FPREG)		; < Not needed >
01:9655 3A4210          	  1632: 		LD		A,(LWIDTH)		; Get width of line
01:9658 47              	  1633: 		LD		B,A				; To B
01:9659 04              	  1634: 		INC		B				; Width 255 (No limit)?
01:965A CA6796          	  1635: 		JP		Z,PRNTNB		; Yes - Output number string
01:965D 04              	  1636: 		INC		B				; Adjust it
01:965E 3AAB10          	  1637: 		LD		A,(CURPOS)		; Get cursor position
01:9661 86              	  1638: 		ADD		A,(HL)			; Add length of string
01:9662 3D              	  1639: 		DEC		A				; Adjust it
01:9663 B8              	  1640: 		CP		B				; Will output fit on this line?
01:9664 D48180          	  1641: 		CALL	NC,PrintCRLF		; No - CRLF first
01:9667 CD199D          	  1642: PRNTNB: CALL	PRS1			; Output string at (HL)
01:966A AF              	  1643: 		XOR		A				; Skip CALL by setting 'z' flag
01:966B C4199D          	  1644: PRNTST: CALL	NZ,PRS1			; Output string at (HL)
01:966E E1              	  1645: 		POP		HL				; Restore code string address
01:966F C31D96          	  1646: 		JP		MRPRNT			; See if more to PRINT
                        	  1647: 
01:9672 3AAB10          	  1648: STTLIN: LD		A,(CURPOS)		; Make sure on new line
01:9675 B7              	  1649: 		OR		A				; Already at start?
01:9676 C8              	  1650: 		RET		Z				; Yes - Do nothing
01:9677 C38180          	  1651: 		JP		PrintCRLF		; Start a new line
                        	  1652: 
01:967A 3600            	  1653: ENDINP: LD		(HL),0			; Mark end of buffer
01:967C 216010          	  1654: 		LD		HL,BUFFER-1		; Point to buffer
01:967F CD8180          	  1655: 		call	PrintCRLF
01:9682 AF              	  1656: DONULL: XOR		A				; Set to position 0
01:9683 32AB10          	  1657: 		LD		(CURPOS),A		; Store it
01:9686 3A4110          	  1658: 		LD		A,(NULLS)		; Get number of nulls
01:9689 3D              	  1659: NULLP:	DEC		A				; Count them
01:968A C8              	  1660: 		RET		Z				; Return if done
01:968B F5              	  1661: 		PUSH	AF				; Save count
01:968C AF              	  1662: 		XOR		A				; Load a null
01:968D CD5592          	  1663: 		CALL	OUTC			; Output it
01:9690 F1              	  1664: 		POP		AF				; Restore count
01:9691 C38996          	  1665: 		JP		NULLP			; Keep counting
                        	  1666: 
01:9694 3A4310          	  1667: DOCOM:	LD		A,(COMMAN)		; Get comma width
01:9697 47              	  1668: 		LD		B,A				; Save in B
01:9698 3AAB10          	  1669: 		LD		A,(CURPOS)		; Get current position
01:969B B8              	  1670: 		CP		B				; Within the limit?
01:969C D48180          	  1671: 		CALL	NC,PrintCRLF		; No - output CRLF
01:969F D2CE96          	  1672: 		JP		NC,NEXITM		; Get next item
01:96A2 D60E            	  1673: ZONELP: SUB		14				; Next zone of 14 characters
01:96A4 D2A296          	  1674: 		JP		NC,ZONELP		; Repeat if more zones
01:96A7 2F              	  1675: 		CPL						; Number of spaces to output
01:96A8 C3C396          	  1676: 		JP		ASPCS			; Output them
                        	  1677: 
01:96AB F5              	  1678: DOTAB:	PUSH	AF				; Save token
01:96AC CD9B9F          	  1679: 		CALL	FNDNUM			; Evaluate expression
01:96AF CD4A92          	  1680: 		CALL	CHKSYN			; Make sure ")" follows
01:96B2 29              	  1681: 		db	")"
01:96B3 2B              	  1682: 		DEC		HL				; Back space on to ")"
01:96B4 F1              	  1683: 		POP		AF				; Restore token
01:96B5 D6A8            	  1684: 		SUB		ZSPC			; Was it "SPC(" ?
01:96B7 E5              	  1685: 		PUSH	HL				; Save code string address
01:96B8 CABE96          	  1686: 		JP		Z,DOSPC			; Yes - Do 'E' spaces
01:96BB 3AAB10          	  1687: 		LD		A,(CURPOS)		; Get current position
01:96BE 2F              	  1688: DOSPC:	CPL						; Number of spaces to print to
01:96BF 83              	  1689: 		ADD		A,E				; Total number to print
01:96C0 D2CE96          	  1690: 		JP		NC,NEXITM		; TAB < Current POS(X)
01:96C3 3C              	  1691: ASPCS:	INC		A				; Output A spaces
01:96C4 47              	  1692: 		LD		B,A				; Save number to print
01:96C5 3E20            	  1693: 		LD		A,' '			; Space
01:96C7 CD5592          	  1694: SPCLP:	CALL	OUTC			; Output character in A
01:96CA 05              	  1695: 		DEC		B				; Count them
01:96CB C2C796          	  1696: 		JP		NZ,SPCLP		; Repeat if more
01:96CE E1              	  1697: NEXITM: POP		HL				; Restore code string address
01:96CF CDD493          	  1698: 		CALL	GETCHR			; Get next character
01:96D2 C32496          	  1699: 		JP		PRNTLP			; More to print
                        	  1700: 
01:96D5 3F5265646F206672	  1701: REDO:	db	"?Redo from start",CR,LF,0
01:96DD 6F6D207374617274
01:96E5 0D
01:96E6 0A
01:96E7 00
                        	  1702: 
01:96E8 3ACD10          	  1703: BADINP: LD		A,(READFG)		; READ or INPUT?
01:96EB B7              	  1704: 		OR		A
01:96EC C2768F          	  1705: 		JP		NZ,DATSNR		; READ - ?SN Error
01:96EF C1              	  1706: 		POP		BC				; Throw away code string addr
01:96F0 21D596          	  1707: 		LD		HL,REDO			; "Redo from start" message
01:96F3 CD169D          	  1708: 		CALL	PRS				; Output string
01:96F6 C3C790          	  1709: 		JP		DOAGN			; Do last INPUT again
                        	  1710: 
01:96F9 CD819C          	  1711: INPUT:	CALL	IDTEST			; Test for illegal direct
01:96FC 7E              	  1712: 		LD		A,(HL)			; Get character after "INPUT"
01:96FD FE22            	  1713: 		CP		'"'				; Is there a prompt string?
01:96FF 3E00            	  1714: 		LD		A,0				; Clear A and leave flags
01:9701 324510          	  1715: 		LD		(CTLOFG),A		; Enable output
01:9704 C21397          	  1716: 		JP		NZ,NOPMPT		; No prompt - get input
01:9707 CDD59C          	  1717: 		CALL	QTSTR			; Get string terminated by '"'
01:970A CD4A92          	  1718: 		CALL	CHKSYN			; Check for ';' after prompt
01:970D 3B              	  1719: 		db	';'
01:970E E5              	  1720: 		PUSH	HL				; Save code string address
01:970F CD199D          	  1721: 		CALL	PRS1			; Output prompt string
01:9712 3E              	  1722: 		db	3EH				; Skip "PUSH HL"
01:9713 E5              	  1723: NOPMPT: PUSH	HL				; Save code string address
01:9714 CDCB90          	  1724: 		CALL	PROMPT			; Get input with "? " prompt
01:9717 C1              	  1725: 		POP		BC				; Restore code string address
01:9718 DA2694          	  1726: 		JP		C,INPBRK		; Break pressed - Exit
01:971B 23              	  1727: 		INC		HL				; Next byte
01:971C 7E              	  1728: 		LD		A,(HL)			; Get it
01:971D B7              	  1729: 		OR		A				; End of line?
01:971E 2B              	  1730: 		DEC		HL				; Back again
01:971F C5              	  1731: 		PUSH	BC				; Re-save code string address
01:9720 CA6D95          	  1732: 		JP		Z,NXTDTA		; Yes - Find next DATA stmt
01:9723 362C            	  1733: 		LD		(HL),','		; Store comma as separator
01:9725 C32D97          	  1734: 		JP		NXTITM			; Get next item
                        	  1735: 
01:9728 E5              	  1736: READ:	PUSH	HL				; Save code string address
01:9729 2ADC10          	  1737: 		LD		HL,(NXTDAT)		; Next DATA statement
01:972C F6              	  1738: 		db	0F6H			; Flag "READ"
01:972D AF              	  1739: NXTITM: XOR		A				; Flag "INPUT"
01:972E 32CD10          	  1740: 		LD		(READFG),A		; Save "READ"/"INPUT" flag
01:9731 E3              	  1741: 		EX		(SP),HL			; Get code str' , Save pointer
01:9732 C33997          	  1742: 		JP		GTVLUS			; Get values
                        	  1743: 
01:9735 CD4A92          	  1744: NEDMOR: CALL	CHKSYN			; Check for comma between items
01:9738 2C              	  1745: 		db	   ','
01:9739 CD339A          	  1746: GTVLUS: CALL	GETVAR			; Get variable name
01:973C E3              	  1747: 		EX		(SP),HL			; Save code str" , Get pointer
01:973D D5              	  1748: 		PUSH	DE				; Save variable address
01:973E 7E              	  1749: 		LD		A,(HL)			; Get next "INPUT"/"DATA" byte
01:973F FE2C            	  1750: 		CP		','				; Comma?
01:9741 CA6197          	  1751: 		JP		Z,ANTVLU		; Yes - Get another value
01:9744 3ACD10          	  1752: 		LD		A,(READFG)		; Is it READ?
01:9747 B7              	  1753: 		OR		A
01:9748 C2CE97          	  1754: 		JP		NZ,FDTLP		; Yes - Find next DATA stmt
01:974B 3E3F            	  1755: 		LD		A,'?'			; More INPUT needed
01:974D CD5592          	  1756: 		CALL	OUTC			; Output character
01:9750 CDCB90          	  1757: 		CALL	PROMPT			; Get INPUT with prompt
01:9753 D1              	  1758: 		POP		DE				; Variable address
01:9754 C1              	  1759: 		POP		BC				; Code string address
01:9755 DA2694          	  1760: 		JP		C,INPBRK		; Break pressed
01:9758 23              	  1761: 		INC		HL				; Point to next DATA byte
01:9759 7E              	  1762: 		LD		A,(HL)			; Get byte
01:975A B7              	  1763: 		OR		A				; Is it zero (No input) ?
01:975B 2B              	  1764: 		DEC		HL				; Back space INPUT pointer
01:975C C5              	  1765: 		PUSH	BC				; Save code string address
01:975D CA6D95          	  1766: 		JP		Z,NXTDTA		; Find end of buffer
01:9760 D5              	  1767: 		PUSH	DE				; Save variable address
01:9761 3AAD10          	  1768: ANTVLU: LD		A,(TYPE)		; Check data type
01:9764 B7              	  1769: 		OR		A				; Is it numeric?
01:9765 CA8B97          	  1770: 		JP		Z,INPBIN		; Yes - Convert to binary
01:9768 CDD493          	  1771: 		CALL	GETCHR			; Get next character
01:976B 57              	  1772: 		LD		D,A				; Save input character
01:976C 47              	  1773: 		LD		B,A				; Again
01:976D FE22            	  1774: 		CP		'"'				; Start of literal sting?"
01:976F CA7F97          	  1775: 		JP		Z,STRENT		; Yes - Create string entry
01:9772 3ACD10          	  1776: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:9775 B7              	  1777: 		OR		A
01:9776 57              	  1778: 		LD		D,A				; Save 00 if "INPUT"
01:9777 CA7C97          	  1779: 		JP		Z,ITMSEP		; "INPUT" - End with 00
01:977A 163A            	  1780: 		LD		D,':'			; "DATA" - End with 00 or ':'
01:977C 062C            	  1781: ITMSEP: LD		B,','			; Item separator
01:977E 2B              	  1782: 		DEC		HL				; Back space for DTSTR
01:977F CDD89C          	  1783: STRENT: CALL	DTSTR			; Get string terminated by D
01:9782 EB              	  1784: 		EX		DE,HL			; String address to DE
01:9783 219697          	  1785: 		LD		HL,LTSTND		; Where to go after LETSTR
01:9786 E3              	  1786: 		EX		(SP),HL			; Save HL , get input pointer
01:9787 D5              	  1787: 		PUSH	DE				; Save address of string
01:9788 C3A095          	  1788: 		JP		LETSTR			; Assign string to variable
                        	  1789: 
01:978B CDD493          	  1790: INPBIN: CALL	GETCHR			; Get next character
01:978E CD26A3          	  1791: 		CALL	ASCTFP			; Convert ASCII to FP number
01:9791 E3              	  1792: 		EX		(SP),HL			; Save input ptr, Get var addr
01:9792 CD77A2          	  1793: 		CALL	FPTHL			; Move FPREG to variable
01:9795 E1              	  1794: 		POP		HL				; Restore input pointer
01:9796 2B              	  1795: LTSTND: DEC		HL				; DEC 'cos GETCHR INCs
01:9797 CDD493          	  1796: 		CALL	GETCHR			; Get next character
01:979A CAA297          	  1797: 		JP		Z,MORDT			; End of line - More needed?
01:979D FE2C            	  1798: 		CP		','				; Another value?
01:979F C2E896          	  1799: 		JP		NZ,BADINP		; No - Bad input
01:97A2 E3              	  1800: MORDT:	EX		(SP),HL			; Get code string address
01:97A3 2B              	  1801: 		DEC		HL				; DEC 'cos GETCHR INCs
01:97A4 CDD493          	  1802: 		CALL	GETCHR			; Get next character
01:97A7 C23597          	  1803: 		JP		NZ,NEDMOR		; More needed - Get it
01:97AA D1              	  1804: 		POP		DE				; Restore DATA pointer
01:97AB 3ACD10          	  1805: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:97AE B7              	  1806: 		OR		A
01:97AF EB              	  1807: 		EX		DE,HL			; DATA pointer to HL
01:97B0 C2FA93          	  1808: 		JP		NZ,UPDATA		; Update DATA pointer if "READ"
01:97B3 D5              	  1809: 		PUSH	DE				; Save code string address
01:97B4 B6              	  1810: 		OR		(HL)			; More input given?
01:97B5 21BD97          	  1811: 		LD		HL,EXTIG		; "?Extra ignored" message
01:97B8 C4169D          	  1812: 		CALL	NZ,PRS			; Output string if extra given
01:97BB E1              	  1813: 		POP		HL				; Restore code string address
01:97BC C9              	  1814: 		RET
                        	  1815: 
01:97BD 3F45787472612069	  1816: EXTIG:	db	"?Extra ignored",CR,LF,0
01:97C5 676E6F726564
01:97CB 0D
01:97CC 0A
01:97CD 00
                        	  1817: 
01:97CE CD6E95          	  1818: FDTLP:	CALL	DATAA			; Get next statement
01:97D1 B7              	  1819: 		OR		A				; End of line?
01:97D2 C2E797          	  1820: 		JP		NZ,FANDT		; No - See if DATA statement
01:97D5 23              	  1821: 		INC		HL
01:97D6 7E              	  1822: 		LD		A,(HL)			; End of program?
01:97D7 23              	  1823: 		INC		HL
01:97D8 B6              	  1824: 		OR		(HL)			; 00 00 Ends program
01:97D9 1E06            	  1825: 		LD		E,OD			; ?OD Error
01:97DB CA908F          	  1826: 		JP		Z,ERROR			; Yes - Out of DATA
01:97DE 23              	  1827: 		INC		HL
01:97DF 5E              	  1828: 		LD		E,(HL)			; LSB of line number
01:97E0 23              	  1829: 		INC		HL
01:97E1 56              	  1830: 		LD		D,(HL)			; MSB of line number
01:97E2 EB              	  1831: 		EX		DE,HL
01:97E3 22C910          	  1832: 		LD		(DATLIN),HL		; Set line of current DATA item
01:97E6 EB              	  1833: 		EX		DE,HL
01:97E7 CDD493          	  1834: FANDT:	CALL	GETCHR			; Get next character
01:97EA FE83            	  1835: 		CP		ZDATA			; "DATA" token
01:97EC C2CE97          	  1836: 		JP		NZ,FDTLP		; No "DATA" - Keep looking
01:97EF C36197          	  1837: 		JP		ANTVLU			; Found - Convert input
                        	  1838: 
01:97F2 110000          	  1839: NEXT:	LD		DE,0			; In case no index given
01:97F5 C4339A          	  1840: NEXT1:	CALL	NZ,GETVAR		; Get index address
01:97F8 22CE10          	  1841: 		LD		(BRKLIN),HL		; Save code string address
01:97FB CD258F          	  1842: 		CALL	BAKSTK			; Look for "FOR" block
01:97FE C2828F          	  1843: 		JP		NZ,NFERR		; No "FOR" - ?NF Error
01:9801 F9              	  1844: 		LD		SP,HL			; Clear nested loops
01:9802 D5              	  1845: 		PUSH	DE				; Save index address
01:9803 7E              	  1846: 		LD		A,(HL)			; Get sign of STEP
01:9804 23              	  1847: 		INC		HL
01:9805 F5              	  1848: 		PUSH	AF				; Save sign of STEP
01:9806 D5              	  1849: 		PUSH	DE				; Save index address
01:9807 CD5DA2          	  1850: 		CALL	PHLTFP			; Move index value to FPREG
01:980A E3              	  1851: 		EX		(SP),HL			; Save address of TO value
01:980B E5              	  1852: 		PUSH	HL				; Save address of index
01:980C CDCA9F          	  1853: 		CALL	ADDPHL			; Add STEP to index value
01:980F E1              	  1854: 		POP		HL				; Restore address of index
01:9810 CD77A2          	  1855: 		CALL	FPTHL			; Move value to index variable
01:9813 E1              	  1856: 		POP		HL				; Restore address of TO value
01:9814 CD6EA2          	  1857: 		CALL	LOADFP			; Move TO value to BCDE
01:9817 E5              	  1858: 		PUSH	HL				; Save address of line of FOR
01:9818 CD9AA2          	  1859: 		CALL	CMPNUM			; Compare index with TO value
01:981B E1              	  1860: 		POP		HL				; Restore address of line num
01:981C C1              	  1861: 		POP		BC				; Address of sign of STEP
01:981D 90              	  1862: 		SUB		B				; Compare with expected sign
01:981E CD6EA2          	  1863: 		CALL	LOADFP			; BC = Loop stmt,DE = Line num
01:9821 CA2D98          	  1864: 		JP		Z,KILFOR		; Loop finished - Terminate it
01:9824 EB              	  1865: 		EX		DE,HL			; Loop statement line number
01:9825 225C10          	  1866: 		LD		(LINEAT),HL		; Set loop line number
01:9828 69              	  1867: 		LD		L,C				; Set code string to loop
01:9829 60              	  1868: 		LD		H,B
01:982A C39093          	  1869: 		JP		PUTFID			; Put back "FOR" and continue
                        	  1870: 
01:982D F9              	  1871: KILFOR: LD		SP,HL			; Remove "FOR" block
01:982E 2ACE10          	  1872: 		LD		HL,(BRKLIN)		; Code string after "NEXT"
01:9831 7E              	  1873: 		LD		A,(HL)			; Get next byte in code string
01:9832 FE2C            	  1874: 		CP		','				; More NEXTs ?
01:9834 C29493          	  1875: 		JP		NZ,RUNCNT		; No - Do next statement
01:9837 CDD493          	  1876: 		CALL	GETCHR			; Position to index name
01:983A CDF597          	  1877: 		CALL	NEXT1			; Re-enter NEXT routine
                        	  1878: ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        	  1879: 
01:983D CD4F98          	  1880: GETNUM: CALL	EVAL			; Get a numeric expression
01:9840 F6              	  1881: TSTNUM: db	   0F6H			   ; Clear carry (numeric)
01:9841 37              	  1882: TSTSTR: SCF						; Set carry (string)
01:9842 3AAD10          	  1883: CHKTYP: LD		A,(TYPE)		; Check types match
01:9845 8F              	  1884: 		ADC		A,A				; Expected + actual
01:9846 B7              	  1885: 		OR		A				; Clear carry , set parity
01:9847 E8              	  1886: 		RET		PE				; Even parity - Types match
01:9848 C38E8F          	  1887: 		JP		TMERR			; Different types - Error
                        	  1888: 
01:984B CD4A92          	  1889: OPNPAR: CALL	CHKSYN			; Make sure "(" follows
01:984E 28              	  1890: 		db	"("
01:984F 2B              	  1891: EVAL:	DEC		HL				; Evaluate expression & save
01:9850 1600            	  1892: 		LD		D,0				; Precedence value
01:9852 D5              	  1893: EVAL1:	PUSH	DE				; Save precedence
01:9853 0E01            	  1894: 		LD		C,1
01:9855 CD598F          	  1895: 		CALL	CHKSTK			; Check for 1 level of stack
01:9858 CDC698          	  1896: 		CALL	OPRND			; Get next expression value
01:985B 22D010          	  1897: EVAL2:	LD		(NXTOPR),HL		; Save address of next operator
01:985E 2AD010          	  1898: EVAL3:	LD		HL,(NXTOPR)		; Restore address of next opr
01:9861 C1              	  1899: 		POP		BC				; Precedence value and operator
01:9862 78              	  1900: 		LD		A,B				; Get precedence value
01:9863 FE78            	  1901: 		CP		78H				; "AND" or "OR" ?
01:9865 D44098          	  1902: 		CALL	NC,TSTNUM		; No - Make sure it's a number
01:9868 7E              	  1903: 		LD		A,(HL)			; Get next operator / function
01:9869 1600            	  1904: 		LD		D,0				; Clear Last relation
01:986B D6B3            	  1905: RLTLP:	SUB		ZGTR			; ">" Token
01:986D DA8798          	  1906: 		JP		C,FOPRND		; + - * / ^ AND OR - Test it
01:9870 FE03            	  1907: 		CP		ZLTH+1-ZGTR		; < = >
01:9872 D28798          	  1908: 		JP		NC,FOPRND		; Function - Call it
01:9875 FE01            	  1909: 		CP		ZEQUAL-ZGTR		; "="
01:9877 17              	  1910: 		RLA						; <- Test for legal
01:9878 AA              	  1911: 		XOR		D				; <- combinations of < = >
01:9879 BA              	  1912: 		CP		D				; <- by combining last token
01:987A 57              	  1913: 		LD		D,A				; <- with current one
01:987B DA7C8F          	  1914: 		JP		C,SNERR			; Error if "<<' '==" or ">>"
01:987E 22C510          	  1915: 		LD		(CUROPR),HL		; Save address of current token
01:9881 CDD493          	  1916: 		CALL	GETCHR			; Get next character
01:9884 C36B98          	  1917: 		JP		RLTLP			; Treat the two as one
                        	  1918: 
01:9887 7A              	  1919: FOPRND: LD		A,D				; < = > found ?
01:9888 B7              	  1920: 		OR		A
01:9889 C2AE99          	  1921: 		JP		NZ,TSTRED		; Yes - Test for reduction
01:988C 7E              	  1922: 		LD		A,(HL)			; Get operator token
01:988D 22C510          	  1923: 		LD		(CUROPR),HL		; Save operator address
01:9890 D6AC            	  1924: 		SUB		ZPLUS			; Operator or function?
01:9892 D8              	  1925: 		RET		C				; Neither - Exit
01:9893 FE07            	  1926: 		CP		ZOR+1-ZPLUS		; Is it + - * / ^ AND OR ?
01:9895 D0              	  1927: 		RET		NC				; No - Exit
01:9896 5F              	  1928: 		LD		E,A				; Coded operator
01:9897 3AAD10          	  1929: 		LD		A,(TYPE)		; Get data type
01:989A 3D              	  1930: 		DEC		A				; FF = numeric , 00 = string
01:989B B3              	  1931: 		OR		E				; Combine with coded operator
01:989C 7B              	  1932: 		LD		A,E				; Get coded operator
01:989D CA0C9E          	  1933: 		JP		Z,CONCAT		; String concatenation
01:98A0 07              	  1934: 		RLCA					; Times 2
01:98A1 83              	  1935: 		ADD		A,E				; Times 3
01:98A2 5F              	  1936: 		LD		E,A				; To DE (D is 0)
01:98A3 216E8E          	  1937: 		LD		HL,PRITAB		; Precedence table
01:98A6 19              	  1938: 		ADD		HL,DE			; To the operator concerned
01:98A7 78              	  1939: 		LD		A,B				; Last operator precedence
01:98A8 56              	  1940: 		LD		D,(HL)			; Get evaluation precedence
01:98A9 BA              	  1941: 		CP		D				; Compare with eval precedence
01:98AA D0              	  1942: 		RET		NC				; Exit if higher precedence
01:98AB 23              	  1943: 		INC		HL				; Point to routine address
01:98AC CD4098          	  1944: 		CALL	TSTNUM			; Make sure it's a number
                        	  1945: 
01:98AF C5              	  1946: STKTHS: PUSH	BC				; Save last precedence & token
01:98B0 015E98          	  1947: 		LD		BC,EVAL3		; Where to go on prec' break
01:98B3 C5              	  1948: 		PUSH	BC				; Save on stack for return
01:98B4 43              	  1949: 		LD		B,E				; Save operator
01:98B5 4A              	  1950: 		LD		C,D				; Save precedence
01:98B6 CD50A2          	  1951: 		CALL	STAKFP			; Move value to stack
01:98B9 58              	  1952: 		LD		E,B				; Restore operator
01:98BA 51              	  1953: 		LD		D,C				; Restore precedence
01:98BB 4E              	  1954: 		LD		C,(HL)			; Get LSB of routine address
01:98BC 23              	  1955: 		INC		HL
01:98BD 46              	  1956: 		LD		B,(HL)			; Get MSB of routine address
01:98BE 23              	  1957: 		INC		HL
01:98BF C5              	  1958: 		PUSH	BC				; Save routine address
01:98C0 2AC510          	  1959: 		LD		HL,(CUROPR)		; Address of current operator
01:98C3 C35298          	  1960: 		JP		EVAL1			; Loop until prec' break
                        	  1961: 
01:98C6 AF              	  1962: OPRND:	XOR		A				; Get operand routine
01:98C7 32AD10          	  1963: 		LD		(TYPE),A		; Set numeric expected
01:98CA CDD493          	  1964: 		CALL	GETCHR			; Get next character
01:98CD 1E24            	  1965: 		LD		E,MO			; ?MO Error
01:98CF CA908F          	  1966: 		JP		Z,ERROR			; No operand - Error
01:98D2 DA26A3          	  1967: 		JP		C,ASCTFP		; Number - Get value
01:98D5 CD7594          	  1968: 		CALL	CHKLTR			; See if a letter
01:98D8 D22D99          	  1969: 		JP		NC,CONVAR		; Letter - Find variable
01:98DB FE26            	  1970: 		CP		'&'				; &H = HEX, &B = BINARY
01:98DD 2012            	  1971: 		JR		NZ, NOTAMP
01:98DF CDD493          	  1972: 		CALL	GETCHR			; Get next character
01:98E2 FE48            	  1973: 		CP		'H'				; Hex number indicated? [function added]
01:98E4 CA6EA7          	  1974: 		JP		Z,HEXTFP		; Convert Hex to FPREG
01:98E7 FE42            	  1975: 		CP		'B'				; Binary number indicated? [function added]
01:98E9 CADEA7          	  1976: 		JP		Z,BINTFP		; Convert Bin to FPREG
01:98EC 1E02            	  1977: 		LD		E,SN			; If neither then a ?SN Error
01:98EE CA908F          	  1978: 		JP		Z,ERROR			; 
01:98F1 FEAC            	  1979: NOTAMP: CP		ZPLUS			; '+' Token ?
01:98F3 CAC698          	  1980: 		JP		Z,OPRND			; Yes - Look for operand
01:98F6 FE2E            	  1981: 		CP		'.'				; '.' ?
01:98F8 CA26A3          	  1982: 		JP		Z,ASCTFP		; Yes - Create FP number
01:98FB FEAD            	  1983: 		CP		ZMINUS			; '-' Token ?
01:98FD CA1C99          	  1984: 		JP		Z,MINUS			; Yes - Do minus
01:9900 FE22            	  1985: 		CP		'"'				; Literal string ?
01:9902 CAD59C          	  1986: 		JP		Z,QTSTR			; Get string terminated by '"'
01:9905 FEAA            	  1987: 		CP		ZNOT			; "NOT" Token ?
01:9907 CA0E9A          	  1988: 		JP		Z,EVNOT			; Yes - Eval NOT expression
01:990A FEA7            	  1989: 		CP		ZFN				; "FN" Token ?
01:990C CA399C          	  1990: 		JP		Z,DOFN			; Yes - Do FN routine
01:990F D6B6            	  1991: 		SUB		ZSGN			; Is it a function?
01:9911 D23E99          	  1992: 		JP		NC,FNOFST		; Yes - Evaluate function
01:9914 CD4B98          	  1993: EVLPAR: CALL	OPNPAR			; Evaluate expression in "()"
01:9917 CD4A92          	  1994: 		CALL	CHKSYN			; Make sure ")" follows
01:991A 29              	  1995: 		db	")"
01:991B C9              	  1996: 		RET
                        	  1997: 
01:991C 167D            	  1998: MINUS:	LD		D,7DH			; '-' precedence
01:991E CD5298          	  1999: 		CALL	EVAL1			; Evaluate until prec' break
01:9921 2AD010          	  2000: 		LD		HL,(NXTOPR)		; Get next operator address
01:9924 E5              	  2001: 		PUSH	HL				; Save next operator address
01:9925 CD48A2          	  2002: 		CALL	INVSGN			; Negate value
01:9928 CD4098          	  2003: RETNUM: CALL	TSTNUM			; Make sure it's a number
01:992B E1              	  2004: 		POP		HL				; Restore next operator address
01:992C C9              	  2005: 		RET
                        	  2006: 
01:992D CD339A          	  2007: CONVAR: CALL	GETVAR			; Get variable address to DE
01:9930 E5              	  2008: FRMEVL: PUSH	HL				; Save code string address
01:9931 EB              	  2009: 		EX		DE,HL			; Variable address to HL
01:9932 22E410          	  2010: 		LD		(FPREG),HL		; Save address of variable
01:9935 3AAD10          	  2011: 		LD		A,(TYPE)		; Get type
01:9938 B7              	  2012: 		OR		A				; Numeric?
01:9939 CC5DA2          	  2013: 		CALL	Z,PHLTFP		; Yes - Move contents to FPREG
01:993C E1              	  2014: 		POP		HL				; Restore code string address
01:993D C9              	  2015: 		RET
                        	  2016: 
01:993E 0600            	  2017: FNOFST: LD		B,0				; Get address of function
01:9940 07              	  2018: 		RLCA					; Double function offset
01:9941 4F              	  2019: 		LD		C,A				; BC = Offset in function table
01:9942 C5              	  2020: 		PUSH	BC				; Save adjusted token value
01:9943 CDD493          	  2021: 		CALL	GETCHR			; Get next character
01:9946 79              	  2022: 		LD		A,C				; Get adjusted token value
01:9947 FE31            	  2023: 		CP		2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
01:9949 DA6599          	  2024: 		JP		C,FNVAL			; No - Do function
01:994C CD4B98          	  2025: 		CALL	OPNPAR			; Evaluate expression  (X,...
01:994F CD4A92          	  2026: 		CALL	CHKSYN			; Make sure ',' follows
01:9952 2C              	  2027: 		db	   ','
01:9953 CD4198          	  2028: 		CALL	TSTSTR			; Make sure it's a string
01:9956 EB              	  2029: 		EX		DE,HL			; Save code string address
01:9957 2AE410          	  2030: 		LD		HL,(FPREG)		; Get address of string
01:995A E3              	  2031: 		EX		(SP),HL			; Save address of string
01:995B E5              	  2032: 		PUSH	HL				; Save adjusted token value
01:995C EB              	  2033: 		EX		DE,HL			; Restore code string address
01:995D CD9E9F          	  2034: 		CALL	GETINT			; Get integer 0-255
01:9960 EB              	  2035: 		EX		DE,HL			; Save code string address
01:9961 E3              	  2036: 		EX		(SP),HL			; Save integer,HL = adj' token
01:9962 C36D99          	  2037: 		JP		GOFUNC			; Jump to string function
                        	  2038: 
01:9965 CD1499          	  2039: FNVAL:	CALL	EVLPAR			; Evaluate expression
01:9968 E3              	  2040: 		EX		(SP),HL			; HL = Adjusted token value
01:9969 112899          	  2041: 		LD		DE,RETNUM		; Return number from function
01:996C D5              	  2042: 		PUSH	DE				; Save on stack
01:996D 01C78C          	  2043: GOFUNC: LD		BC,FNCTAB		; Function routine addresses
01:9970 09              	  2044: 		ADD		HL,BC			; Point to right address
01:9971 4E              	  2045: 		LD		C,(HL)			; Get LSB of address
01:9972 23              	  2046: 		INC		HL				;
01:9973 66              	  2047: 		LD		H,(HL)			; Get MSB of address
01:9974 69              	  2048: 		LD		L,C				; Address to HL
01:9975 E9              	  2049: 		JP		(HL)			; Jump to function
                        	  2050: 
01:9976 15              	  2051: SGNEXP: DEC		D				; Dee to flag negative exponent
01:9977 FEAD            	  2052: 		CP		ZMINUS			; '-' token ?
01:9979 C8              	  2053: 		RET		Z				; Yes - Return
01:997A FE2D            	  2054: 		CP		'-'				; '-' ASCII ?
01:997C C8              	  2055: 		RET		Z				; Yes - Return
01:997D 14              	  2056: 		INC		D				; Inc to flag positive exponent
01:997E FE2B            	  2057: 		CP		'+'				; '+' ASCII ?
01:9980 C8              	  2058: 		RET		Z				; Yes - Return
01:9981 FEAC            	  2059: 		CP		ZPLUS			; '+' token ?
01:9983 C8              	  2060: 		RET		Z				; Yes - Return
01:9984 2B              	  2061: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9985 C9              	  2062: 		RET						; Return "NZ"
                        	  2063: 
01:9986 F6              	  2064: POR:	db	   0F6H			   ; Flag "OR"
01:9987 AF              	  2065: PAND:	XOR		A				; Flag "AND"
01:9988 F5              	  2066: 		PUSH	AF				; Save "AND" / "OR" flag
01:9989 CD4098          	  2067: 		CALL	TSTNUM			; Make sure it's a number
01:998C CD8994          	  2068: 		CALL	DEINT			; Get integer -32768 to 32767
01:998F F1              	  2069: 		POP		AF				; Restore "AND" / "OR" flag
01:9990 EB              	  2070: 		EX		DE,HL			; <- Get last
01:9991 C1              	  2071: 		POP		BC				; <-  value
01:9992 E3              	  2072: 		EX		(SP),HL			; <-  from
01:9993 EB              	  2073: 		EX		DE,HL			; <-  stack
01:9994 CD60A2          	  2074: 		CALL	FPBCDE			; Move last value to FPREG
01:9997 F5              	  2075: 		PUSH	AF				; Save "AND" / "OR" flag
01:9998 CD8994          	  2076: 		CALL	DEINT			; Get integer -32768 to 32767
01:999B F1              	  2077: 		POP		AF				; Restore "AND" / "OR" flag
01:999C C1              	  2078: 		POP		BC				; Get value
01:999D 79              	  2079: 		LD		A,C				; Get LSB
01:999E 21F79B          	  2080: 		LD		HL,ACPASS		; Address of save AC as current
01:99A1 C2A999          	  2081: 		JP		NZ,POR1			; Jump if OR
01:99A4 A3              	  2082: 		AND		E				; "AND" LSBs
01:99A5 4F              	  2083: 		LD		C,A				; Save LSB
01:99A6 78              	  2084: 		LD		A,B				; Get MBS
01:99A7 A2              	  2085: 		AND		D				; "AND" MSBs
01:99A8 E9              	  2086: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2087: 
01:99A9 B3              	  2088: POR1:	OR		E				; "OR" LSBs
01:99AA 4F              	  2089: 		LD		C,A				; Save LSB
01:99AB 78              	  2090: 		LD		A,B				; Get MSB
01:99AC B2              	  2091: 		OR		D				; "OR" MSBs
01:99AD E9              	  2092: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2093: 
01:99AE 21C099          	  2094: TSTRED: LD		HL,CMPLOG		; Logical compare routine
01:99B1 3AAD10          	  2095: 		LD		A,(TYPE)		; Get data type
01:99B4 1F              	  2096: 		RRA						; Carry set = string
01:99B5 7A              	  2097: 		LD		A,D				; Get last precedence value
01:99B6 17              	  2098: 		RLA						; Times 2 plus carry
01:99B7 5F              	  2099: 		LD		E,A				; To E
01:99B8 1664            	  2100: 		LD		D,64H			; Relational precedence
01:99BA 78              	  2101: 		LD		A,B				; Get current precedence
01:99BB BA              	  2102: 		CP		D				; Compare with last
01:99BC D0              	  2103: 		RET		NC				; Eval if last was rel' or log'
01:99BD C3AF98          	  2104: 		JP		STKTHS			; Stack this one and get next
                        	  2105: 
01:99C0 C299            	  2106: CMPLOG: dw	CMPLG1			; Compare two values / strings
01:99C2 79              	  2107: CMPLG1: LD		A,C				; Get data type
01:99C3 B7              	  2108: 		OR		A
01:99C4 1F              	  2109: 		RRA
01:99C5 C1              	  2110: 		POP		BC				; Get last expression to BCDE
01:99C6 D1              	  2111: 		POP		DE
01:99C7 F5              	  2112: 		PUSH	AF				; Save status
01:99C8 CD4298          	  2113: 		CALL	CHKTYP			; Check that types match
01:99CB 21049A          	  2114: 		LD		HL,CMPRES		; Result to comparison
01:99CE E5              	  2115: 		PUSH	HL				; Save for RETurn
01:99CF CA9AA2          	  2116: 		JP		Z,CMPNUM		; Compare values if numeric
01:99D2 AF              	  2117: 		XOR		A				; Compare two strings
01:99D3 32AD10          	  2118: 		LD		(TYPE),A		; Set type to numeric
01:99D6 D5              	  2119: 		PUSH	DE				; Save string name
01:99D7 CD599E          	  2120: 		CALL	GSTRCU			; Get current string
01:99DA 7E              	  2121: 		LD		A,(HL)			; Get length of string
01:99DB 23              	  2122: 		INC		HL
01:99DC 23              	  2123: 		INC		HL
01:99DD 4E              	  2124: 		LD		C,(HL)			; Get LSB of address
01:99DE 23              	  2125: 		INC		HL
01:99DF 46              	  2126: 		LD		B,(HL)			; Get MSB of address
01:99E0 D1              	  2127: 		POP		DE				; Restore string name
01:99E1 C5              	  2128: 		PUSH	BC				; Save address of string
01:99E2 F5              	  2129: 		PUSH	AF				; Save length of string
01:99E3 CD5D9E          	  2130: 		CALL	GSTRDE			; Get second string
01:99E6 CD6EA2          	  2131: 		CALL	LOADFP			; Get address of second string
01:99E9 F1              	  2132: 		POP		AF				; Restore length of string 1
01:99EA 57              	  2133: 		LD		D,A				; Length to D
01:99EB E1              	  2134: 		POP		HL				; Restore address of string 1
01:99EC 7B              	  2135: CMPSTR: LD		A,E				; Bytes of string 2 to do
01:99ED B2              	  2136: 		OR		D				; Bytes of string 1 to do
01:99EE C8              	  2137: 		RET		Z				; Exit if all bytes compared
01:99EF 7A              	  2138: 		LD		A,D				; Get bytes of string 1 to do
01:99F0 D601            	  2139: 		SUB		1
01:99F2 D8              	  2140: 		RET		C				; Exit if end of string 1
01:99F3 AF              	  2141: 		XOR		A
01:99F4 BB              	  2142: 		CP		E				; Bytes of string 2 to do
01:99F5 3C              	  2143: 		INC		A
01:99F6 D0              	  2144: 		RET		NC				; Exit if end of string 2
01:99F7 15              	  2145: 		DEC		D				; Count bytes in string 1
01:99F8 1D              	  2146: 		DEC		E				; Count bytes in string 2
01:99F9 0A              	  2147: 		LD		A,(BC)			; Byte in string 2
01:99FA BE              	  2148: 		CP		(HL)			; Compare to byte in string 1
01:99FB 23              	  2149: 		INC		HL				; Move up string 1
01:99FC 03              	  2150: 		INC		BC				; Move up string 2
01:99FD CAEC99          	  2151: 		JP		Z,CMPSTR		; Same - Try next bytes
01:9A00 3F              	  2152: 		CCF						; Flag difference (">" or "<")
01:9A01 C32AA2          	  2153: 		JP		FLGDIF			; "<" gives -1 , ">" gives +1
                        	  2154: 
01:9A04 3C              	  2155: CMPRES: INC		A				; Increment current value
01:9A05 8F              	  2156: 		ADC		A,A				; Double plus carry
01:9A06 C1              	  2157: 		POP		BC				; Get other value
01:9A07 A0              	  2158: 		AND		B				; Combine them
01:9A08 C6FF            	  2159: 		ADD		A,-1			; Carry set if different
01:9A0A 9F              	  2160: 		SBC		A,A				; 00 - Equal , FF - Different
01:9A0B C331A2          	  2161: 		JP		FLGREL			; Set current value & continue
                        	  2162: 
01:9A0E 165A            	  2163: EVNOT:	LD		D,5AH			; Precedence value for "NOT"
01:9A10 CD5298          	  2164: 		CALL	EVAL1			; Eval until precedence break
01:9A13 CD4098          	  2165: 		CALL	TSTNUM			; Make sure it's a number
01:9A16 CD8994          	  2166: 		CALL	DEINT			; Get integer -32768 - 32767
01:9A19 7B              	  2167: 		LD		A,E				; Get LSB
01:9A1A 2F              	  2168: 		CPL						; Invert LSB
01:9A1B 4F              	  2169: 		LD		C,A				; Save "NOT" of LSB
01:9A1C 7A              	  2170: 		LD		A,D				; Get MSB
01:9A1D 2F              	  2171: 		CPL						; Invert MSB
01:9A1E CDF79B          	  2172: 		CALL	ACPASS			; Save AC as current
01:9A21 C1              	  2173: 		POP		BC				; Clean up stack
01:9A22 C35E98          	  2174: 		JP		EVAL3			; Continue evaluation
                        	  2175: 
01:9A25 2B              	  2176: DIMRET: DEC		HL				; DEC 'cos GETCHR INCs
01:9A26 CDD493          	  2177: 		CALL	GETCHR			; Get next character
01:9A29 C8              	  2178: 		RET		Z				; End of DIM statement
01:9A2A CD4A92          	  2179: 		CALL	CHKSYN			; Make sure ',' follows
01:9A2D 2C              	  2180: 		db	   ','
01:9A2E 01259A          	  2181: DIM:	LD		BC,DIMRET		; Return to "DIMRET"
01:9A31 C5              	  2182: 		PUSH	BC				; Save on stack
01:9A32 F6              	  2183: 		db	   0F6H			   ; Flag "Create" variable
01:9A33 AF              	  2184: GETVAR: XOR		A				; Find variable address,to DE
01:9A34 32AC10          	  2185: 		LD		(LCRFLG),A		; Set locate / create flag
01:9A37 46              	  2186: 		LD		B,(HL)			; Get First byte of name
01:9A38 CD7594          	  2187: GTFNAM: CALL	CHKLTR			; See if a letter
01:9A3B DA7C8F          	  2188: 		JP		C,SNERR			; ?SN Error if not a letter
01:9A3E AF              	  2189: 		XOR		A
01:9A3F 4F              	  2190: 		LD		C,A				; Clear second byte of name
01:9A40 32AD10          	  2191: 		LD		(TYPE),A		; Set type to numeric
01:9A43 CDD493          	  2192: 		CALL	GETCHR			; Get next character
01:9A46 DA4F9A          	  2193: 		JP		C,SVNAM2		; Numeric - Save in name
01:9A49 CD7594          	  2194: 		CALL	CHKLTR			; See if a letter
01:9A4C DA5C9A          	  2195: 		JP		C,CHARTY		; Not a letter - Check type
01:9A4F 4F              	  2196: SVNAM2: LD		C,A				; Save second byte of name
01:9A50 CDD493          	  2197: ENDNAM: CALL	GETCHR			; Get next character
01:9A53 DA509A          	  2198: 		JP		C,ENDNAM		; Numeric - Get another
01:9A56 CD7594          	  2199: 		CALL	CHKLTR			; See if a letter
01:9A59 D2509A          	  2200: 		JP		NC,ENDNAM		; Letter - Get another
01:9A5C D624            	  2201: CHARTY: SUB		'$'				; String variable?
01:9A5E C26B9A          	  2202: 		JP		NZ,NOTSTR		; No - Numeric variable
01:9A61 3C              	  2203: 		INC		A				; A = 1 (string type)
01:9A62 32AD10          	  2204: 		LD		(TYPE),A		; Set type to string
01:9A65 0F              	  2205: 		RRCA					; A = 80H , Flag for string
01:9A66 81              	  2206: 		ADD		A,C				; 2nd byte of name has bit 7 on
01:9A67 4F              	  2207: 		LD		C,A				; Resave second byte on name
01:9A68 CDD493          	  2208: 		CALL	GETCHR			; Get next character
01:9A6B 3ACB10          	  2209: NOTSTR: LD		A,(FORFLG)		; Array name needed ?
01:9A6E 3D              	  2210: 		DEC		A
01:9A6F CA189B          	  2211: 		JP		Z,ARLDSV		; Yes - Get array name
01:9A72 F27B9A          	  2212: 		JP		P,NSCFOR		; No array with "FOR" or "FN"
01:9A75 7E              	  2213: 		LD		A,(HL)			; Get byte again
01:9A76 D628            	  2214: 		SUB		'('				; Subscripted variable?
01:9A78 CAF09A          	  2215: 		JP		Z,SBSCPT		; Yes - Sort out subscript
                        	  2216: 
01:9A7B AF              	  2217: NSCFOR: XOR		A				; Simple variable
01:9A7C 32CB10          	  2218: 		LD		(FORFLG),A		; Clear "FOR" flag
01:9A7F E5              	  2219: 		PUSH	HL				; Save code string address
01:9A80 50              	  2220: 		LD		D,B				; DE = Variable name to find
01:9A81 59              	  2221: 		LD		E,C
01:9A82 2ADE10          	  2222: 		LD		HL,(FNRGNM)		; FN argument name
01:9A85 CD4492          	  2223: 		CALL	CPDEHL			; Is it the FN argument?
01:9A88 11E010          	  2224: 		LD		DE,FNARG		; Point to argument value
01:9A8B CA60A1          	  2225: 		JP		Z,POPHRT		; Yes - Return FN argument value
01:9A8E 2AD810          	  2226: 		LD		HL,(VAREND)		; End of variables
01:9A91 EB              	  2227: 		EX		DE,HL			; Address of end of search
01:9A92 2AD610          	  2228: 		LD		HL,(PROGND)		; Start of variables address
01:9A95 CD4492          	  2229: FNDVAR: CALL	CPDEHL			; End of variable list table?
01:9A98 CAAE9A          	  2230: 		JP		Z,CFEVAL		; Yes - Called from EVAL?
01:9A9B 79              	  2231: 		LD		A,C				; Get second byte of name
01:9A9C 96              	  2232: 		SUB		(HL)			; Compare with name in list
01:9A9D 23              	  2233: 		INC		HL				; Move on to first byte
01:9A9E C2A39A          	  2234: 		JP		NZ,FNTHR		; Different - Find another
01:9AA1 78              	  2235: 		LD		A,B				; Get first byte of name
01:9AA2 96              	  2236: 		SUB		(HL)			; Compare with name in list
01:9AA3 23              	  2237: FNTHR:	INC		HL				; Move on to LSB of value
01:9AA4 CAE29A          	  2238: 		JP		Z,RETADR		; Found - Return address
01:9AA7 23              	  2239: 		INC		HL				; <- Skip
01:9AA8 23              	  2240: 		INC		HL				; <- over
01:9AA9 23              	  2241: 		INC		HL				; <- F.P.
01:9AAA 23              	  2242: 		INC		HL				; <- value
01:9AAB C3959A          	  2243: 		JP		FNDVAR			; Keep looking
                        	  2244: 
01:9AAE E1              	  2245: CFEVAL: POP		HL				; Restore code string address
01:9AAF E3              	  2246: 		EX		(SP),HL			; Get return address
01:9AB0 D5              	  2247: 		PUSH	DE				; Save address of variable
01:9AB1 113099          	  2248: 		LD		DE,FRMEVL		; Return address in EVAL
01:9AB4 CD4492          	  2249: 		CALL	CPDEHL			; Called from EVAL ?
01:9AB7 D1              	  2250: 		POP		DE				; Restore address of variable
01:9AB8 CAE59A          	  2251: 		JP		Z,RETNUL		; Yes - Return null variable
01:9ABB E3              	  2252: 		EX		(SP),HL			; Put back return
01:9ABC E5              	  2253: 		PUSH	HL				; Save code string address
01:9ABD C5              	  2254: 		PUSH	BC				; Save variable name
01:9ABE 010600          	  2255: 		LD		BC,6			; 2 byte name plus 4 byte data
01:9AC1 2ADA10          	  2256: 		LD		HL,(ARREND)		; End of arrays
01:9AC4 E5              	  2257: 		PUSH	HL				; Save end of arrays
01:9AC5 09              	  2258: 		ADD		HL,BC			; Move up 6 bytes
01:9AC6 C1              	  2259: 		POP		BC				; Source address in BC
01:9AC7 E5              	  2260: 		PUSH	HL				; Save new end address
01:9AC8 CD488F          	  2261: 		CALL	MOVUP			; Move arrays up
01:9ACB E1              	  2262: 		POP		HL				; Restore new end address
01:9ACC 22DA10          	  2263: 		LD		(ARREND),HL		; Set new end address
01:9ACF 60              	  2264: 		LD		H,B				; End of variables to HL
01:9AD0 69              	  2265: 		LD		L,C
01:9AD1 22D810          	  2266: 		LD		(VAREND),HL		; Set new end address
                        	  2267: 
01:9AD4 2B              	  2268: ZEROLP: DEC		HL				; Back through to zero variable
01:9AD5 3600            	  2269: 		LD		(HL),0			; Zero byte in variable
01:9AD7 CD4492          	  2270: 		CALL	CPDEHL			; Done them all?
01:9ADA C2D49A          	  2271: 		JP		NZ,ZEROLP		; No - Keep on going
01:9ADD D1              	  2272: 		POP		DE				; Get variable name
01:9ADE 73              	  2273: 		LD		(HL),E			; Store second character
01:9ADF 23              	  2274: 		INC		HL
01:9AE0 72              	  2275: 		LD		(HL),D			; Store first character
01:9AE1 23              	  2276: 		INC		HL
01:9AE2 EB              	  2277: RETADR: EX		DE,HL			; Address of variable in DE
01:9AE3 E1              	  2278: 		POP		HL				; Restore code string address
01:9AE4 C9              	  2279: 		RET
                        	  2280: 
01:9AE5 32E710          	  2281: RETNUL: LD		(FPEXP),A		; Set result to zero
01:9AE8 21188F          	  2282: 		LD		HL,ZERBYT		; Also set a null string
01:9AEB 22E410          	  2283: 		LD		(FPREG),HL		; Save for EVAL
01:9AEE E1              	  2284: 		POP		HL				; Restore code string address
01:9AEF C9              	  2285: 		RET
                        	  2286: 
01:9AF0 E5              	  2287: SBSCPT: PUSH	HL				; Save code string address
01:9AF1 2AAC10          	  2288: 		LD		HL,(LCRFLG)		; Locate/Create and Type
01:9AF4 E3              	  2289: 		EX		(SP),HL			; Save and get code string
01:9AF5 57              	  2290: 		LD		D,A				; Zero number of dimensions
01:9AF6 D5              	  2291: SCPTLP: PUSH	DE				; Save number of dimensions
01:9AF7 C5              	  2292: 		PUSH	BC				; Save array name
01:9AF8 CD7D94          	  2293: 		CALL	FPSINT			; Get subscript (0-32767)
01:9AFB C1              	  2294: 		POP		BC				; Restore array name
01:9AFC F1              	  2295: 		POP		AF				; Get number of dimensions
01:9AFD EB              	  2296: 		EX		DE,HL
01:9AFE E3              	  2297: 		EX		(SP),HL			; Save subscript value
01:9AFF E5              	  2298: 		PUSH	HL				; Save LCRFLG and TYPE
01:9B00 EB              	  2299: 		EX		DE,HL
01:9B01 3C              	  2300: 		INC		A				; Count dimensions
01:9B02 57              	  2301: 		LD		D,A				; Save in D
01:9B03 7E              	  2302: 		LD		A,(HL)			; Get next byte in code string
01:9B04 FE2C            	  2303: 		CP		','				; Comma (more to come)?
01:9B06 CAF69A          	  2304: 		JP		Z,SCPTLP		; Yes - More subscripts
01:9B09 CD4A92          	  2305: 		CALL	CHKSYN			; Make sure ")" follows
01:9B0C 29              	  2306: 		db	   ")"
01:9B0D 22D010          	  2307: 		LD		(NXTOPR),HL		; Save code string address
01:9B10 E1              	  2308: 		POP		HL				; Get LCRFLG and TYPE
01:9B11 22AC10          	  2309: 		LD		(LCRFLG),HL		; Restore Locate/create & type
01:9B14 1E00            	  2310: 		LD		E,0				; Flag not CSAVE* or CLOAD*
01:9B16 D5              	  2311: 		PUSH	DE				; Save number of dimensions (D)
01:9B17 11              	  2312: 		db	   11H			   ; Skip "PUSH HL" and "PUSH AF'
                        	  2313: 
01:9B18 E5              	  2314: ARLDSV: PUSH	HL				; Save code string address
01:9B19 F5              	  2315: 		PUSH	AF				; A = 00 , Flags set = Z,N
01:9B1A 2AD810          	  2316: 		LD		HL,(VAREND)		; Start of arrays
01:9B1D 3E              	  2317: 		db	   3EH			   ; Skip "ADD HL,DE"
01:9B1E 19              	  2318: FNDARY: ADD		HL,DE			; Move to next array start
01:9B1F EB              	  2319: 		EX		DE,HL
01:9B20 2ADA10          	  2320: 		LD		HL,(ARREND)		; End of arrays
01:9B23 EB              	  2321: 		EX		DE,HL			; Current array pointer
01:9B24 CD4492          	  2322: 		CALL	CPDEHL			; End of arrays found?
01:9B27 CA509B          	  2323: 		JP		Z,CREARY		; Yes - Create array
01:9B2A 7E              	  2324: 		LD		A,(HL)			; Get second byte of name
01:9B2B B9              	  2325: 		CP		C				; Compare with name given
01:9B2C 23              	  2326: 		INC		HL				; Move on
01:9B2D C2329B          	  2327: 		JP		NZ,NXTARY		; Different - Find next array
01:9B30 7E              	  2328: 		LD		A,(HL)			; Get first byte of name
01:9B31 B8              	  2329: 		CP		B				; Compare with name given
01:9B32 23              	  2330: NXTARY: INC		HL				; Move on
01:9B33 5E              	  2331: 		LD		E,(HL)			; Get LSB of next array address
01:9B34 23              	  2332: 		INC		HL
01:9B35 56              	  2333: 		LD		D,(HL)			; Get MSB of next array address
01:9B36 23              	  2334: 		INC		HL
01:9B37 C21E9B          	  2335: 		JP		NZ,FNDARY		; Not found - Keep looking
01:9B3A 3AAC10          	  2336: 		LD		A,(LCRFLG)		; Found Locate or Create it?
01:9B3D B7              	  2337: 		OR		A
01:9B3E C2858F          	  2338: 		JP		NZ,DDERR		; Create - ?DD Error
01:9B41 F1              	  2339: 		POP		AF				; Locate - Get number of dim'ns
01:9B42 44              	  2340: 		LD		B,H				; BC Points to array dim'ns
01:9B43 4D              	  2341: 		LD		C,L
01:9B44 CA60A1          	  2342: 		JP		Z,POPHRT		; Jump if array load/save
01:9B47 96              	  2343: 		SUB		(HL)			; Same number of dimensions?
01:9B48 CAAE9B          	  2344: 		JP		Z,FINDEL		; Yes - Find element
01:9B4B 1E10            	  2345: BSERR:	LD		E,BS			; ?BS Error
01:9B4D C3908F          	  2346: 		JP		ERROR			; Output error
                        	  2347: 
01:9B50 110400          	  2348: CREARY: LD		DE,4			; 4 Bytes per entry
01:9B53 F1              	  2349: 		POP		AF				; Array to save or 0 dim'ns?
01:9B54 CA9E94          	  2350: 		JP		Z,FCERR			; Yes - ?FC Error
01:9B57 71              	  2351: 		LD		(HL),C			; Save second byte of name
01:9B58 23              	  2352: 		INC		HL
01:9B59 70              	  2353: 		LD		(HL),B			; Save first byte of name
01:9B5A 23              	  2354: 		INC		HL
01:9B5B 4F              	  2355: 		LD		C,A				; Number of dimensions to C
01:9B5C CD598F          	  2356: 		CALL	CHKSTK			; Check if enough memory
01:9B5F 23              	  2357: 		INC		HL				; Point to number of dimensions
01:9B60 23              	  2358: 		INC		HL
01:9B61 22C510          	  2359: 		LD		(CUROPR),HL		; Save address of pointer
01:9B64 71              	  2360: 		LD		(HL),C			; Set number of dimensions
01:9B65 23              	  2361: 		INC		HL
01:9B66 3AAC10          	  2362: 		LD		A,(LCRFLG)		; Locate of Create?
01:9B69 17              	  2363: 		RLA						; Carry set = Create
01:9B6A 79              	  2364: 		LD		A,C				; Get number of dimensions
01:9B6B 010B00          	  2365: CRARLP: LD		BC,10+1			; Default dimension size 10
01:9B6E D2739B          	  2366: 		JP		NC,DEFSIZ		; Locate - Set default size
01:9B71 C1              	  2367: 		POP		BC				; Get specified dimension size
01:9B72 03              	  2368: 		INC		BC				; Include zero element
01:9B73 71              	  2369: DEFSIZ: LD		(HL),C			; Save LSB of dimension size
01:9B74 23              	  2370: 		INC		HL
01:9B75 70              	  2371: 		LD		(HL),B			; Save MSB of dimension size
01:9B76 23              	  2372: 		INC		HL
01:9B77 F5              	  2373: 		PUSH	AF				; Save num' of dim'ns an status
01:9B78 E5              	  2374: 		PUSH	HL				; Save address of dim'n size
01:9B79 CD0BA3          	  2375: 		CALL	MLDEBC			; Multiply DE by BC to find
01:9B7C EB              	  2376: 		EX		DE,HL			; amount of mem needed (to DE)
01:9B7D E1              	  2377: 		POP		HL				; Restore address of dimension
01:9B7E F1              	  2378: 		POP		AF				; Restore number of dimensions
01:9B7F 3D              	  2379: 		DEC		A				; Count them
01:9B80 C26B9B          	  2380: 		JP		NZ,CRARLP		; Do next dimension if more
01:9B83 F5              	  2381: 		PUSH	AF				; Save locate/create flag
01:9B84 42              	  2382: 		LD		B,D				; MSB of memory needed
01:9B85 4B              	  2383: 		LD		C,E				; LSB of memory needed
01:9B86 EB              	  2384: 		EX		DE,HL
01:9B87 19              	  2385: 		ADD		HL,DE			; Add bytes to array start
01:9B88 DA718F          	  2386: 		JP		C,OMERR			; Too big - Error
01:9B8B CD628F          	  2387: 		CALL	ENFMEM			; See if enough memory
01:9B8E 22DA10          	  2388: 		LD		(ARREND),HL		; Save new end of array
                        	  2389: 
01:9B91 2B              	  2390: ZERARY: DEC		HL				; Back through array data
01:9B92 3600            	  2391: 		LD		(HL),0			; Set array element to zero
01:9B94 CD4492          	  2392: 		CALL	CPDEHL			; All elements zeroed?
01:9B97 C2919B          	  2393: 		JP		NZ,ZERARY		; No - Keep on going
01:9B9A 03              	  2394: 		INC		BC				; Number of bytes + 1
01:9B9B 57              	  2395: 		LD		D,A				; A=0
01:9B9C 2AC510          	  2396: 		LD		HL,(CUROPR)		; Get address of array
01:9B9F 5E              	  2397: 		LD		E,(HL)			; Number of dimensions
01:9BA0 EB              	  2398: 		EX		DE,HL			; To HL
01:9BA1 29              	  2399: 		ADD		HL,HL			; Two bytes per dimension size
01:9BA2 09              	  2400: 		ADD		HL,BC			; Add number of bytes
01:9BA3 EB              	  2401: 		EX		DE,HL			; Bytes needed to DE
01:9BA4 2B              	  2402: 		DEC		HL
01:9BA5 2B              	  2403: 		DEC		HL
01:9BA6 73              	  2404: 		LD		(HL),E			; Save LSB of bytes needed
01:9BA7 23              	  2405: 		INC		HL
01:9BA8 72              	  2406: 		LD		(HL),D			; Save MSB of bytes needed
01:9BA9 23              	  2407: 		INC		HL
01:9BAA F1              	  2408: 		POP		AF				; Locate / Create?
01:9BAB DAD29B          	  2409: 		JP		C,ENDDIM		; A is 0 , End if create
01:9BAE 47              	  2410: FINDEL: LD		B,A				; Find array element
01:9BAF 4F              	  2411: 		LD		C,A
01:9BB0 7E              	  2412: 		LD		A,(HL)			; Number of dimensions
01:9BB1 23              	  2413: 		INC		HL
01:9BB2 16              	  2414: 		db	   16H			   ; Skip "POP HL"
01:9BB3 E1              	  2415: FNDELP: POP		HL				; Address of next dim' size
01:9BB4 5E              	  2416: 		LD		E,(HL)			; Get LSB of dim'n size
01:9BB5 23              	  2417: 		INC		HL
01:9BB6 56              	  2418: 		LD		D,(HL)			; Get MSB of dim'n size
01:9BB7 23              	  2419: 		INC		HL
01:9BB8 E3              	  2420: 		EX		(SP),HL			; Save address - Get index
01:9BB9 F5              	  2421: 		PUSH	AF				; Save number of dim'ns
01:9BBA CD4492          	  2422: 		CALL	CPDEHL			; Dimension too large?
01:9BBD D24B9B          	  2423: 		JP		NC,BSERR		; Yes - ?BS Error
01:9BC0 E5              	  2424: 		PUSH	HL				; Save index
01:9BC1 CD0BA3          	  2425: 		CALL	MLDEBC			; Multiply previous by size
01:9BC4 D1              	  2426: 		POP		DE				; Index supplied to DE
01:9BC5 19              	  2427: 		ADD		HL,DE			; Add index to pointer
01:9BC6 F1              	  2428: 		POP		AF				; Number of dimensions
01:9BC7 3D              	  2429: 		DEC		A				; Count them
01:9BC8 44              	  2430: 		LD		B,H				; MSB of pointer
01:9BC9 4D              	  2431: 		LD		C,L				; LSB of pointer
01:9BCA C2B39B          	  2432: 		JP		NZ,FNDELP		; More - Keep going
01:9BCD 29              	  2433: 		ADD		HL,HL			; 4 Bytes per element
01:9BCE 29              	  2434: 		ADD		HL,HL
01:9BCF C1              	  2435: 		POP		BC				; Start of array
01:9BD0 09              	  2436: 		ADD		HL,BC			; Point to element
01:9BD1 EB              	  2437: 		EX		DE,HL			; Address of element to DE
01:9BD2 2AD010          	  2438: ENDDIM: LD		HL,(NXTOPR)		; Got code string address
01:9BD5 C9              	  2439: 		RET
                        	  2440: 
01:9BD6 2ADA10          	  2441: FRE:	LD		HL,(ARREND)		; Start of free memory
01:9BD9 EB              	  2442: 		EX		DE,HL			; To DE
01:9BDA 210000          	  2443: 		LD		HL,0			; End of free memory
01:9BDD 39              	  2444: 		ADD		HL,SP			; Current stack value
01:9BDE 3AAD10          	  2445: 		LD		A,(TYPE)		; Dummy argument type
01:9BE1 B7              	  2446: 		OR		A
01:9BE2 CAF29B          	  2447: 		JP		Z,FRENUM		; Numeric - Free variable space
01:9BE5 CD599E          	  2448: 		CALL	GSTRCU			; Current string to pool
01:9BE8 CD599D          	  2449: 		CALL	GARBGE			; Garbage collection
01:9BEB 2A5A10          	  2450: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9BEE EB              	  2451: 		EX		DE,HL			; To DE
01:9BEF 2AC310          	  2452: 		LD		HL,(STRBOT)		; Bottom of string space
01:9BF2 7D              	  2453: FRENUM: LD		A,L				; Get LSB of end
01:9BF3 93              	  2454: 		SUB		E				; Subtract LSB of beginning
01:9BF4 4F              	  2455: 		LD		C,A				; Save difference if C
01:9BF5 7C              	  2456: 		LD		A,H				; Get MSB of end
01:9BF6 9A              	  2457: 		SBC		A,D				; Subtract MSB of beginning
01:9BF7 41              	  2458: ACPASS: LD		B,C				; Return integer AC
01:9BF8 50              	  2459: ABPASS: LD		D,B				; Return integer AB
01:9BF9 1E00            	  2460: 		LD		E,0
01:9BFB 21AD10          	  2461: 		LD		HL,TYPE			; Point to type
01:9BFE 73              	  2462: 		LD		(HL),E			; Set type to numeric
01:9BFF 0690            	  2463: 		LD		B,80H+16		; 16 bit integer
01:9C01 C336A2          	  2464: 		JP		RETINT			; Return the integr
                        	  2465: 
01:9C04 3AAB10          	  2466: POS:	LD		A,(CURPOS)		; Get cursor position
01:9C07 47              	  2467: PASSA:	LD		B,A				; Put A into AB
01:9C08 AF              	  2468: 		XOR		A				; Zero A
01:9C09 C3F89B          	  2469: 		JP		ABPASS			; Return integer AB
                        	  2470: 
01:9C0C CD8F9C          	  2471: DEF:	CALL	CHEKFN			; Get "FN" and name
01:9C0F CD819C          	  2472: 		CALL	IDTEST			; Test for illegal direct
01:9C12 016E95          	  2473: 		LD		BC,DATAA			; To get next statement
01:9C15 C5              	  2474: 		PUSH	BC				; Save address for RETurn
01:9C16 D5              	  2475: 		PUSH	DE				; Save address of function ptr
01:9C17 CD4A92          	  2476: 		CALL	CHKSYN			; Make sure "(" follows
01:9C1A 28              	  2477: 		db	   "("
01:9C1B CD339A          	  2478: 		CALL	GETVAR			; Get argument variable name
01:9C1E E5              	  2479: 		PUSH	HL				; Save code string address
01:9C1F EB              	  2480: 		EX		DE,HL			; Argument address to HL
01:9C20 2B              	  2481: 		DEC		HL
01:9C21 56              	  2482: 		LD		D,(HL)			; Get first byte of arg name
01:9C22 2B              	  2483: 		DEC		HL
01:9C23 5E              	  2484: 		LD		E,(HL)			; Get second byte of arg name
01:9C24 E1              	  2485: 		POP		HL				; Restore code string address
01:9C25 CD4098          	  2486: 		CALL	TSTNUM			; Make sure numeric argument
01:9C28 CD4A92          	  2487: 		CALL	CHKSYN			; Make sure ")" follows
01:9C2B 29              	  2488: 		db	   ")"
01:9C2C CD4A92          	  2489: 		CALL	CHKSYN			; Make sure "=" follows
01:9C2F B4              	  2490: 		db	   ZEQUAL		   ; "=" token
01:9C30 44              	  2491: 		LD		B,H				; Code string address to BC
01:9C31 4D              	  2492: 		LD		C,L
01:9C32 E3              	  2493: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C33 71              	  2494: 		LD		(HL),C			; Save LSB of FN code string
01:9C34 23              	  2495: 		INC		HL
01:9C35 70              	  2496: 		LD		(HL),B			; Save MSB of FN code string
01:9C36 C3CE9C          	  2497: 		JP		SVSTAD			; Save address and do function
                        	  2498: 
01:9C39 CD8F9C          	  2499: DOFN:	CALL	CHEKFN			; Make sure FN follows
01:9C3C D5              	  2500: 		PUSH	DE				; Save function pointer address
01:9C3D CD1499          	  2501: 		CALL	EVLPAR			; Evaluate expression in "()"
01:9C40 CD4098          	  2502: 		CALL	TSTNUM			; Make sure numeric result
01:9C43 E3              	  2503: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C44 5E              	  2504: 		LD		E,(HL)			; Get LSB of FN code string
01:9C45 23              	  2505: 		INC		HL
01:9C46 56              	  2506: 		LD		D,(HL)			; Get MSB of FN code string
01:9C47 23              	  2507: 		INC		HL
01:9C48 7A              	  2508: 		LD		A,D				; And function DEFined?
01:9C49 B3              	  2509: 		OR		E
01:9C4A CA888F          	  2510: 		JP		Z,UFERR			; No - ?UF Error
01:9C4D 7E              	  2511: 		LD		A,(HL)			; Get LSB of argument address
01:9C4E 23              	  2512: 		INC		HL
01:9C4F 66              	  2513: 		LD		H,(HL)			; Get MSB of argument address
01:9C50 6F              	  2514: 		LD		L,A				; HL = Arg variable address
01:9C51 E5              	  2515: 		PUSH	HL				; Save it
01:9C52 2ADE10          	  2516: 		LD		HL,(FNRGNM)		; Get old argument name
01:9C55 E3              	  2517: 		EX		(SP),HL ;		; Save old , Get new
01:9C56 22DE10          	  2518: 		LD		(FNRGNM),HL		; Set new argument name
01:9C59 2AE210          	  2519: 		LD		HL,(FNARG+2)	; Get LSB,NLSB of old arg value
01:9C5C E5              	  2520: 		PUSH	HL				; Save it
01:9C5D 2AE010          	  2521: 		LD		HL,(FNARG)		; Get MSB,EXP of old arg value
01:9C60 E5              	  2522: 		PUSH	HL				; Save it
01:9C61 21E010          	  2523: 		LD		HL,FNARG		; HL = Value of argument
01:9C64 D5              	  2524: 		PUSH	DE				; Save FN code string address
01:9C65 CD77A2          	  2525: 		CALL	FPTHL			; Move FPREG to argument
01:9C68 E1              	  2526: 		POP		HL				; Get FN code string address
01:9C69 CD3D98          	  2527: 		CALL	GETNUM			; Get value from function
01:9C6C 2B              	  2528: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9C6D CDD493          	  2529: 		CALL	GETCHR			; Get next character
01:9C70 C27C8F          	  2530: 		JP		NZ,SNERR		; Bad character in FN - Error
01:9C73 E1              	  2531: 		POP		HL				; Get MSB,EXP of old arg
01:9C74 22E010          	  2532: 		LD		(FNARG),HL		; Restore it
01:9C77 E1              	  2533: 		POP		HL				; Get LSB,NLSB of old arg
01:9C78 22E210          	  2534: 		LD		(FNARG+2),HL	; Restore it
01:9C7B E1              	  2535: 		POP		HL				; Get name of old arg
01:9C7C 22DE10          	  2536: 		LD		(FNRGNM),HL		; Restore it
01:9C7F E1              	  2537: 		POP		HL				; Restore code string address
01:9C80 C9              	  2538: 		RET
                        	  2539: 
01:9C81 E5              	  2540: IDTEST: PUSH	HL				; Save code string address
01:9C82 2A5C10          	  2541: 		LD		HL,(LINEAT)		; Get current line number
01:9C85 23              	  2542: 		INC		HL				; -1 means direct statement
01:9C86 7C              	  2543: 		LD		A,H
01:9C87 B5              	  2544: 		OR		L
01:9C88 E1              	  2545: 		POP		HL				; Restore code string address
01:9C89 C0              	  2546: 		RET		NZ				; Return if in program
01:9C8A 1E16            	  2547: 		LD		E,ID			; ?ID Error
01:9C8C C3908F          	  2548: 		JP		ERROR
                        	  2549: 
01:9C8F CD4A92          	  2550: CHEKFN: CALL	CHKSYN			; Make sure FN follows
01:9C92 A7              	  2551: 		db	   ZFN			   ; "FN" token
01:9C93 3E80            	  2552: 		LD		A,80H
01:9C95 32CB10          	  2553: 		LD		(FORFLG),A		; Flag FN name to find
01:9C98 B6              	  2554: 		OR		(HL)			; FN name has bit 7 set
01:9C99 47              	  2555: 		LD		B,A				; in first byte of name
01:9C9A CD389A          	  2556: 		CALL	GTFNAM			; Get FN name
01:9C9D C34098          	  2557: 		JP		TSTNUM			; Make sure numeric function
                        	  2558: 
01:9CA0 CD4098          	  2559: STRR:	CALL	TSTNUM			; Make sure it's a number
01:9CA3 CDC4A3          	  2560: 		CALL	NUMASC			; Turn number into text
01:9CA6 CDD49C          	  2561: STR1:	CALL	CRTST			; Create string entry for it
01:9CA9 CD599E          	  2562: 		CALL	GSTRCU			; Current string to pool
01:9CAC 01B49E          	  2563: 		LD		BC,TOPOOL		; Save in string pool
01:9CAF C5              	  2564: 		PUSH	BC				; Save address on stack
                        	  2565: 
01:9CB0 7E              	  2566: SAVSTR: LD		A,(HL)			; Get string length
01:9CB1 23              	  2567: 		INC		HL
01:9CB2 23              	  2568: 		INC		HL
01:9CB3 E5              	  2569: 		PUSH	HL				; Save pointer to string
01:9CB4 CD2F9D          	  2570: 		CALL	TESTR			; See if enough string space
01:9CB7 E1              	  2571: 		POP		HL				; Restore pointer to string
01:9CB8 4E              	  2572: 		LD		C,(HL)			; Get LSB of address
01:9CB9 23              	  2573: 		INC		HL
01:9CBA 46              	  2574: 		LD		B,(HL)			; Get MSB of address
01:9CBB CDC89C          	  2575: 		CALL	CRTMST			; Create string entry
01:9CBE E5              	  2576: 		PUSH	HL				; Save pointer to MSB of addr
01:9CBF 6F              	  2577: 		LD		L,A				; Length of string
01:9CC0 CD4C9E          	  2578: 		CALL	TOSTRA			; Move to string area
01:9CC3 D1              	  2579: 		POP		DE				; Restore pointer to MSB
01:9CC4 C9              	  2580: 		RET
                        	  2581: 
01:9CC5 CD2F9D          	  2582: MKTMST: CALL	TESTR			; See if enough string space
01:9CC8 21BF10          	  2583: CRTMST: LD		HL,TMPSTR		; Temporary string
01:9CCB E5              	  2584: 		PUSH	HL				; Save it
01:9CCC 77              	  2585: 		LD		(HL),A			; Save length of string
01:9CCD 23              	  2586: 		INC		HL
01:9CCE 23              	  2587: SVSTAD: INC		HL
01:9CCF 73              	  2588: 		LD		(HL),E			; Save LSB of address
01:9CD0 23              	  2589: 		INC		HL
01:9CD1 72              	  2590: 		LD		(HL),D			; Save MSB of address
01:9CD2 E1              	  2591: 		POP		HL				; Restore pointer
01:9CD3 C9              	  2592: 		RET
                        	  2593: 
01:9CD4 2B              	  2594: CRTST:	DEC		HL				; DEC - INCed after
01:9CD5 0622            	  2595: QTSTR:	LD		B,'"'			; Terminating quote "
01:9CD7 50              	  2596: 		LD		D,B				; Quote to D
01:9CD8 E5              	  2597: DTSTR:	PUSH	HL				; Save start
01:9CD9 0EFF            	  2598: 		LD		C,-1			; Set counter to -1
01:9CDB 23              	  2599: QTSTLP: INC		HL				; Move on
01:9CDC 7E              	  2600: 		LD		A,(HL)			; Get byte
01:9CDD 0C              	  2601: 		INC		C				; Count bytes
01:9CDE B7              	  2602: 		OR		A				; End of line?
01:9CDF CAEA9C          	  2603: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CE2 BA              	  2604: 		CP		D				; Terminator D found?
01:9CE3 CAEA9C          	  2605: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CE6 B8              	  2606: 		CP		B				; Terminator B found?
01:9CE7 C2DB9C          	  2607: 		JP		NZ,QTSTLP		; No - Keep looking
01:9CEA FE22            	  2608: CRTSTE: CP		'"'				; End with '"'?
01:9CEC CCD493          	  2609: 		CALL	Z,GETCHR		; Yes - Get next character
01:9CEF E3              	  2610: 		EX		(SP),HL			; Starting quote
01:9CF0 23              	  2611: 		INC		HL				; First byte of string
01:9CF1 EB              	  2612: 		EX		DE,HL			; To DE
01:9CF2 79              	  2613: 		LD		A,C				; Get length
01:9CF3 CDC89C          	  2614: 		CALL	CRTMST			; Create string entry
01:9CF6 11BF10          	  2615: TSTOPL: LD		DE,TMPSTR		; Temporary string
01:9CF9 2AB110          	  2616: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9CFC 22E410          	  2617: 		LD		(FPREG),HL		; Save address of string ptr
01:9CFF 3E01            	  2618: 		LD		A,1
01:9D01 32AD10          	  2619: 		LD		(TYPE),A		; Set type to string
01:9D04 CD7AA2          	  2620: 		CALL	DETHL4			; Move string to pool
01:9D07 CD4492          	  2621: 		CALL	CPDEHL			; Out of string pool?
01:9D0A 22B110          	  2622: 		LD		(TMSTPT),HL		; Save new pointer
01:9D0D E1              	  2623: 		POP		HL				; Restore code string address
01:9D0E 7E              	  2624: 		LD		A,(HL)			; Get next code byte
01:9D0F C0              	  2625: 		RET		NZ				; Return if pool OK
01:9D10 1E1E            	  2626: 		LD		E,ST			; ?ST Error
01:9D12 C3908F          	  2627: 		JP		ERROR			; String pool overflow
                        	  2628: 
01:9D15 23              	  2629: PRNUMS: INC		HL				; Skip leading space
01:9D16 CDD49C          	  2630: PRS:	CALL	CRTST			; Create string entry for it
01:9D19 CD599E          	  2631: PRS1:	CALL	GSTRCU			; Current string to pool
01:9D1C CD6EA2          	  2632: 		CALL	LOADFP			; Move string block to BCDE
01:9D1F 1C              	  2633: 		INC		E				; Length + 1
01:9D20 1D              	  2634: PRSLP:	DEC		E				; Count characters
01:9D21 C8              	  2635: 		RET		Z				; End of string
01:9D22 0A              	  2636: 		LD		A,(BC)			; Get byte to output
01:9D23 CD5592          	  2637: 		CALL	OUTC			; Output character in A
01:9D26 FE0D            	  2638: 		CP		CR				; Return?
01:9D28 CC8296          	  2639: 		CALL	Z,DONULL		; Yes - Do nulls
01:9D2B 03              	  2640: 		INC		BC				; Next byte in string
01:9D2C C3209D          	  2641: 		JP		PRSLP			; More characters to output
                        	  2642: 
01:9D2F B7              	  2643: TESTR:	OR		A				; Test if enough room
01:9D30 0E              	  2644: 		db	   0EH			   ; No garbage collection done
01:9D31 F1              	  2645: GRBDON: POP		AF				; Garbage collection done
01:9D32 F5              	  2646: 		PUSH	AF				; Save status
01:9D33 2A5A10          	  2647: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9D36 EB              	  2648: 		EX		DE,HL			; To DE
01:9D37 2AC310          	  2649: 		LD		HL,(STRBOT)		; Bottom of string area
01:9D3A 2F              	  2650: 		CPL						; Negate length (Top down)
01:9D3B 4F              	  2651: 		LD		C,A				; -Length to BC
01:9D3C 06FF            	  2652: 		LD		B,-1			; BC = -ve length of string
01:9D3E 09              	  2653: 		ADD		HL,BC			; Add to bottom of space in use
01:9D3F 23              	  2654: 		INC		HL				; Plus one for 2's complement
01:9D40 CD4492          	  2655: 		CALL	CPDEHL			; Below string RAM area?
01:9D43 DA4D9D          	  2656: 		JP		C,TESTOS		; Tidy up if not done else err
01:9D46 22C310          	  2657: 		LD		(STRBOT),HL		; Save new bottom of area
01:9D49 23              	  2658: 		INC		HL				; Point to first byte of string
01:9D4A EB              	  2659: 		EX		DE,HL			; Address to DE
01:9D4B F1              	  2660: POPAF:	POP		AF				; Throw away status push
01:9D4C C9              	  2661: 		RET
                        	  2662: 
01:9D4D F1              	  2663: TESTOS: POP		AF				; Garbage collect been done?
01:9D4E 1E1A            	  2664: 		LD		E,OS			; ?OS Error
01:9D50 CA908F          	  2665: 		JP		Z,ERROR			; Yes - Not enough string apace
01:9D53 BF              	  2666: 		CP		A				; Flag garbage collect done
01:9D54 F5              	  2667: 		PUSH	AF				; Save status
01:9D55 01319D          	  2668: 		LD		BC,GRBDON		; Garbage collection done
01:9D58 C5              	  2669: 		PUSH	BC				; Save for RETurn
01:9D59 2AAF10          	  2670: GARBGE: LD		HL,(LSTRAM)		; Get end of RAM pointer
01:9D5C 22C310          	  2671: GARBLP: LD		(STRBOT),HL		; Reset string pointer
01:9D5F 210000          	  2672: 		LD		HL,0
01:9D62 E5              	  2673: 		PUSH	HL				; Flag no string found
01:9D63 2A5A10          	  2674: 		LD		HL,(STRSPC)		; Get bottom of string space
01:9D66 E5              	  2675: 		PUSH	HL				; Save bottom of string space
01:9D67 21B310          	  2676: 		LD		HL,TMSTPL		; Temporary string pool
01:9D6A EB              	  2677: GRBLP:	EX		DE,HL
01:9D6B 2AB110          	  2678: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9D6E EB              	  2679: 		EX		DE,HL
01:9D6F CD4492          	  2680: 		CALL	CPDEHL			; Temporary string pool done?
01:9D72 016A9D          	  2681: 		LD		BC,GRBLP		; Loop until string pool done
01:9D75 C2BE9D          	  2682: 		JP		NZ,STPOOL		; No - See if in string area
01:9D78 2AD610          	  2683: 		LD		HL,(PROGND)		; Start of simple variables
01:9D7B EB              	  2684: SMPVAR: EX		DE,HL
01:9D7C 2AD810          	  2685: 		LD		HL,(VAREND)		; End of simple variables
01:9D7F EB              	  2686: 		EX		DE,HL
01:9D80 CD4492          	  2687: 		CALL	CPDEHL			; All simple strings done?
01:9D83 CA919D          	  2688: 		JP		Z,ARRLP			; Yes - Do string arrays
01:9D86 7E              	  2689: 		LD		A,(HL)			; Get type of variable
01:9D87 23              	  2690: 		INC		HL
01:9D88 23              	  2691: 		INC		HL
01:9D89 B7              	  2692: 		OR		A				; "S" flag set if string
01:9D8A CDC19D          	  2693: 		CALL	STRADD			; See if string in string area
01:9D8D C37B9D          	  2694: 		JP		SMPVAR			; Loop until simple ones done
                        	  2695: 
01:9D90 C1              	  2696: GNXARY: POP		BC				; Scrap address of this array
01:9D91 EB              	  2697: ARRLP:	EX		DE,HL
01:9D92 2ADA10          	  2698: 		LD		HL,(ARREND)		; End of string arrays
01:9D95 EB              	  2699: 		EX		DE,HL
01:9D96 CD4492          	  2700: 		CALL	CPDEHL			; All string arrays done?
01:9D99 CAE79D          	  2701: 		JP		Z,SCNEND		; Yes - Move string if found
01:9D9C CD6EA2          	  2702: 		CALL	LOADFP			; Get array name to BCDE
01:9D9F 7B              	  2703: 		LD		A,E				; Get type of array		
01:9DA0 E5              	  2704: 		PUSH	HL				; Save address of num of dim'ns
01:9DA1 09              	  2705: 		ADD		HL,BC			; Start of next array
01:9DA2 B7              	  2706: 		OR		A				; Test type of array
01:9DA3 F2909D          	  2707: 		JP		P,GNXARY		; Numeric array - Ignore it
01:9DA6 22C510          	  2708: 		LD		(CUROPR),HL		; Save address of next array
01:9DA9 E1              	  2709: 		POP		HL				; Get address of num of dim'ns
01:9DAA 4E              	  2710: 		LD		C,(HL)			; BC = Number of dimensions
01:9DAB 0600            	  2711: 		LD		B,0
01:9DAD 09              	  2712: 		ADD		HL,BC			; Two bytes per dimension size
01:9DAE 09              	  2713: 		ADD		HL,BC
01:9DAF 23              	  2714: 		INC		HL				; Plus one for number of dim'ns
01:9DB0 EB              	  2715: GRBARY: EX		DE,HL
01:9DB1 2AC510          	  2716: 		LD		HL,(CUROPR)		; Get address of next array
01:9DB4 EB              	  2717: 		EX		DE,HL
01:9DB5 CD4492          	  2718: 		CALL	CPDEHL			; Is this array finished?
01:9DB8 CA919D          	  2719: 		JP		Z,ARRLP			; Yes - Get next one
01:9DBB 01B09D          	  2720: 		LD		BC,GRBARY		; Loop until array all done
01:9DBE C5              	  2721: STPOOL: PUSH	BC				; Save return address
01:9DBF F680            	  2722: 		OR		80H				; Flag string type
01:9DC1 7E              	  2723: STRADD: LD		A,(HL)			; Get string length
01:9DC2 23              	  2724: 		INC		HL
01:9DC3 23              	  2725: 		INC		HL
01:9DC4 5E              	  2726: 		LD		E,(HL)			; Get LSB of string address
01:9DC5 23              	  2727: 		INC		HL
01:9DC6 56              	  2728: 		LD		D,(HL)			; Get MSB of string address
01:9DC7 23              	  2729: 		INC		HL
01:9DC8 F0              	  2730: 		RET		P				; Not a string - Return
01:9DC9 B7              	  2731: 		OR		A				; Set flags on string length
01:9DCA C8              	  2732: 		RET		Z				; Null string - Return
01:9DCB 44              	  2733: 		LD		B,H				; Save variable pointer
01:9DCC 4D              	  2734: 		LD		C,L
01:9DCD 2AC310          	  2735: 		LD		HL,(STRBOT)		; Bottom of new area
01:9DD0 CD4492          	  2736: 		CALL	CPDEHL			; String been done?
01:9DD3 60              	  2737: 		LD		H,B				; Restore variable pointer
01:9DD4 69              	  2738: 		LD		L,C
01:9DD5 D8              	  2739: 		RET		C				; String done - Ignore
01:9DD6 E1              	  2740: 		POP		HL				; Return address
01:9DD7 E3              	  2741: 		EX		(SP),HL			; Lowest available string area
01:9DD8 CD4492          	  2742: 		CALL	CPDEHL			; String within string area?
01:9DDB E3              	  2743: 		EX		(SP),HL			; Lowest available string area
01:9DDC E5              	  2744: 		PUSH	HL				; Re-save return address
01:9DDD 60              	  2745: 		LD		H,B				; Restore variable pointer
01:9DDE 69              	  2746: 		LD		L,C
01:9DDF D0              	  2747: 		RET		NC				; Outside string area - Ignore
01:9DE0 C1              	  2748: 		POP		BC				; Get return , Throw 2 away
01:9DE1 F1              	  2749: 		POP		AF				; 
01:9DE2 F1              	  2750: 		POP		AF				; 
01:9DE3 E5              	  2751: 		PUSH	HL				; Save variable pointer
01:9DE4 D5              	  2752: 		PUSH	DE				; Save address of current
01:9DE5 C5              	  2753: 		PUSH	BC				; Put back return address
01:9DE6 C9              	  2754: 		RET						; Go to it
                        	  2755: 
01:9DE7 D1              	  2756: SCNEND: POP		DE				; Addresses of strings
01:9DE8 E1              	  2757: 		POP		HL				; 
01:9DE9 7D              	  2758: 		LD		A,L				; HL = 0 if no more to do
01:9DEA B4              	  2759: 		OR		H
01:9DEB C8              	  2760: 		RET		Z				; No more to do - Return
01:9DEC 2B              	  2761: 		DEC		HL
01:9DED 46              	  2762: 		LD		B,(HL)			; MSB of address of string
01:9DEE 2B              	  2763: 		DEC		HL
01:9DEF 4E              	  2764: 		LD		C,(HL)			; LSB of address of string
01:9DF0 E5              	  2765: 		PUSH	HL				; Save variable address
01:9DF1 2B              	  2766: 		DEC		HL
01:9DF2 2B              	  2767: 		DEC		HL
01:9DF3 6E              	  2768: 		LD		L,(HL)			; HL = Length of string
01:9DF4 2600            	  2769: 		LD		H,0
01:9DF6 09              	  2770: 		ADD		HL,BC			; Address of end of string+1
01:9DF7 50              	  2771: 		LD		D,B				; String address to DE
01:9DF8 59              	  2772: 		LD		E,C
01:9DF9 2B              	  2773: 		DEC		HL				; Last byte in string
01:9DFA 44              	  2774: 		LD		B,H				; Address to BC
01:9DFB 4D              	  2775: 		LD		C,L
01:9DFC 2AC310          	  2776: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9DFF CD4B8F          	  2777: 		CALL	MOVSTR			; Move string to new address
01:9E02 E1              	  2778: 		POP		HL				; Restore variable address
01:9E03 71              	  2779: 		LD		(HL),C			; Save new LSB of address
01:9E04 23              	  2780: 		INC		HL
01:9E05 70              	  2781: 		LD		(HL),B			; Save new MSB of address
01:9E06 69              	  2782: 		LD		L,C				; Next string area+1 to HL
01:9E07 60              	  2783: 		LD		H,B
01:9E08 2B              	  2784: 		DEC		HL				; Next string area address
01:9E09 C35C9D          	  2785: 		JP		GARBLP			; Look for more strings
                        	  2786: 
01:9E0C C5              	  2787: CONCAT: PUSH	BC				; Save prec' opr & code string
01:9E0D E5              	  2788: 		PUSH	HL				; 
01:9E0E 2AE410          	  2789: 		LD		HL,(FPREG)		; Get first string
01:9E11 E3              	  2790: 		EX		(SP),HL			; Save first string
01:9E12 CDC698          	  2791: 		CALL	OPRND			; Get second string
01:9E15 E3              	  2792: 		EX		(SP),HL			; Restore first string
01:9E16 CD4198          	  2793: 		CALL	TSTSTR			; Make sure it's a string
01:9E19 7E              	  2794: 		LD		A,(HL)			; Get length of second string
01:9E1A E5              	  2795: 		PUSH	HL				; Save first string
01:9E1B 2AE410          	  2796: 		LD		HL,(FPREG)		; Get second string
01:9E1E E5              	  2797: 		PUSH	HL				; Save second string
01:9E1F 86              	  2798: 		ADD		A,(HL)			; Add length of second string
01:9E20 1E1C            	  2799: 		LD		E,LS			; ?LS Error
01:9E22 DA908F          	  2800: 		JP		C,ERROR			; String too long - Error
01:9E25 CDC59C          	  2801: 		CALL	MKTMST			; Make temporary string
01:9E28 D1              	  2802: 		POP		DE				; Get second string to DE
01:9E29 CD5D9E          	  2803: 		CALL	GSTRDE			; Move to string pool if needed
01:9E2C E3              	  2804: 		EX		(SP),HL			; Get first string
01:9E2D CD5C9E          	  2805: 		CALL	GSTRHL			; Move to string pool if needed
01:9E30 E5              	  2806: 		PUSH	HL				; Save first string
01:9E31 2AC110          	  2807: 		LD		HL,(TMPSTR+2)	; Temporary string address
01:9E34 EB              	  2808: 		EX		DE,HL			; To DE
01:9E35 CD439E          	  2809: 		CALL	SSTSA			; First string to string area
01:9E38 CD439E          	  2810: 		CALL	SSTSA			; Second string to string area
01:9E3B 215B98          	  2811: 		LD		HL,EVAL2		; Return to evaluation loop
01:9E3E E3              	  2812: 		EX		(SP),HL			; Save return,get code string
01:9E3F E5              	  2813: 		PUSH	HL				; Save code string address
01:9E40 C3F69C          	  2814: 		JP		TSTOPL			; To temporary string to pool
                        	  2815: 
01:9E43 E1              	  2816: SSTSA:	POP		HL				; Return address
01:9E44 E3              	  2817: 		EX		(SP),HL			; Get string block,save return
01:9E45 7E              	  2818: 		LD		A,(HL)			; Get length of string
01:9E46 23              	  2819: 		INC		HL
01:9E47 23              	  2820: 		INC		HL
01:9E48 4E              	  2821: 		LD		C,(HL)			; Get LSB of string address
01:9E49 23              	  2822: 		INC		HL
01:9E4A 46              	  2823: 		LD		B,(HL)			; Get MSB of string address
01:9E4B 6F              	  2824: 		LD		L,A				; Length to L
01:9E4C 2C              	  2825: TOSTRA: INC		L				; INC - DECed after
01:9E4D 2D              	  2826: TSALP:	DEC		L				; Count bytes moved
01:9E4E C8              	  2827: 		RET		Z				; End of string - Return
01:9E4F 0A              	  2828: 		LD		A,(BC)			; Get source
01:9E50 12              	  2829: 		LD		(DE),A			; Save destination
01:9E51 03              	  2830: 		INC		BC				; Next source
01:9E52 13              	  2831: 		INC		DE				; Next destination
01:9E53 C34D9E          	  2832: 		JP		TSALP			; Loop until string moved
                        	  2833: 
01:9E56 CD4198          	  2834: GETSTR: CALL	TSTSTR			; Make sure it's a string
01:9E59 2AE410          	  2835: GSTRCU: LD		HL,(FPREG)		; Get current string
01:9E5C EB              	  2836: GSTRHL: EX		DE,HL			; Save DE
01:9E5D CD779E          	  2837: GSTRDE: CALL	BAKTMP			; Was it last tmp-str?
01:9E60 EB              	  2838: 		EX		DE,HL			; Restore DE
01:9E61 C0              	  2839: 		RET		NZ				; No - Return
01:9E62 D5              	  2840: 		PUSH	DE				; Save string
01:9E63 50              	  2841: 		LD		D,B				; String block address to DE
01:9E64 59              	  2842: 		LD		E,C
01:9E65 1B              	  2843: 		DEC		DE				; Point to length
01:9E66 4E              	  2844: 		LD		C,(HL)			; Get string length
01:9E67 2AC310          	  2845: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9E6A CD4492          	  2846: 		CALL	CPDEHL			; Last one in string area?
01:9E6D C2759E          	  2847: 		JP		NZ,POPHL		; No - Return
01:9E70 47              	  2848: 		LD		B,A				; Clear B (A=0)
01:9E71 09              	  2849: 		ADD		HL,BC			; Remove string from str' area
01:9E72 22C310          	  2850: 		LD		(STRBOT),HL		; Save new bottom of str' area
01:9E75 E1              	  2851: POPHL:	POP		HL				; Restore string
01:9E76 C9              	  2852: 		RET
                        	  2853: 
01:9E77 2AB110          	  2854: BAKTMP: LD		HL,(TMSTPT)		; Get temporary string pool top
01:9E7A 2B              	  2855: 		DEC		HL				; Back
01:9E7B 46              	  2856: 		LD		B,(HL)			; Get MSB of address
01:9E7C 2B              	  2857: 		DEC		HL				; Back
01:9E7D 4E              	  2858: 		LD		C,(HL)			; Get LSB of address
01:9E7E 2B              	  2859: 		DEC		HL				; Back
01:9E7F 2B              	  2860: 		DEC		HL				; Back
01:9E80 CD4492          	  2861: 		CALL	CPDEHL			; String last in string pool?
01:9E83 C0              	  2862: 		RET		NZ				; Yes - Leave it
01:9E84 22B110          	  2863: 		LD		(TMSTPT),HL		; Save new string pool top
01:9E87 C9              	  2864: 		RET
                        	  2865: 
01:9E88 01079C          	  2866: LEN:	LD		BC,PASSA		; To return integer A
01:9E8B C5              	  2867: 		PUSH	BC				; Save address
01:9E8C CD569E          	  2868: GETLEN: CALL	GETSTR			; Get string and its length
01:9E8F AF              	  2869: 		XOR		A
01:9E90 57              	  2870: 		LD		D,A				; Clear D
01:9E91 32AD10          	  2871: 		LD		(TYPE),A		; Set type to numeric
01:9E94 7E              	  2872: 		LD		A,(HL)			; Get length of string
01:9E95 B7              	  2873: 		OR		A				; Set status flags
01:9E96 C9              	  2874: 		RET
                        	  2875: 
01:9E97 01079C          	  2876: ASCC:	LD		BC,PASSA		; To return integer A
01:9E9A C5              	  2877: 		PUSH	BC				; Save address
01:9E9B CD8C9E          	  2878: GTFLNM: CALL	GETLEN			; Get length of string
01:9E9E CA9E94          	  2879: 		JP		Z,FCERR			; Null string - Error
01:9EA1 23              	  2880: 		INC		HL
01:9EA2 23              	  2881: 		INC		HL
01:9EA3 5E              	  2882: 		LD		E,(HL)			; Get LSB of address
01:9EA4 23              	  2883: 		INC		HL
01:9EA5 56              	  2884: 		LD		D,(HL)			; Get MSB of address
01:9EA6 1A              	  2885: 		LD		A,(DE)			; Get first byte of string
01:9EA7 C9              	  2886: 		RET
                        	  2887: 
01:9EA8 3E01            	  2888: CHR:	LD		A,1				; One character string
01:9EAA CDC59C          	  2889: 		CALL	MKTMST			; Make a temporary string
01:9EAD CDA19F          	  2890: 		CALL	MAKINT			; Make it integer A
01:9EB0 2AC110          	  2891: 		LD		HL,(TMPSTR+2)	; Get address of string
01:9EB3 73              	  2892: 		LD		(HL),E			; Save character
01:9EB4 C1              	  2893: TOPOOL: POP		BC				; Clean up stack
01:9EB5 C3F69C          	  2894: 		JP		TSTOPL			; Temporary string to pool
                        	  2895: 
01:9EB8 CD519F          	  2896: LEFT:	CALL	LFRGNM			; Get number and ending ")"
01:9EBB AF              	  2897: 		XOR		A				; Start at first byte in string
01:9EBC E3              	  2898: RIGHT1: EX		(SP),HL			; Save code string,Get string
01:9EBD 4F              	  2899: 		LD		C,A				; Starting position in string
01:9EBE E5              	  2900: MID1:	PUSH	HL				; Save string block address
01:9EBF 7E              	  2901: 		LD		A,(HL)			; Get length of string
01:9EC0 B8              	  2902: 		CP		B				; Compare with number given
01:9EC1 DAC69E          	  2903: 		JP		C,ALLFOL		; All following bytes required
01:9EC4 78              	  2904: 		LD		A,B				; Get new length
01:9EC5 11              	  2905: 		db	   11H			   ; Skip "LD C,0"
01:9EC6 0E00            	  2906: ALLFOL: LD		C,0				; First byte of string
01:9EC8 C5              	  2907: 		PUSH	BC				; Save position in string
01:9EC9 CD2F9D          	  2908: 		CALL	TESTR			; See if enough string space
01:9ECC C1              	  2909: 		POP		BC				; Get position in string
01:9ECD E1              	  2910: 		POP		HL				; Restore string block address
01:9ECE E5              	  2911: 		PUSH	HL				; And re-save it
01:9ECF 23              	  2912: 		INC		HL
01:9ED0 23              	  2913: 		INC		HL
01:9ED1 46              	  2914: 		LD		B,(HL)			; Get LSB of address
01:9ED2 23              	  2915: 		INC		HL
01:9ED3 66              	  2916: 		LD		H,(HL)			; Get MSB of address
01:9ED4 68              	  2917: 		LD		L,B				; HL = address of string
01:9ED5 0600            	  2918: 		LD		B,0				; BC = starting address
01:9ED7 09              	  2919: 		ADD		HL,BC			; Point to that byte
01:9ED8 44              	  2920: 		LD		B,H				; BC = source string
01:9ED9 4D              	  2921: 		LD		C,L
01:9EDA CDC89C          	  2922: 		CALL	CRTMST			; Create a string entry
01:9EDD 6F              	  2923: 		LD		L,A				; Length of new string
01:9EDE CD4C9E          	  2924: 		CALL	TOSTRA			; Move string to string area
01:9EE1 D1              	  2925: 		POP		DE				; Clear stack
01:9EE2 CD5D9E          	  2926: 		CALL	GSTRDE			; Move to string pool if needed
01:9EE5 C3F69C          	  2927: 		JP		TSTOPL			; Temporary string to pool
                        	  2928: 
01:9EE8 CD519F          	  2929: RIGHT:	CALL	LFRGNM			; Get number and ending ")"
01:9EEB D1              	  2930: 		POP		DE				; Get string length
01:9EEC D5              	  2931: 		PUSH	DE				; And re-save
01:9EED 1A              	  2932: 		LD		A,(DE)			; Get length
01:9EEE 90              	  2933: 		SUB		B				; Move back N bytes
01:9EEF C3BC9E          	  2934: 		JP		RIGHT1			; Go and get sub-string
                        	  2935: 
01:9EF2 EB              	  2936: MID:	EX		DE,HL			; Get code string address
01:9EF3 7E              	  2937: 		LD		A,(HL)			; Get next byte ',' or ")"
01:9EF4 CD569F          	  2938: 		CALL	MIDNUM			; Get number supplied
01:9EF7 04              	  2939: 		INC		B				; Is it character zero?
01:9EF8 05              	  2940: 		DEC		B
01:9EF9 CA9E94          	  2941: 		JP		Z,FCERR			; Yes - Error
01:9EFC C5              	  2942: 		PUSH	BC				; Save starting position
01:9EFD 1EFF            	  2943: 		LD		E,255			; All of string
01:9EFF FE29            	  2944: 		CP		')'				; Any length given?
01:9F01 CA0B9F          	  2945: 		JP		Z,RSTSTR		; No - Rest of string
01:9F04 CD4A92          	  2946: 		CALL	CHKSYN			; Make sure ',' follows
01:9F07 2C              	  2947: 		db	   ','
01:9F08 CD9E9F          	  2948: 		CALL	GETINT			; Get integer 0-255
01:9F0B CD4A92          	  2949: RSTSTR: CALL	CHKSYN			; Make sure ")" follows
01:9F0E 29              	  2950: 		db	   ")"
01:9F0F F1              	  2951: 		POP		AF				; Restore starting position
01:9F10 E3              	  2952: 		EX		(SP),HL			; Get string,8ave code string
01:9F11 01BE9E          	  2953: 		LD		BC,MID1			; Continuation of MID$ routine
01:9F14 C5              	  2954: 		PUSH	BC				; Save for return
01:9F15 3D              	  2955: 		DEC		A				; Starting position-1
01:9F16 BE              	  2956: 		CP		(HL)			; Compare with length
01:9F17 0600            	  2957: 		LD		B,0				; Zero bytes length
01:9F19 D0              	  2958: 		RET		NC				; Null string if start past end
01:9F1A 4F              	  2959: 		LD		C,A				; Save starting position-1
01:9F1B 7E              	  2960: 		LD		A,(HL)			; Get length of string
01:9F1C 91              	  2961: 		SUB		C				; Subtract start
01:9F1D BB              	  2962: 		CP		E				; Enough string for it?
01:9F1E 47              	  2963: 		LD		B,A				; Save maximum length available
01:9F1F D8              	  2964: 		RET		C				; Truncate string if needed
01:9F20 43              	  2965: 		LD		B,E				; Set specified length
01:9F21 C9              	  2966: 		RET						; Go and create string
                        	  2967: 
01:9F22 CD8C9E          	  2968: VAL:	CALL	GETLEN			; Get length of string
01:9F25 CA3FA0          	  2969: 		JP		Z,RESZER		; Result zero
01:9F28 5F              	  2970: 		LD		E,A				; Save length
01:9F29 23              	  2971: 		INC		HL
01:9F2A 23              	  2972: 		INC		HL
01:9F2B 7E              	  2973: 		LD		A,(HL)			; Get LSB of address
01:9F2C 23              	  2974: 		INC		HL
01:9F2D 66              	  2975: 		LD		H,(HL)			; Get MSB of address
01:9F2E 6F              	  2976: 		LD		L,A				; HL = String address
01:9F2F E5              	  2977: 		PUSH	HL				; Save string address
01:9F30 19              	  2978: 		ADD		HL,DE
01:9F31 46              	  2979: 		LD		B,(HL)			; Get end of string+1 byte
01:9F32 72              	  2980: 		LD		(HL),D			; Zero it to terminate
01:9F33 E3              	  2981: 		EX		(SP),HL			; Save string end,get start
01:9F34 C5              	  2982: 		PUSH	BC				; Save end+1 byte
01:9F35 7E              	  2983: 		LD		A,(HL)			; Get starting byte
01:9F36 FE24            	  2984: 		CP		'$'				; Hex number indicated? [function added]
01:9F38 C2409F          	  2985: 		JP		NZ,VAL1
01:9F3B CD6EA7          	  2986: 		CALL	HEXTFP			; Convert Hex to FPREG
01:9F3E 180D            	  2987: 		JR		VAL3
01:9F40 FE25            	  2988: VAL1:	CP		'%'				; Binary number indicated? [function added]
01:9F42 C24A9F          	  2989: 		JP		NZ,VAL2
01:9F45 CDDEA7          	  2990: 		CALL	BINTFP		; Convert Bin to FPREG
01:9F48 1803            	  2991: 		JR		VAL3
01:9F4A CD26A3          	  2992: VAL2:	CALL	ASCTFP			; Convert ASCII string to FP
01:9F4D C1              	  2993: VAL3:	POP		BC				; Restore end+1 byte
01:9F4E E1              	  2994: 		POP		HL				; Restore end+1 address
01:9F4F 70              	  2995: 		LD		(HL),B			; Put back original byte
01:9F50 C9              	  2996: 		RET
                        	  2997: 
01:9F51 EB              	  2998: LFRGNM: EX		DE,HL			; Code string address to HL
01:9F52 CD4A92          	  2999: 		CALL	CHKSYN			; Make sure ")" follows
01:9F55 29              	  3000: 		db	   ")"
01:9F56 C1              	  3001: MIDNUM: POP		BC				; Get return address
01:9F57 D1              	  3002: 		POP		DE				; Get number supplied
01:9F58 C5              	  3003: 		PUSH	BC				; Re-save return address
01:9F59 43              	  3004: 		LD		B,E				; Number to B
01:9F5A C9              	  3005: 		RET
                        	  3006: 
01:9F5B CDA19F          	  3007: INP:	CALL	MAKINT			; Make it integer A
01:9F5E 323F10          	  3008: 		LD		(INPORT),A		; Set input port
01:9F61 CD3E10          	  3009: 		CALL	INPSUB			; Get input from port
01:9F64 C3079C          	  3010: 		JP		PASSA			; Return integer A
                        	  3011: 
01:9F67 CD8B9F          	  3012: POUT:	CALL	SETIO			; Set up port number
01:9F6A C30610          	  3013: 		JP		OUTSUB			; Output data and return
                        	  3014: 
01:9F6D CD8B9F          	  3015: WAIT:	CALL	SETIO			; Set up port number
01:9F70 F5              	  3016: 		PUSH	AF				; Save AND mask
01:9F71 1E00            	  3017: 		LD		E,0				; Assume zero if none given
01:9F73 2B              	  3018: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9F74 CDD493          	  3019: 		CALL	GETCHR			; Get next character
01:9F77 CA819F          	  3020: 		JP		Z,NOXOR			; No XOR byte given
01:9F7A CD4A92          	  3021: 		CALL	CHKSYN			; Make sure ',' follows
01:9F7D 2C              	  3022: 		db	   ','
01:9F7E CD9E9F          	  3023: 		CALL	GETINT			; Get integer 0-255 to XOR with
01:9F81 C1              	  3024: NOXOR:	POP		BC				; Restore AND mask
01:9F82 CD3E10          	  3025: WAITLP: CALL	INPSUB			; Get input
01:9F85 AB              	  3026: 		XOR		E				; Flip selected bits
01:9F86 A0              	  3027: 		AND		B				; Result non-zero?
01:9F87 CA829F          	  3028: 		JP		Z,WAITLP		; No = keep waiting
01:9F8A C9              	  3029: 		RET
                        	  3030: 
01:9F8B CD9E9F          	  3031: SETIO:	CALL	GETINT			; Get integer 0-255
01:9F8E 323F10          	  3032: 		LD		(INPORT),A		; Set input port
01:9F91 320710          	  3033: 		LD		(OTPORT),A		; Set output port
01:9F94 CD4A92          	  3034: 		CALL	CHKSYN			; Make sure ',' follows
01:9F97 2C              	  3035: 		db	   ','
01:9F98 C39E9F          	  3036: 		JP		GETINT			; Get integer 0-255 and return
                        	  3037: 
01:9F9B CDD493          	  3038: FNDNUM: CALL	GETCHR			; Get next character
01:9F9E CD3D98          	  3039: GETINT: CALL	GETNUM			; Get a number from 0 to 255
01:9FA1 CD8394          	  3040: MAKINT: CALL	DEPINT			; Make sure value 0 - 255
01:9FA4 7A              	  3041: 		LD		A,D				; Get MSB of number
01:9FA5 B7              	  3042: 		OR		A				; Zero?
01:9FA6 C29E94          	  3043: 		JP		NZ,FCERR		; No - Error
01:9FA9 2B              	  3044: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9FAA CDD493          	  3045: 		CALL	GETCHR			; Get next character
01:9FAD 7B              	  3046: 		LD		A,E				; Get number to A
01:9FAE C9              	  3047: 		RET
                        	  3048: 
01:9FAF CD8994          	  3049: PEEK:	CALL	DEINT			; Get memory address
01:9FB2 1A              	  3050: 		LD		A,(DE)			; Get byte in memory
01:9FB3 C3079C          	  3051: 		JP		PASSA			; Return integer A
                        	  3052: 
01:9FB6 CD3D98          	  3053: POKE:	CALL	GETNUM			; Get memory address
01:9FB9 CD8994          	  3054: 		CALL	DEINT			; Get integer -32768 to 3276
01:9FBC D5              	  3055: 		PUSH	DE				; Save memory address
01:9FBD CD4A92          	  3056: 		CALL	CHKSYN			; Make sure ',' follows
01:9FC0 2C              	  3057: 		db	   ','
01:9FC1 CD9E9F          	  3058: 		CALL	GETINT			; Get integer 0-255
01:9FC4 D1              	  3059: 		POP		DE				; Restore memory address
01:9FC5 12              	  3060: 		LD		(DE),A			; Load it into memory
01:9FC6 C9              	  3061: 		RET
                        	  3062: 
01:9FC7 219DA4          	  3063: ROUND:	LD		HL,HALF			; Add 0.5 to FPREG
01:9FCA CD6EA2          	  3064: ADDPHL: CALL	LOADFP			; Load FP at (HL) to BCDE
01:9FCD C3D99F          	  3065: 		JP		FPADD			; Add BCDE to FPREG
                        	  3066: 
01:9FD0 CD6EA2          	  3067: SUBPHL: CALL	LOADFP			; FPREG = -FPREG + number at HL
01:9FD3 21              	  3068: 		db	   21H			   ; Skip "POP BC" and "POP DE"
01:9FD4 C1              	  3069: PSUB:	POP		BC				; Get FP number from stack
01:9FD5 D1              	  3070: 		POP		DE
01:9FD6 CD48A2          	  3071: SUBCDE: CALL	INVSGN			; Negate FPREG
01:9FD9 78              	  3072: FPADD:	LD		A,B				; Get FP exponent
01:9FDA B7              	  3073: 		OR		A				; Is number zero?
01:9FDB C8              	  3074: 		RET		Z				; Yes - Nothing to add
01:9FDC 3AE710          	  3075: 		LD		A,(FPEXP)		; Get FPREG exponent
01:9FDF B7              	  3076: 		OR		A				; Is this number zero?
01:9FE0 CA60A2          	  3077: 		JP		Z,FPBCDE		; Yes - Move BCDE to FPREG
01:9FE3 90              	  3078: 		SUB		B				; BCDE number larger?
01:9FE4 D2F39F          	  3079: 		JP		NC,NOSWAP		; No - Don't swap them
01:9FE7 2F              	  3080: 		CPL						; Two's complement
01:9FE8 3C              	  3081: 		INC		A				;  FP exponent
01:9FE9 EB              	  3082: 		EX		DE,HL
01:9FEA CD50A2          	  3083: 		CALL	STAKFP			; Put FPREG on stack
01:9FED EB              	  3084: 		EX		DE,HL
01:9FEE CD60A2          	  3085: 		CALL	FPBCDE			; Move BCDE to FPREG
01:9FF1 C1              	  3086: 		POP		BC				; Restore number from stack
01:9FF2 D1              	  3087: 		POP		DE
01:9FF3 FE19            	  3088: NOSWAP: CP		24+1			; Second number insignificant?
01:9FF5 D0              	  3089: 		RET		NC				; Yes - First number is result
01:9FF6 F5              	  3090: 		PUSH	AF				; Save number of bits to scale
01:9FF7 CD85A2          	  3091: 		CALL	SIGNS			; Set MSBs & sign of result
01:9FFA 67              	  3092: 		LD		H,A				; Save sign of result
01:9FFB F1              	  3093: 		POP		AF				; Restore scaling factor
01:9FFC CD9EA0          	  3094: 		CALL	SCALE			; Scale BCDE to same exponent
01:9FFF B4              	  3095: 		OR		H				; Result to be positive?
01:A000 21E410          	  3096: 		LD		HL,FPREG		; Point to FPREG
01:A003 F219A0          	  3097: 		JP		P,MINCDE		; No - Subtract FPREG from CDE
01:A006 CD7EA0          	  3098: 		CALL	PLUCDE			; Add FPREG to CDE
01:A009 D25FA0          	  3099: 		JP		NC,RONDUP		; No overflow - Round it up
01:A00C 23              	  3100: 		INC		HL				; Point to exponent
01:A00D 34              	  3101: 		INC		(HL)			; Increment it
01:A00E CA8B8F          	  3102: 		JP		Z,OVERR			; Number overflowed - Error
01:A011 2E01            	  3103: 		LD		L,1				; 1 bit to shift right
01:A013 CDB4A0          	  3104: 		CALL	SHRT1			; Shift result right
01:A016 C35FA0          	  3105: 		JP		RONDUP			; Round it up
                        	  3106: 
01:A019 AF              	  3107: MINCDE: XOR		A				; Clear A and carry
01:A01A 90              	  3108: 		SUB		B				; Negate exponent
01:A01B 47              	  3109: 		LD		B,A				; Re-save exponent
01:A01C 7E              	  3110: 		LD		A,(HL)			; Get LSB of FPREG
01:A01D 9B              	  3111: 		SBC		A, E			; Subtract LSB of BCDE
01:A01E 5F              	  3112: 		LD		E,A				; Save LSB of BCDE
01:A01F 23              	  3113: 		INC		HL
01:A020 7E              	  3114: 		LD		A,(HL)			; Get NMSB of FPREG
01:A021 9A              	  3115: 		SBC		A,D				; Subtract NMSB of BCDE
01:A022 57              	  3116: 		LD		D,A				; Save NMSB of BCDE
01:A023 23              	  3117: 		INC		HL
01:A024 7E              	  3118: 		LD		A,(HL)			; Get MSB of FPREG
01:A025 99              	  3119: 		SBC		A,C				; Subtract MSB of BCDE
01:A026 4F              	  3120: 		LD		C,A				; Save MSB of BCDE
01:A027 DC8AA0          	  3121: CONPOS: CALL	C,COMPL			; Overflow - Make it positive
                        	  3122: 
01:A02A 68              	  3123: BNORM:	LD		L,B				; L = Exponent
01:A02B 63              	  3124: 		LD		H,E				; H = LSB
01:A02C AF              	  3125: 		XOR		A
01:A02D 47              	  3126: BNRMLP: LD		B,A				; Save bit count
01:A02E 79              	  3127: 		LD		A,C				; Get MSB
01:A02F B7              	  3128: 		OR		A				; Is it zero?
01:A030 C24CA0          	  3129: 		JP		NZ,PNORM		; No - Do it bit at a time
01:A033 4A              	  3130: 		LD		C,D				; MSB = NMSB
01:A034 54              	  3131: 		LD		D,H				; NMSB= LSB
01:A035 65              	  3132: 		LD		H,L				; LSB = VLSB
01:A036 6F              	  3133: 		LD		L,A				; VLSB= 0
01:A037 78              	  3134: 		LD		A,B				; Get exponent
01:A038 D608            	  3135: 		SUB		8				; Count 8 bits
01:A03A FEE0            	  3136: 		CP		-24-8			; Was number zero?
01:A03C C22DA0          	  3137: 		JP		NZ,BNRMLP		; No - Keep normalising
01:A03F AF              	  3138: RESZER: XOR		A				; Result is zero
01:A040 32E710          	  3139: SAVEXP: LD		(FPEXP),A		; Save result as zero
01:A043 C9              	  3140: 		RET
                        	  3141: 
01:A044 05              	  3142: NORMAL: DEC		B				; Count bits
01:A045 29              	  3143: 		ADD		HL,HL			; Shift HL left
01:A046 7A              	  3144: 		LD		A,D				; Get NMSB
01:A047 17              	  3145: 		RLA						; Shift left with last bit
01:A048 57              	  3146: 		LD		D,A				; Save NMSB
01:A049 79              	  3147: 		LD		A,C				; Get MSB
01:A04A 8F              	  3148: 		ADC		A,A				; Shift left with last bit
01:A04B 4F              	  3149: 		LD		C,A				; Save MSB
01:A04C F244A0          	  3150: PNORM:	JP		P,NORMAL		; Not done - Keep going
01:A04F 78              	  3151: 		LD		A,B				; Number of bits shifted
01:A050 5C              	  3152: 		LD		E,H				; Save HL in EB
01:A051 45              	  3153: 		LD		B,L
01:A052 B7              	  3154: 		OR		A				; Any shifting done?
01:A053 CA5FA0          	  3155: 		JP		Z,RONDUP		; No - Round it up
01:A056 21E710          	  3156: 		LD		HL,FPEXP		; Point to exponent
01:A059 86              	  3157: 		ADD		A,(HL)			; Add shifted bits
01:A05A 77              	  3158: 		LD		(HL),A			; Re-save exponent
01:A05B D23FA0          	  3159: 		JP		NC,RESZER		; Underflow - Result is zero
01:A05E C8              	  3160: 		RET		Z				; Result is zero
01:A05F 78              	  3161: RONDUP: LD		A,B				; Get VLSB of number
01:A060 21E710          	  3162: RONDB:	LD		HL,FPEXP		; Point to exponent
01:A063 B7              	  3163: 		OR		A				; Any rounding?
01:A064 FC71A0          	  3164: 		CALL	M,FPROND		; Yes - Round number up
01:A067 46              	  3165: 		LD		B,(HL)			; B = Exponent
01:A068 23              	  3166: 		INC		HL
01:A069 7E              	  3167: 		LD		A,(HL)			; Get sign of result
01:A06A E680            	  3168: 		AND		10000000B		; Only bit 7 needed
01:A06C A9              	  3169: 		XOR		C				; Set correct sign
01:A06D 4F              	  3170: 		LD		C,A				; Save correct sign in number
01:A06E C360A2          	  3171: 		JP		FPBCDE			; Move BCDE to FPREG
                        	  3172: 
01:A071 1C              	  3173: FPROND: INC		E				; Round LSB
01:A072 C0              	  3174: 		RET		NZ				; Return if ok
01:A073 14              	  3175: 		INC		D				; Round NMSB
01:A074 C0              	  3176: 		RET		NZ				; Return if ok
01:A075 0C              	  3177: 		INC		C				; Round MSB
01:A076 C0              	  3178: 		RET		NZ				; Return if ok
01:A077 0E80            	  3179: 		LD		C,80H			; Set normal value
01:A079 34              	  3180: 		INC		(HL)			; Increment exponent
01:A07A C0              	  3181: 		RET		NZ				; Return if ok
01:A07B C38B8F          	  3182: 		JP		OVERR			; Overflow error
                        	  3183: 
01:A07E 7E              	  3184: PLUCDE: LD		A,(HL)			; Get LSB of FPREG
01:A07F 83              	  3185: 		ADD		A,E				; Add LSB of BCDE
01:A080 5F              	  3186: 		LD		E,A				; Save LSB of BCDE
01:A081 23              	  3187: 		INC		HL
01:A082 7E              	  3188: 		LD		A,(HL)			; Get NMSB of FPREG
01:A083 8A              	  3189: 		ADC		A,D				; Add NMSB of BCDE
01:A084 57              	  3190: 		LD		D,A				; Save NMSB of BCDE
01:A085 23              	  3191: 		INC		HL
01:A086 7E              	  3192: 		LD		A,(HL)			; Get MSB of FPREG
01:A087 89              	  3193: 		ADC		A,C				; Add MSB of BCDE
01:A088 4F              	  3194: 		LD		C,A				; Save MSB of BCDE
01:A089 C9              	  3195: 		RET
                        	  3196: 
01:A08A 21E810          	  3197: COMPL:	LD		HL,SGNRES		; Sign of result
01:A08D 7E              	  3198: 		LD		A,(HL)			; Get sign of result
01:A08E 2F              	  3199: 		CPL						; Negate it
01:A08F 77              	  3200: 		LD		(HL),A			; Put it back
01:A090 AF              	  3201: 		XOR		A
01:A091 6F              	  3202: 		LD		L,A				; Set L to zero
01:A092 90              	  3203: 		SUB		B				; Negate exponent,set carry
01:A093 47              	  3204: 		LD		B,A				; Re-save exponent
01:A094 7D              	  3205: 		LD		A,L				; Load zero
01:A095 9B              	  3206: 		SBC		A,E				; Negate LSB
01:A096 5F              	  3207: 		LD		E,A				; Re-save LSB
01:A097 7D              	  3208: 		LD		A,L				; Load zero
01:A098 9A              	  3209: 		SBC		A,D				; Negate NMSB
01:A099 57              	  3210: 		LD		D,A				; Re-save NMSB
01:A09A 7D              	  3211: 		LD		A,L				; Load zero
01:A09B 99              	  3212: 		SBC		A,C				; Negate MSB
01:A09C 4F              	  3213: 		LD		C,A				; Re-save MSB
01:A09D C9              	  3214: 		RET
                        	  3215: 
01:A09E 0600            	  3216: SCALE:	LD		B,0				; Clear underflow
01:A0A0 D608            	  3217: SCALLP: SUB		8				; 8 bits (a whole byte)?
01:A0A2 DAADA0          	  3218: 		JP		C,SHRITE		; No - Shift right A bits
01:A0A5 43              	  3219: 		LD		B,E				; <- Shift
01:A0A6 5A              	  3220: 		LD		E,D				; <- right
01:A0A7 51              	  3221: 		LD		D,C				; <- eight
01:A0A8 0E00            	  3222: 		LD		C,0				; <- bits
01:A0AA C3A0A0          	  3223: 		JP		SCALLP			; More bits to shift
                        	  3224: 
01:A0AD C609            	  3225: SHRITE: ADD		A,8+1			; Adjust count
01:A0AF 6F              	  3226: 		LD		L,A				; Save bits to shift
01:A0B0 AF              	  3227: SHRLP:	XOR		A				; Flag for all done
01:A0B1 2D              	  3228: 		DEC		L				; All shifting done?
01:A0B2 C8              	  3229: 		RET		Z				; Yes - Return
01:A0B3 79              	  3230: 		LD		A,C				; Get MSB
01:A0B4 1F              	  3231: SHRT1:	RRA						; Shift it right
01:A0B5 4F              	  3232: 		LD		C,A				; Re-save
01:A0B6 7A              	  3233: 		LD		A,D				; Get NMSB
01:A0B7 1F              	  3234: 		RRA						; Shift right with last bit
01:A0B8 57              	  3235: 		LD		D,A				; Re-save it
01:A0B9 7B              	  3236: 		LD		A,E				; Get LSB
01:A0BA 1F              	  3237: 		RRA						; Shift right with last bit
01:A0BB 5F              	  3238: 		LD		E,A				; Re-save it
01:A0BC 78              	  3239: 		LD		A,B				; Get underflow
01:A0BD 1F              	  3240: 		RRA						; Shift right with last bit
01:A0BE 47              	  3241: 		LD		B,A				; Re-save underflow
01:A0BF C3B0A0          	  3242: 		JP		SHRLP			; More bits to do
                        	  3243: 
01:A0C2 00              	  3244: UNITY:	db		000H,000H,000H,081H	   ; 1.00000
01:A0C3 00
01:A0C4 00
01:A0C5 81
                        	  3245: 
01:A0C6 03              	  3246: LOGTAB: db	   3					   ; Table used by LOG
01:A0C7 AA              	  3247: 		db	   0AAH,056H,019H,080H	   ; 0.59898
01:A0C8 56
01:A0C9 19
01:A0CA 80
01:A0CB F1              	  3248: 		db	   0F1H,022H,076H,080H	   ; 0.96147
01:A0CC 22
01:A0CD 76
01:A0CE 80
01:A0CF 45              	  3249: 		db	   045H,0AAH,038H,082H	   ; 2.88539
01:A0D0 AA
01:A0D1 38
01:A0D2 82
                        	  3250: 
01:A0D3 CD1FA2          	  3251: LOG:	CALL	TSTSGN			; Test sign of value
01:A0D6 B7              	  3252: 		OR		A
01:A0D7 EA9E94          	  3253: 		JP		PE,FCERR		; ?FC Error if <= zero
01:A0DA 21E710          	  3254: 		LD		HL,FPEXP		; Point to exponent
01:A0DD 7E              	  3255: 		LD		A,(HL)			; Get exponent
01:A0DE 013580          	  3256: 		LD		BC,8035H		; BCDE = SQR(1/2)
01:A0E1 11F304          	  3257: 		LD		DE,04F3H
01:A0E4 90              	  3258: 		SUB		B				; Scale value to be < 1
01:A0E5 F5              	  3259: 		PUSH	AF				; Save scale factor
01:A0E6 70              	  3260: 		LD		(HL),B			; Save new exponent
01:A0E7 D5              	  3261: 		PUSH	DE				; Save SQR(1/2)
01:A0E8 C5              	  3262: 		PUSH	BC
01:A0E9 CDD99F          	  3263: 		CALL	FPADD			; Add SQR(1/2) to value
01:A0EC C1              	  3264: 		POP		BC				; Restore SQR(1/2)
01:A0ED D1              	  3265: 		POP		DE
01:A0EE 04              	  3266: 		INC		B				; Make it SQR(2)
01:A0EF CD75A1          	  3267: 		CALL	DVBCDE			; Divide by SQR(2)
01:A0F2 21C2A0          	  3268: 		LD		HL,UNITY		; Point to 1.
01:A0F5 CDD09F          	  3269: 		CALL	SUBPHL			; Subtract FPREG from 1
01:A0F8 21C6A0          	  3270: 		LD		HL,LOGTAB		; Coefficient table
01:A0FB CD67A5          	  3271: 		CALL	SUMSER			; Evaluate sum of series
01:A0FE 018080          	  3272: 		LD		BC,8080H		; BCDE = -0.5
01:A101 110000          	  3273: 		LD		DE,0000H
01:A104 CDD99F          	  3274: 		CALL	FPADD			; Subtract 0.5 from FPREG
01:A107 F1              	  3275: 		POP		AF				; Restore scale factor
01:A108 CD9AA3          	  3276: 		CALL	RSCALE			; Re-scale number
01:A10B 013180          	  3277: MULLN2: LD		BC,8031H		; BCDE = Ln(2)
01:A10E 111872          	  3278: 		LD		DE,7218H
01:A111 21              	  3279: 		db	   21H			   ; Skip "POP BC" and "POP DE"
                        	  3280: 
01:A112 C1              	  3281: MULTT:	POP		BC				; Get number from stack
01:A113 D1              	  3282: 		POP		DE
01:A114 CD1FA2          	  3283: FPMULT: CALL	TSTSGN			; Test sign of FPREG
01:A117 C8              	  3284: 		RET		Z				; Return zero if zero
01:A118 2E00            	  3285: 		LD		L,0				; Flag add exponents
01:A11A CDDDA1          	  3286: 		CALL	ADDEXP			; Add exponents
01:A11D 79              	  3287: 		LD		A,C				; Get MSB of multiplier
01:A11E 32F610          	  3288: 		LD		(MULVAL),A		; Save MSB of multiplier
01:A121 EB              	  3289: 		EX		DE,HL
01:A122 22F710          	  3290: 		LD		(MULVAL+1),HL	; Save rest of multiplier
01:A125 010000          	  3291: 		LD		BC,0			; Partial product (BCDE) = zero
01:A128 50              	  3292: 		LD		D,B
01:A129 58              	  3293: 		LD		E,B
01:A12A 212AA0          	  3294: 		LD		HL,BNORM		; Address of normalise
01:A12D E5              	  3295: 		PUSH	HL				; Save for return
01:A12E 2136A1          	  3296: 		LD		HL,MULT8		; Address of 8 bit multiply
01:A131 E5              	  3297: 		PUSH	HL				; Save for NMSB,MSB
01:A132 E5              	  3298: 		PUSH	HL				; 
01:A133 21E410          	  3299: 		LD		HL,FPREG		; Point to number
01:A136 7E              	  3300: MULT8:	LD		A,(HL)			; Get LSB of number
01:A137 23              	  3301: 		INC		HL				; Point to NMSB
01:A138 B7              	  3302: 		OR		A				; Test LSB
01:A139 CA62A1          	  3303: 		JP		Z,BYTSFT		; Zero - shift to next byte
01:A13C E5              	  3304: 		PUSH	HL				; Save address of number
01:A13D 2E08            	  3305: 		LD		L,8				; 8 bits to multiply by
01:A13F 1F              	  3306: MUL8LP: RRA						; Shift LSB right
01:A140 67              	  3307: 		LD		H,A				; Save LSB
01:A141 79              	  3308: 		LD		A,C				; Get MSB
01:A142 D250A1          	  3309: 		JP		NC,NOMADD		; Bit was zero - Don't add
01:A145 E5              	  3310: 		PUSH	HL				; Save LSB and count
01:A146 2AF710          	  3311: 		LD		HL,(MULVAL+1)	; Get LSB and NMSB
01:A149 19              	  3312: 		ADD		HL,DE			; Add NMSB and LSB
01:A14A EB              	  3313: 		EX		DE,HL			; Leave sum in DE
01:A14B E1              	  3314: 		POP		HL				; Restore MSB and count
01:A14C 3AF610          	  3315: 		LD		A,(MULVAL)		; Get MSB of multiplier
01:A14F 89              	  3316: 		ADC		A,C				; Add MSB
01:A150 1F              	  3317: NOMADD: RRA						; Shift MSB right
01:A151 4F              	  3318: 		LD		C,A				; Re-save MSB
01:A152 7A              	  3319: 		LD		A,D				; Get NMSB
01:A153 1F              	  3320: 		RRA						; Shift NMSB right
01:A154 57              	  3321: 		LD		D,A				; Re-save NMSB
01:A155 7B              	  3322: 		LD		A,E				; Get LSB
01:A156 1F              	  3323: 		RRA						; Shift LSB right
01:A157 5F              	  3324: 		LD		E,A				; Re-save LSB
01:A158 78              	  3325: 		LD		A,B				; Get VLSB
01:A159 1F              	  3326: 		RRA						; Shift VLSB right
01:A15A 47              	  3327: 		LD		B,A				; Re-save VLSB
01:A15B 2D              	  3328: 		DEC		L				; Count bits multiplied
01:A15C 7C              	  3329: 		LD		A,H				; Get LSB of multiplier
01:A15D C23FA1          	  3330: 		JP		NZ,MUL8LP		; More - Do it
01:A160 E1              	  3331: POPHRT: POP		HL				; Restore address of number
01:A161 C9              	  3332: 		RET
                        	  3333: 
01:A162 43              	  3334: BYTSFT: LD		B,E				; Shift partial product left
01:A163 5A              	  3335: 		LD		E,D
01:A164 51              	  3336: 		LD		D,C
01:A165 4F              	  3337: 		LD		C,A
01:A166 C9              	  3338: 		RET
                        	  3339: 
01:A167 CD50A2          	  3340: DIV10:	CALL	STAKFP			; Save FPREG on stack
01:A16A 012084          	  3341: 		LD		BC,8420H		; BCDE = 10.
01:A16D 110000          	  3342: 		LD		DE,0000H
01:A170 CD60A2          	  3343: 		CALL	FPBCDE			; Move 10 to FPREG
                        	  3344: 
01:A173 C1              	  3345: DIV:	POP		BC				; Get number from stack
01:A174 D1              	  3346: 		POP		DE
01:A175 CD1FA2          	  3347: DVBCDE: CALL	TSTSGN			; Test sign of FPREG
01:A178 CA7F8F          	  3348: 		JP		Z,DZERR			; Error if division by zero
01:A17B 2EFF            	  3349: 		LD		L,-1			; Flag subtract exponents
01:A17D CDDDA1          	  3350: 		CALL	ADDEXP			; Subtract exponents
01:A180 34              	  3351: 		INC		(HL)			; Add 2 to exponent to adjust
01:A181 34              	  3352: 		INC		(HL)
01:A182 2B              	  3353: 		DEC		HL				; Point to MSB
01:A183 7E              	  3354: 		LD		A,(HL)			; Get MSB of dividend
01:A184 321210          	  3355: 		LD		(DIV3),A		; Save for subtraction
01:A187 2B              	  3356: 		DEC		HL
01:A188 7E              	  3357: 		LD		A,(HL)			; Get NMSB of dividend
01:A189 320E10          	  3358: 		LD		(DIV2),A		; Save for subtraction
01:A18C 2B              	  3359: 		DEC		HL
01:A18D 7E              	  3360: 		LD		A,(HL)			; Get MSB of dividend
01:A18E 320A10          	  3361: 		LD		(DIV1),A		; Save for subtraction
01:A191 41              	  3362: 		LD		B,C				; Get MSB
01:A192 EB              	  3363: 		EX		DE,HL			; NMSB,LSB to HL
01:A193 AF              	  3364: 		XOR		A
01:A194 4F              	  3365: 		LD		C,A				; Clear MSB of quotient
01:A195 57              	  3366: 		LD		D,A				; Clear NMSB of quotient
01:A196 5F              	  3367: 		LD		E,A				; Clear LSB of quotient
01:A197 321510          	  3368: 		LD		(DIV4),A		; Clear overflow count
01:A19A E5              	  3369: DIVLP:	PUSH	HL				; Save divisor
01:A19B C5              	  3370: 		PUSH	BC
01:A19C 7D              	  3371: 		LD		A,L				; Get LSB of number
01:A19D CD0910          	  3372: 		CALL	DIVSUP			; Subt' divisor from dividend
01:A1A0 DE00            	  3373: 		SBC		A,0				; Count for overflows
01:A1A2 3F              	  3374: 		CCF
01:A1A3 D2ADA1          	  3375: 		JP		NC,RESDIV		; Restore divisor if borrow
01:A1A6 321510          	  3376: 		LD		(DIV4),A		; Re-save overflow count
01:A1A9 F1              	  3377: 		POP		AF				; Scrap divisor
01:A1AA F1              	  3378: 		POP		AF
01:A1AB 37              	  3379: 		SCF						; Set carry to
01:A1AC D2              	  3380: 		db	   0D2H			   ; Skip "POP BC" and "POP HL"
                        	  3381: 
01:A1AD C1              	  3382: RESDIV: POP		BC				; Restore divisor
01:A1AE E1              	  3383: 		POP		HL
01:A1AF 79              	  3384: 		LD		A,C				; Get MSB of quotient
01:A1B0 3C              	  3385: 		INC		A
01:A1B1 3D              	  3386: 		DEC		A
01:A1B2 1F              	  3387: 		RRA						; Bit 0 to bit 7
01:A1B3 FA60A0          	  3388: 		JP		M,RONDB			; Done - Normalise result
01:A1B6 17              	  3389: 		RLA						; Restore carry
01:A1B7 7B              	  3390: 		LD		A,E				; Get LSB of quotient
01:A1B8 17              	  3391: 		RLA						; Double it
01:A1B9 5F              	  3392: 		LD		E,A				; Put it back
01:A1BA 7A              	  3393: 		LD		A,D				; Get NMSB of quotient
01:A1BB 17              	  3394: 		RLA						; Double it
01:A1BC 57              	  3395: 		LD		D,A				; Put it back
01:A1BD 79              	  3396: 		LD		A,C				; Get MSB of quotient
01:A1BE 17              	  3397: 		RLA						; Double it
01:A1BF 4F              	  3398: 		LD		C,A				; Put it back
01:A1C0 29              	  3399: 		ADD		HL,HL			; Double NMSB,LSB of divisor
01:A1C1 78              	  3400: 		LD		A,B				; Get MSB of divisor
01:A1C2 17              	  3401: 		RLA						; Double it
01:A1C3 47              	  3402: 		LD		B,A				; Put it back
01:A1C4 3A1510          	  3403: 		LD		A,(DIV4)		; Get VLSB of quotient
01:A1C7 17              	  3404: 		RLA						; Double it
01:A1C8 321510          	  3405: 		LD		(DIV4),A		; Put it back
01:A1CB 79              	  3406: 		LD		A,C				; Get MSB of quotient
01:A1CC B2              	  3407: 		OR		D				; Merge NMSB
01:A1CD B3              	  3408: 		OR		E				; Merge LSB
01:A1CE C29AA1          	  3409: 		JP		NZ,DIVLP		; Not done - Keep dividing
01:A1D1 E5              	  3410: 		PUSH	HL				; Save divisor
01:A1D2 21E710          	  3411: 		LD		HL,FPEXP		; Point to exponent
01:A1D5 35              	  3412: 		DEC		(HL)			; Divide by 2
01:A1D6 E1              	  3413: 		POP		HL				; Restore divisor
01:A1D7 C29AA1          	  3414: 		JP		NZ,DIVLP		; Ok - Keep going
01:A1DA C38B8F          	  3415: 		JP		OVERR			; Overflow error
                        	  3416: 
01:A1DD 78              	  3417: ADDEXP: LD		A,B				; Get exponent of dividend
01:A1DE B7              	  3418: 		OR		A				; Test it
01:A1DF CA01A2          	  3419: 		JP		Z,OVTST3		; Zero - Result zero
01:A1E2 7D              	  3420: 		LD		A,L				; Get add/subtract flag
01:A1E3 21E710          	  3421: 		LD		HL,FPEXP		; Point to exponent
01:A1E6 AE              	  3422: 		XOR		(HL)			; Add or subtract it
01:A1E7 80              	  3423: 		ADD		A,B				; Add the other exponent
01:A1E8 47              	  3424: 		LD		B,A				; Save new exponent
01:A1E9 1F              	  3425: 		RRA						; Test exponent for overflow
01:A1EA A8              	  3426: 		XOR		B
01:A1EB 78              	  3427: 		LD		A,B				; Get exponent
01:A1EC F200A2          	  3428: 		JP		P,OVTST2		; Positive - Test for overflow
01:A1EF C680            	  3429: 		ADD		A,80H			; Add excess 128
01:A1F1 77              	  3430: 		LD		(HL),A			; Save new exponent
01:A1F2 CA60A1          	  3431: 		JP		Z,POPHRT		; Zero - Result zero
01:A1F5 CD85A2          	  3432: 		CALL	SIGNS			; Set MSBs and sign of result
01:A1F8 77              	  3433: 		LD		(HL),A			; Save new exponent
01:A1F9 2B              	  3434: 		DEC		HL				; Point to MSB
01:A1FA C9              	  3435: 		RET
                        	  3436: 
01:A1FB CD1FA2          	  3437: OVTST1: CALL	TSTSGN			; Test sign of FPREG
01:A1FE 2F              	  3438: 		CPL						; Invert sign
01:A1FF E1              	  3439: 		POP		HL				; Clean up stack
01:A200 B7              	  3440: OVTST2: OR		A				; Test if new exponent zero
01:A201 E1              	  3441: OVTST3: POP		HL				; Clear off return address
01:A202 F23FA0          	  3442: 		JP		P,RESZER		; Result zero
01:A205 C38B8F          	  3443: 		JP		OVERR			; Overflow error
                        	  3444: 
01:A208 CD6BA2          	  3445: MLSP10: CALL	BCDEFP			; Move FPREG to BCDE
01:A20B 78              	  3446: 		LD		A,B				; Get exponent
01:A20C B7              	  3447: 		OR		A				; Is it zero?
01:A20D C8              	  3448: 		RET		Z				; Yes - Result is zero
01:A20E C602            	  3449: 		ADD		A,2				; Multiply by 4
01:A210 DA8B8F          	  3450: 		JP		C,OVERR			; Overflow - ?OV Error
01:A213 47              	  3451: 		LD		B,A				; Re-save exponent
01:A214 CDD99F          	  3452: 		CALL	FPADD			; Add BCDE to FPREG (Times 5)
01:A217 21E710          	  3453: 		LD		HL,FPEXP		; Point to exponent
01:A21A 34              	  3454: 		INC		(HL)			; Double number (Times 10)
01:A21B C0              	  3455: 		RET		NZ				; Ok - Return
01:A21C C38B8F          	  3456: 		JP		OVERR			; Overflow error
                        	  3457: 
01:A21F 3AE710          	  3458: TSTSGN: LD		A,(FPEXP)		; Get sign of FPREG
01:A222 B7              	  3459: 		OR		A
01:A223 C8              	  3460: 		RET		Z				; RETurn if number is zero
01:A224 3AE610          	  3461: 		LD		A,(FPREG+2)		; Get MSB of FPREG
01:A227 FE              	  3462: 		db	   0FEH			   ; Test sign
01:A228 2F              	  3463: RETREL: CPL						; Invert sign
01:A229 17              	  3464: 		RLA						; Sign bit to carry
01:A22A 9F              	  3465: FLGDIF: SBC		A,A				; Carry to all bits of A
01:A22B C0              	  3466: 		RET		NZ				; Return -1 if negative
01:A22C 3C              	  3467: 		INC		A				; Bump to +1
01:A22D C9              	  3468: 		RET						; Positive - Return +1
                        	  3469: 
01:A22E CD1FA2          	  3470: SGN:	CALL	TSTSGN			; Test sign of FPREG
01:A231 0688            	  3471: FLGREL: LD		B,80H+8			; 8 bit integer in exponent
01:A233 110000          	  3472: 		LD		DE,0			; Zero NMSB and LSB
01:A236 21E710          	  3473: RETINT: LD		HL,FPEXP		; Point to exponent
01:A239 4F              	  3474: 		LD		C,A				; CDE = MSB,NMSB and LSB
01:A23A 70              	  3475: 		LD		(HL),B			; Save exponent
01:A23B 0600            	  3476: 		LD		B,0				; CDE = integer to normalise
01:A23D 23              	  3477: 		INC		HL				; Point to sign of result
01:A23E 3680            	  3478: 		LD		(HL),80H		; Set sign of result
01:A240 17              	  3479: 		RLA						; Carry = sign of integer
01:A241 C327A0          	  3480: 		JP		CONPOS			; Set sign of result
                        	  3481: 
01:A244 CD1FA2          	  3482: ABS:	CALL	TSTSGN			; Test sign of FPREG
01:A247 F0              	  3483: 		RET		P				; Return if positive
01:A248 21E610          	  3484: INVSGN: LD		HL,FPREG+2		; Point to MSB
01:A24B 7E              	  3485: 		LD		A,(HL)			; Get sign of mantissa
01:A24C EE80            	  3486: 		XOR		80H				; Invert sign of mantissa
01:A24E 77              	  3487: 		LD		(HL),A			; Re-save sign of mantissa
01:A24F C9              	  3488: 		RET
                        	  3489: 
01:A250 EB              	  3490: STAKFP: EX		DE,HL			; Save code string address
01:A251 2AE410          	  3491: 		LD		HL,(FPREG)		; LSB,NLSB of FPREG
01:A254 E3              	  3492: 		EX		(SP),HL			; Stack them,get return
01:A255 E5              	  3493: 		PUSH	HL				; Re-save return
01:A256 2AE610          	  3494: 		LD		HL,(FPREG+2)	; MSB and exponent of FPREG
01:A259 E3              	  3495: 		EX		(SP),HL			; Stack them,get return
01:A25A E5              	  3496: 		PUSH	HL				; Re-save return
01:A25B EB              	  3497: 		EX		DE,HL			; Restore code string address
01:A25C C9              	  3498: 		RET
                        	  3499: 
01:A25D CD6EA2          	  3500: PHLTFP: CALL	LOADFP			; Number at HL to BCDE
01:A260 EB              	  3501: FPBCDE: EX		DE,HL			; Save code string address
01:A261 22E410          	  3502: 		LD		(FPREG),HL		; Save LSB,NLSB of number
01:A264 60              	  3503: 		LD		H,B				; Exponent of number
01:A265 69              	  3504: 		LD		L,C				; MSB of number
01:A266 22E610          	  3505: 		LD		(FPREG+2),HL	; Save MSB and exponent
01:A269 EB              	  3506: 		EX		DE,HL			; Restore code string address
01:A26A C9              	  3507: 		RET
                        	  3508: 
01:A26B 21E410          	  3509: BCDEFP: LD		HL,FPREG		; Point to FPREG
01:A26E 5E              	  3510: LOADFP: LD		E,(HL)			; Get LSB of number
01:A26F 23              	  3511: 		INC		HL
01:A270 56              	  3512: 		LD		D,(HL)			; Get NMSB of number
01:A271 23              	  3513: 		INC		HL
01:A272 4E              	  3514: 		LD		C,(HL)			; Get MSB of number
01:A273 23              	  3515: 		INC		HL
01:A274 46              	  3516: 		LD		B,(HL)			; Get exponent of number
01:A275 23              	  3517: INCHL:	INC		HL				; Used for conditional "INC HL"
01:A276 C9              	  3518: 		RET
                        	  3519: 
01:A277 11E410          	  3520: FPTHL:	LD		DE,FPREG		; Point to FPREG
01:A27A 0604            	  3521: DETHL4: LD		B,4				; 4 bytes to move
01:A27C 1A              	  3522: DETHLB: LD		A,(DE)			; Get source
01:A27D 77              	  3523: 		LD		(HL),A			; Save destination
01:A27E 13              	  3524: 		INC		DE				; Next source
01:A27F 23              	  3525: 		INC		HL				; Next destination
01:A280 05              	  3526: 		DEC		B				; Count bytes
01:A281 C27CA2          	  3527: 		JP		NZ,DETHLB		; Loop if more
01:A284 C9              	  3528: 		RET
                        	  3529: 
01:A285 21E610          	  3530: SIGNS:	LD		HL,FPREG+2		; Point to MSB of FPREG
01:A288 7E              	  3531: 		LD		A,(HL)			; Get MSB
01:A289 07              	  3532: 		RLCA					; Old sign to carry
01:A28A 37              	  3533: 		SCF						; Set MSBit
01:A28B 1F              	  3534: 		RRA						; Set MSBit of MSB
01:A28C 77              	  3535: 		LD		(HL),A			; Save new MSB
01:A28D 3F              	  3536: 		CCF						; Complement sign
01:A28E 1F              	  3537: 		RRA						; Old sign to carry
01:A28F 23              	  3538: 		INC		HL
01:A290 23              	  3539: 		INC		HL
01:A291 77              	  3540: 		LD		(HL),A			; Set sign of result
01:A292 79              	  3541: 		LD		A,C				; Get MSB
01:A293 07              	  3542: 		RLCA					; Old sign to carry
01:A294 37              	  3543: 		SCF						; Set MSBit
01:A295 1F              	  3544: 		RRA						; Set MSBit of MSB
01:A296 4F              	  3545: 		LD		C,A				; Save MSB
01:A297 1F              	  3546: 		RRA
01:A298 AE              	  3547: 		XOR		(HL)			; New sign of result
01:A299 C9              	  3548: 		RET
                        	  3549: 
01:A29A 78              	  3550: CMPNUM: LD		A,B				; Get exponent of number
01:A29B B7              	  3551: 		OR		A
01:A29C CA1FA2          	  3552: 		JP		Z,TSTSGN		; Zero - Test sign of FPREG
01:A29F 2128A2          	  3553: 		LD		HL,RETREL		; Return relation routine
01:A2A2 E5              	  3554: 		PUSH	HL				; Save for return
01:A2A3 CD1FA2          	  3555: 		CALL	TSTSGN			; Test sign of FPREG
01:A2A6 79              	  3556: 		LD		A,C				; Get MSB of number
01:A2A7 C8              	  3557: 		RET		Z				; FPREG zero - Number's MSB
01:A2A8 21E610          	  3558: 		LD		HL,FPREG+2		; MSB of FPREG
01:A2AB AE              	  3559: 		XOR		(HL)			; Combine signs
01:A2AC 79              	  3560: 		LD		A,C				; Get MSB of number
01:A2AD F8              	  3561: 		RET		M				; Exit if signs different
01:A2AE CDB4A2          	  3562: 		CALL	CMPFP			; Compare FP numbers
01:A2B1 1F              	  3563: 		RRA						; Get carry to sign
01:A2B2 A9              	  3564: 		XOR		C				; Combine with MSB of number
01:A2B3 C9              	  3565: 		RET
                        	  3566: 
01:A2B4 23              	  3567: CMPFP:	INC		HL				; Point to exponent
01:A2B5 78              	  3568: 		LD		A,B				; Get exponent
01:A2B6 BE              	  3569: 		CP		(HL)			; Compare exponents
01:A2B7 C0              	  3570: 		RET		NZ				; Different
01:A2B8 2B              	  3571: 		DEC		HL				; Point to MBS
01:A2B9 79              	  3572: 		LD		A,C				; Get MSB
01:A2BA BE              	  3573: 		CP		(HL)			; Compare MSBs
01:A2BB C0              	  3574: 		RET		NZ				; Different
01:A2BC 2B              	  3575: 		DEC		HL				; Point to NMSB
01:A2BD 7A              	  3576: 		LD		A,D				; Get NMSB
01:A2BE BE              	  3577: 		CP		(HL)			; Compare NMSBs
01:A2BF C0              	  3578: 		RET		NZ				; Different
01:A2C0 2B              	  3579: 		DEC		HL				; Point to LSB
01:A2C1 7B              	  3580: 		LD		A,E				; Get LSB
01:A2C2 96              	  3581: 		SUB		(HL)			; Compare LSBs
01:A2C3 C0              	  3582: 		RET		NZ				; Different
01:A2C4 E1              	  3583: 		POP		HL				; Drop RETurn
01:A2C5 E1              	  3584: 		POP		HL				; Drop another RETurn
01:A2C6 C9              	  3585: 		RET
                        	  3586: 
01:A2C7 47              	  3587: FPINT:	LD		B,A				; <- Move
01:A2C8 4F              	  3588: 		LD		C,A				; <- exponent
01:A2C9 57              	  3589: 		LD		D,A				; <- to all
01:A2CA 5F              	  3590: 		LD		E,A				; <- bits
01:A2CB B7              	  3591: 		OR		A				; Test exponent
01:A2CC C8              	  3592: 		RET		Z				; Zero - Return zero
01:A2CD E5              	  3593: 		PUSH	HL				; Save pointer to number
01:A2CE CD6BA2          	  3594: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A2D1 CD85A2          	  3595: 		CALL	SIGNS			; Set MSBs & sign of result
01:A2D4 AE              	  3596: 		XOR		(HL)			; Combine with sign of FPREG
01:A2D5 67              	  3597: 		LD		H,A				; Save combined signs
01:A2D6 FCEBA2          	  3598: 		CALL	M,DCBCDE		; Negative - Decrement BCDE
01:A2D9 3E98            	  3599: 		LD		A,80H+24		; 24 bits
01:A2DB 90              	  3600: 		SUB		B				; Bits to shift
01:A2DC CD9EA0          	  3601: 		CALL	SCALE			; Shift BCDE
01:A2DF 7C              	  3602: 		LD		A,H				; Get combined sign
01:A2E0 17              	  3603: 		RLA						; Sign to carry
01:A2E1 DC71A0          	  3604: 		CALL	C,FPROND		; Negative - Round number up
01:A2E4 0600            	  3605: 		LD		B,0				; Zero exponent
01:A2E6 DC8AA0          	  3606: 		CALL	C,COMPL			; If negative make positive
01:A2E9 E1              	  3607: 		POP		HL				; Restore pointer to number
01:A2EA C9              	  3608: 		RET
                        	  3609: 
01:A2EB 1B              	  3610: DCBCDE: DEC		DE				; Decrement BCDE
01:A2EC 7A              	  3611: 		LD		A,D				; Test LSBs
01:A2ED A3              	  3612: 		AND		E
01:A2EE 3C              	  3613: 		INC		A
01:A2EF C0              	  3614: 		RET		NZ				; Exit if LSBs not FFFF
01:A2F0 0B              	  3615: 		DEC		BC				; Decrement MSBs
01:A2F1 C9              	  3616: 		RET
                        	  3617: 
01:A2F2 21E710          	  3618: INT:	LD		HL,FPEXP		; Point to exponent
01:A2F5 7E              	  3619: 		LD		A,(HL)			; Get exponent
01:A2F6 FE98            	  3620: 		CP		80H+24			; Integer accuracy only?
01:A2F8 3AE410          	  3621: 		LD		A,(FPREG)		; Get LSB
01:A2FB D0              	  3622: 		RET		NC				; Yes - Already integer
01:A2FC 7E              	  3623: 		LD		A,(HL)			; Get exponent
01:A2FD CDC7A2          	  3624: 		CALL	FPINT			; F.P to integer
01:A300 3698            	  3625: 		LD		(HL),80H+24		; Save 24 bit integer
01:A302 7B              	  3626: 		LD		A,E				; Get LSB of number
01:A303 F5              	  3627: 		PUSH	AF				; Save LSB
01:A304 79              	  3628: 		LD		A,C				; Get MSB of number
01:A305 17              	  3629: 		RLA						; Sign to carry
01:A306 CD27A0          	  3630: 		CALL	CONPOS			; Set sign of result
01:A309 F1              	  3631: 		POP		AF				; Restore LSB of number
01:A30A C9              	  3632: 		RET
                        	  3633: 
01:A30B 210000          	  3634: MLDEBC: LD		HL,0			; Clear partial product
01:A30E 78              	  3635: 		LD		A,B				; Test multiplier
01:A30F B1              	  3636: 		OR		C
01:A310 C8              	  3637: 		RET		Z				; Return zero if zero
01:A311 3E10            	  3638: 		LD		A,16			; 16 bits
01:A313 29              	  3639: MLDBLP: ADD		HL,HL			; Shift P.P left
01:A314 DA4B9B          	  3640: 		JP		C,BSERR			; ?BS Error if overflow
01:A317 EB              	  3641: 		EX		DE,HL
01:A318 29              	  3642: 		ADD		HL,HL			; Shift multiplier left
01:A319 EB              	  3643: 		EX		DE,HL
01:A31A D221A3          	  3644: 		JP		NC,NOMLAD		; Bit was zero - No add
01:A31D 09              	  3645: 		ADD		HL,BC			; Add multiplicand
01:A31E DA4B9B          	  3646: 		JP		C,BSERR			; ?BS Error if overflow
01:A321 3D              	  3647: NOMLAD: DEC		A				; Count bits
01:A322 C213A3          	  3648: 		JP		NZ,MLDBLP		; More
01:A325 C9              	  3649: 		RET
                        	  3650: 
01:A326 FE2D            	  3651: ASCTFP: CP		'-'				; Negative?
01:A328 F5              	  3652: 		PUSH	AF				; Save it and flags
01:A329 CA32A3          	  3653: 		JP		Z,CNVNUM		; Yes - Convert number
01:A32C FE2B            	  3654: 		CP		'+'				; Positive?
01:A32E CA32A3          	  3655: 		JP		Z,CNVNUM		; Yes - Convert number
01:A331 2B              	  3656: 		DEC		HL				; DEC 'cos GETCHR INCs
01:A332 CD3FA0          	  3657: CNVNUM: CALL	RESZER			; Set result to zero
01:A335 47              	  3658: 		LD		B,A				; Digits after point counter
01:A336 57              	  3659: 		LD		D,A				; Sign of exponent
01:A337 5F              	  3660: 		LD		E,A				; Exponent of ten
01:A338 2F              	  3661: 		CPL
01:A339 4F              	  3662: 		LD		C,A				; Before or after point flag
01:A33A CDD493          	  3663: MANLP:	CALL	GETCHR			; Get next character
01:A33D DA83A3          	  3664: 		JP		C,ADDIG			; Digit - Add to number
01:A340 FE2E            	  3665: 		CP		'.'
01:A342 CA5EA3          	  3666: 		JP		Z,DPOINT		; '.' - Flag point
01:A345 FE45            	  3667: 		CP		'E'
01:A347 C262A3          	  3668: 		JP		NZ,CONEXP		; Not 'E' - Scale number
01:A34A CDD493          	  3669: 		CALL	GETCHR			; Get next character
01:A34D CD7699          	  3670: 		CALL	SGNEXP			; Get sign of exponent
01:A350 CDD493          	  3671: EXPLP:	CALL	GETCHR			; Get next character
01:A353 DAA5A3          	  3672: 		JP		C,EDIGIT		; Digit - Add to exponent
01:A356 14              	  3673: 		INC		D				; Is sign negative?
01:A357 C262A3          	  3674: 		JP		NZ,CONEXP		; No - Scale number
01:A35A AF              	  3675: 		XOR		A
01:A35B 93              	  3676: 		SUB		E				; Negate exponent
01:A35C 5F              	  3677: 		LD		E,A				; And re-save it
01:A35D 0C              	  3678: 		INC		C				; Flag end of number
01:A35E 0C              	  3679: DPOINT: INC		C				; Flag point passed
01:A35F CA3AA3          	  3680: 		JP		Z,MANLP			; Zero - Get another digit
01:A362 E5              	  3681: CONEXP: PUSH	HL				; Save code string address
01:A363 7B              	  3682: 		LD		A,E				; Get exponent
01:A364 90              	  3683: 		SUB		B				; Subtract digits after point
01:A365 F47BA3          	  3684: SCALMI: CALL	P,SCALPL		; Positive - Multiply number
01:A368 F271A3          	  3685: 		JP		P,ENDCON		; Positive - All done
01:A36B F5              	  3686: 		PUSH	AF				; Save number of times to /10
01:A36C CD67A1          	  3687: 		CALL	DIV10			; Divide by 10
01:A36F F1              	  3688: 		POP		AF				; Restore count
01:A370 3C              	  3689: 		INC		A				; Count divides
                        	  3690: 
01:A371 C265A3          	  3691: ENDCON: JP		NZ,SCALMI		; More to do
01:A374 D1              	  3692: 		POP		DE				; Restore code string address
01:A375 F1              	  3693: 		POP		AF				; Restore sign of number
01:A376 CC48A2          	  3694: 		CALL	Z,INVSGN		; Negative - Negate number
01:A379 EB              	  3695: 		EX		DE,HL			; Code string address to HL
01:A37A C9              	  3696: 		RET
                        	  3697: 
01:A37B C8              	  3698: SCALPL: RET		Z				; Exit if no scaling needed
01:A37C F5              	  3699: MULTEN: PUSH	AF				; Save count
01:A37D CD08A2          	  3700: 		CALL	MLSP10			; Multiply number by 10
01:A380 F1              	  3701: 		POP		AF				; Restore count
01:A381 3D              	  3702: 		DEC		A				; Count multiplies
01:A382 C9              	  3703: 		RET
                        	  3704: 
01:A383 D5              	  3705: ADDIG:	PUSH	DE				; Save sign of exponent
01:A384 57              	  3706: 		LD		D,A				; Save digit
01:A385 78              	  3707: 		LD		A,B				; Get digits after point
01:A386 89              	  3708: 		ADC		A,C				; Add one if after point
01:A387 47              	  3709: 		LD		B,A				; Re-save counter
01:A388 C5              	  3710: 		PUSH	BC				; Save point flags
01:A389 E5              	  3711: 		PUSH	HL				; Save code string address
01:A38A D5              	  3712: 		PUSH	DE				; Save digit
01:A38B CD08A2          	  3713: 		CALL	MLSP10			; Multiply number by 10
01:A38E F1              	  3714: 		POP		AF				; Restore digit
01:A38F D630            	  3715: 		SUB		'0'				; Make it absolute
01:A391 CD9AA3          	  3716: 		CALL	RSCALE			; Re-scale number
01:A394 E1              	  3717: 		POP		HL				; Restore code string address
01:A395 C1              	  3718: 		POP		BC				; Restore point flags
01:A396 D1              	  3719: 		POP		DE				; Restore sign of exponent
01:A397 C33AA3          	  3720: 		JP		MANLP			; Get another digit
                        	  3721: 
01:A39A CD50A2          	  3722: RSCALE: CALL	STAKFP			; Put number on stack
01:A39D CD31A2          	  3723: 		CALL	FLGREL			; Digit to add to FPREG
01:A3A0 C1              	  3724: PADD:	POP		BC				; Restore number
01:A3A1 D1              	  3725: 		POP		DE
01:A3A2 C3D99F          	  3726: 		JP		FPADD			; Add BCDE to FPREG and return
                        	  3727: 
01:A3A5 7B              	  3728: EDIGIT: LD		A,E				; Get digit
01:A3A6 07              	  3729: 		RLCA					; Times 2
01:A3A7 07              	  3730: 		RLCA					; Times 4
01:A3A8 83              	  3731: 		ADD		A,E				; Times 5
01:A3A9 07              	  3732: 		RLCA					; Times 10
01:A3AA 86              	  3733: 		ADD		A,(HL)			; Add next digit
01:A3AB D630            	  3734: 		SUB		'0'				; Make it absolute
01:A3AD 5F              	  3735: 		LD		E,A				; Save new digit
01:A3AE C350A3          	  3736: 		JP		EXPLP			; Look for another digit
                        	  3737: 
01:A3B1 E5              	  3738: LINEIN: PUSH	HL				; Save code string address
01:A3B2 21148F          	  3739: 		LD		HL,INMSG		; Output " in "
01:A3B5 CD169D          	  3740: 		CALL	PRS				; Output string at HL
01:A3B8 E1              	  3741: 		POP		HL				; Restore code string address
01:A3B9 EB              	  3742: PRNTHL: EX		DE,HL			; Code string address to DE
01:A3BA AF              	  3743: 		XOR		A
01:A3BB 0698            	  3744: 		LD		B,80H+24		; 24 bits
01:A3BD CD36A2          	  3745: 		CALL	RETINT			; Return the integer
01:A3C0 21159D          	  3746: 		LD		HL,PRNUMS		; Print number string
01:A3C3 E5              	  3747: 		PUSH	HL				; Save for return
01:A3C4 21E910          	  3748: NUMASC: LD		HL,PBUFF		; Convert number to ASCII
01:A3C7 E5              	  3749: 		PUSH	HL				; Save for return
01:A3C8 CD1FA2          	  3750: 		CALL	TSTSGN			; Test sign of FPREG
01:A3CB 3620            	  3751: 		LD		(HL),' '		; Space at start
01:A3CD F2D2A3          	  3752: 		JP		P,SPCFST		; Positive - Space to start
01:A3D0 362D            	  3753: 		LD		(HL),'-'		; '-' sign at start
01:A3D2 23              	  3754: SPCFST: INC		HL				; First byte of number
01:A3D3 3630            	  3755: 		LD		(HL),'0'		; '0' if zero
01:A3D5 CA88A4          	  3756: 		JP		Z,JSTZER		; Return '0' if zero
01:A3D8 E5              	  3757: 		PUSH	HL				; Save buffer address
01:A3D9 FC48A2          	  3758: 		CALL	M,INVSGN		; Negate FPREG if negative
01:A3DC AF              	  3759: 		XOR		A				; Zero A
01:A3DD F5              	  3760: 		PUSH	AF				; Save it
01:A3DE CD8EA4          	  3761: 		CALL	RNGTST			; Test number is in range
01:A3E1 014391          	  3762: SIXDIG: LD		BC,9143H		; BCDE - 99999.9
01:A3E4 11F84F          	  3763: 		LD		DE,4FF8H
01:A3E7 CD9AA2          	  3764: 		CALL	CMPNUM			; Compare numbers
01:A3EA B7              	  3765: 		OR		A
01:A3EB E2FFA3          	  3766: 		JP		PO,INRNG		; > 99999.9 - Sort it out
01:A3EE F1              	  3767: 		POP		AF				; Restore count
01:A3EF CD7CA3          	  3768: 		CALL	MULTEN			; Multiply by ten
01:A3F2 F5              	  3769: 		PUSH	AF				; Re-save count
01:A3F3 C3E1A3          	  3770: 		JP		SIXDIG			; Test it again
                        	  3771: 
01:A3F6 CD67A1          	  3772: GTSIXD: CALL	DIV10			; Divide by 10
01:A3F9 F1              	  3773: 		POP		AF				; Get count
01:A3FA 3C              	  3774: 		INC		A				; Count divides
01:A3FB F5              	  3775: 		PUSH	AF				; Re-save count
01:A3FC CD8EA4          	  3776: 		CALL	RNGTST			; Test number is in range
01:A3FF CDC79F          	  3777: INRNG:	CALL	ROUND			; Add 0.5 to FPREG
01:A402 3C              	  3778: 		INC		A
01:A403 CDC7A2          	  3779: 		CALL	FPINT			; F.P to integer
01:A406 CD60A2          	  3780: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A409 010603          	  3781: 		LD		BC,0306H		; 1E+06 to 1E-03 range
01:A40C F1              	  3782: 		POP		AF				; Restore count
01:A40D 81              	  3783: 		ADD		A,C				; 6 digits before point
01:A40E 3C              	  3784: 		INC		A				; Add one
01:A40F FA1BA4          	  3785: 		JP		M,MAKNUM		; Do it in 'E' form if < 1E-02
01:A412 FE08            	  3786: 		CP		6+1+1			; More than 999999 ?
01:A414 D21BA4          	  3787: 		JP		NC,MAKNUM		; Yes - Do it in 'E' form
01:A417 3C              	  3788: 		INC		A				; Adjust for exponent
01:A418 47              	  3789: 		LD		B,A				; Exponent of number
01:A419 3E02            	  3790: 		LD		A,2				; Make it zero after
                        	  3791: 
01:A41B 3D              	  3792: MAKNUM: DEC		A				; Adjust for digits to do
01:A41C 3D              	  3793: 		DEC		A
01:A41D E1              	  3794: 		POP		HL				; Restore buffer address
01:A41E F5              	  3795: 		PUSH	AF				; Save count
01:A41F 11A1A4          	  3796: 		LD		DE,POWERS		; Powers of ten
01:A422 05              	  3797: 		DEC		B				; Count digits before point
01:A423 C22CA4          	  3798: 		JP		NZ,DIGTXT		; Not zero - Do number
01:A426 362E            	  3799: 		LD		(HL),'.'		; Save point
01:A428 23              	  3800: 		INC		HL				; Move on
01:A429 3630            	  3801: 		LD		(HL),'0'		; Save zero
01:A42B 23              	  3802: 		INC		HL				; Move on
01:A42C 05              	  3803: DIGTXT: DEC		B				; Count digits before point
01:A42D 362E            	  3804: 		LD		(HL),'.'		; Save point in case
01:A42F CC75A2          	  3805: 		CALL	Z,INCHL			; Last digit - move on
01:A432 C5              	  3806: 		PUSH	BC				; Save digits before point
01:A433 E5              	  3807: 		PUSH	HL				; Save buffer address
01:A434 D5              	  3808: 		PUSH	DE				; Save powers of ten
01:A435 CD6BA2          	  3809: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A438 E1              	  3810: 		POP		HL				; Powers of ten table
01:A439 062F            	  3811: 		LD		B, '0'-1		; ASCII '0' - 1
01:A43B 04              	  3812: TRYAGN: INC		B				; Count subtractions
01:A43C 7B              	  3813: 		LD		A,E				; Get LSB
01:A43D 96              	  3814: 		SUB		(HL)			; Subtract LSB
01:A43E 5F              	  3815: 		LD		E,A				; Save LSB
01:A43F 23              	  3816: 		INC		HL
01:A440 7A              	  3817: 		LD		A,D				; Get NMSB
01:A441 9E              	  3818: 		SBC		A,(HL)			; Subtract NMSB
01:A442 57              	  3819: 		LD		D,A				; Save NMSB
01:A443 23              	  3820: 		INC		HL
01:A444 79              	  3821: 		LD		A,C				; Get MSB
01:A445 9E              	  3822: 		SBC		A,(HL)			; Subtract MSB
01:A446 4F              	  3823: 		LD		C,A				; Save MSB
01:A447 2B              	  3824: 		DEC		HL				; Point back to start
01:A448 2B              	  3825: 		DEC		HL
01:A449 D23BA4          	  3826: 		JP		NC,TRYAGN		; No overflow - Try again
01:A44C CD7EA0          	  3827: 		CALL	PLUCDE			; Restore number
01:A44F 23              	  3828: 		INC		HL				; Start of next number
01:A450 CD60A2          	  3829: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A453 EB              	  3830: 		EX		DE,HL			; Save point in table
01:A454 E1              	  3831: 		POP		HL				; Restore buffer address
01:A455 70              	  3832: 		LD		(HL),B			; Save digit in buffer
01:A456 23              	  3833: 		INC		HL				; And move on
01:A457 C1              	  3834: 		POP		BC				; Restore digit count
01:A458 0D              	  3835: 		DEC		C				; Count digits
01:A459 C22CA4          	  3836: 		JP		NZ,DIGTXT		; More - Do them
01:A45C 05              	  3837: 		DEC		B				; Any decimal part?
01:A45D CA6CA4          	  3838: 		JP		Z,DOEBIT		; No - Do 'E' bit
01:A460 2B              	  3839: SUPTLZ: DEC		HL				; Move back through buffer
01:A461 7E              	  3840: 		LD		A,(HL)			; Get character
01:A462 FE30            	  3841: 		CP		'0'				; '0' character?
01:A464 CA60A4          	  3842: 		JP		Z,SUPTLZ		; Yes - Look back for more
01:A467 FE2E            	  3843: 		CP		'.'				; A decimal point?
01:A469 C475A2          	  3844: 		CALL	NZ,INCHL		; Move back over digit
                        	  3845: 
01:A46C F1              	  3846: DOEBIT: POP		AF				; Get 'E' flag
01:A46D CA8BA4          	  3847: 		JP		Z,NOENED		; No 'E' needed - End buffer
01:A470 3645            	  3848: 		LD		(HL),'E'		; Put 'E' in buffer
01:A472 23              	  3849: 		INC		HL				; And move on
01:A473 362B            	  3850: 		LD		(HL),'+'		; Put '+' in buffer
01:A475 F27CA4          	  3851: 		JP		P,OUTEXP		; Positive - Output exponent
01:A478 362D            	  3852: 		LD		(HL),'-'		; Put '-' in buffer
01:A47A 2F              	  3853: 		CPL						; Negate exponent
01:A47B 3C              	  3854: 		INC		A
01:A47C 062F            	  3855: OUTEXP: LD		B,'0'-1			; ASCII '0' - 1
01:A47E 04              	  3856: EXPTEN: INC		B				; Count subtractions
01:A47F D60A            	  3857: 		SUB		10				; Tens digit
01:A481 D27EA4          	  3858: 		JP		NC,EXPTEN		; More to do
01:A484 C63A            	  3859: 		ADD		A,'0'+10		; Restore and make ASCII
01:A486 23              	  3860: 		INC		HL				; Move on
01:A487 70              	  3861: 		LD		(HL),B			; Save MSB of exponent
01:A488 23              	  3862: JSTZER: INC		HL				;
01:A489 77              	  3863: 		LD		(HL),A			; Save LSB of exponent
01:A48A 23              	  3864: 		INC		HL
01:A48B 71              	  3865: NOENED: LD		(HL),C			; Mark end of buffer
01:A48C E1              	  3866: 		POP		HL				; Restore code string address
01:A48D C9              	  3867: 		RET
                        	  3868: 
01:A48E 017494          	  3869: RNGTST: LD		BC,9474H		; BCDE = 999999.
01:A491 11F723          	  3870: 		LD		DE,23F7H
01:A494 CD9AA2          	  3871: 		CALL	CMPNUM			; Compare numbers
01:A497 B7              	  3872: 		OR		A
01:A498 E1              	  3873: 		POP		HL				; Return address to HL
01:A499 E2F6A3          	  3874: 		JP		PO,GTSIXD		; Too big - Divide by ten
01:A49C E9              	  3875: 		JP		(HL)			; Otherwise return to caller
                        	  3876: 
01:A49D 00              	  3877: HALF:	db	   00H,00H,00H,80H ; 0.5
01:A49E 00
01:A49F 00
01:A4A0 80
                        	  3878: 
01:A4A1 A0              	  3879: POWERS: db	   0A0H,086H,001H  ; 100000
01:A4A2 86
01:A4A3 01
01:A4A4 10              	  3880: 		db	   010H,027H,000H  ;  10000
01:A4A5 27
01:A4A6 00
01:A4A7 E8              	  3881: 		db	   0E8H,003H,000H  ;   1000
01:A4A8 03
01:A4A9 00
01:A4AA 64              	  3882: 		db	   064H,000H,000H  ;	100
01:A4AB 00
01:A4AC 00
01:A4AD 0A              	  3883: 		db	   00AH,000H,000H  ;	 10
01:A4AE 00
01:A4AF 00
01:A4B0 01              	  3884: 		db	   001H,000H,000H  ;	  1
01:A4B1 00
01:A4B2 00
                        	  3885: 
01:A4B3 2148A2          	  3886: NEGAFT: LD	HL,INVSGN			; Negate result
01:A4B6 E3              	  3887: 		EX		(SP),HL			; To be done after caller
01:A4B7 E9              	  3888: 		JP		(HL)			; Return to caller
                        	  3889: 
01:A4B8 CD50A2          	  3890: SQR:	CALL	STAKFP			; Put value on stack
01:A4BB 219DA4          	  3891: 		LD		HL,HALF			; Set power to 1/2
01:A4BE CD5DA2          	  3892: 		CALL	PHLTFP			; Move 1/2 to FPREG
                        	  3893: 
01:A4C1 C1              	  3894: POWER:	POP		BC				; Get base
01:A4C2 D1              	  3895: 		POP		DE
01:A4C3 CD1FA2          	  3896: 		CALL	TSTSGN			; Test sign of power
01:A4C6 78              	  3897: 		LD		A,B				; Get exponent of base
01:A4C7 CA06A5          	  3898: 		JP		Z,EXPP			; Make result 1 if zero
01:A4CA F2D1A4          	  3899: 		JP		P,POWER1		; Positive base - Ok
01:A4CD B7              	  3900: 		OR		A				; Zero to negative power?
01:A4CE CA7F8F          	  3901: 		JP		Z,DZERR			; Yes - ?/0 Error
01:A4D1 B7              	  3902: POWER1: OR		A				; Base zero?
01:A4D2 CA40A0          	  3903: 		JP		Z,SAVEXP		; Yes - Return zero
01:A4D5 D5              	  3904: 		PUSH	DE				; Save base
01:A4D6 C5              	  3905: 		PUSH	BC
01:A4D7 79              	  3906: 		LD		A,C				; Get MSB of base
01:A4D8 F67F            	  3907: 		OR		01111111B		; Get sign status
01:A4DA CD6BA2          	  3908: 		CALL	BCDEFP			; Move power to BCDE
01:A4DD F2EEA4          	  3909: 		JP		P,POWER2		; Positive base - Ok
01:A4E0 D5              	  3910: 		PUSH	DE				; Save power
01:A4E1 C5              	  3911: 		PUSH	BC
01:A4E2 CDF2A2          	  3912: 		CALL	INT				; Get integer of power
01:A4E5 C1              	  3913: 		POP		BC				; Restore power
01:A4E6 D1              	  3914: 		POP		DE
01:A4E7 F5              	  3915: 		PUSH	AF				; MSB of base
01:A4E8 CD9AA2          	  3916: 		CALL	CMPNUM			; Power an integer?
01:A4EB E1              	  3917: 		POP		HL				; Restore MSB of base
01:A4EC 7C              	  3918: 		LD		A,H				; but don't affect flags
01:A4ED 1F              	  3919: 		RRA						; Exponent odd or even?
01:A4EE E1              	  3920: POWER2: POP		HL				; Restore MSB and exponent
01:A4EF 22E610          	  3921: 		LD		(FPREG+2),HL	; Save base in FPREG
01:A4F2 E1              	  3922: 		POP		HL				; LSBs of base
01:A4F3 22E410          	  3923: 		LD		(FPREG),HL		; Save in FPREG
01:A4F6 DCB3A4          	  3924: 		CALL	C,NEGAFT		; Odd power - Negate result
01:A4F9 CC48A2          	  3925: 		CALL	Z,INVSGN		; Negative base - Negate it
01:A4FC D5              	  3926: 		PUSH	DE				; Save power
01:A4FD C5              	  3927: 		PUSH	BC
01:A4FE CDD3A0          	  3928: 		CALL	LOG				; Get LOG of base
01:A501 C1              	  3929: 		POP		BC				; Restore power
01:A502 D1              	  3930: 		POP		DE
01:A503 CD14A1          	  3931: 		CALL	FPMULT			; Multiply LOG by power
                        	  3932: 
01:A506 CD50A2          	  3933: EXPP:	CALL	STAKFP			; Put value on stack
01:A509 013881          	  3934: 		LD		BC,08138H		; BCDE = 1/Ln(2)
01:A50C 113BAA          	  3935: 		LD		DE,0AA3BH
01:A50F CD14A1          	  3936: 		CALL	FPMULT			; Multiply value by 1/LN(2)
01:A512 3AE710          	  3937: 		LD		A,(FPEXP)		; Get exponent
01:A515 FE88            	  3938: 		CP		80H+8			; Is it in range?
01:A517 D2FBA1          	  3939: 		JP		NC,OVTST1		; No - Test for overflow
01:A51A CDF2A2          	  3940: 		CALL	INT				; Get INT of FPREG
01:A51D C680            	  3941: 		ADD		A,80H			; For excess 128
01:A51F C602            	  3942: 		ADD		A,2				; Exponent > 126?
01:A521 DAFBA1          	  3943: 		JP		C,OVTST1		; Yes - Test for overflow
01:A524 F5              	  3944: 		PUSH	AF				; Save scaling factor
01:A525 21C2A0          	  3945: 		LD		HL,UNITY		; Point to 1.
01:A528 CDCA9F          	  3946: 		CALL	ADDPHL			; Add 1 to FPREG
01:A52B CD0BA1          	  3947: 		CALL	MULLN2			; Multiply by LN(2)
01:A52E F1              	  3948: 		POP		AF				; Restore scaling factor
01:A52F C1              	  3949: 		POP		BC				; Restore exponent
01:A530 D1              	  3950: 		POP		DE
01:A531 F5              	  3951: 		PUSH	AF				; Save scaling factor
01:A532 CDD69F          	  3952: 		CALL	SUBCDE			; Subtract exponent from FPREG
01:A535 CD48A2          	  3953: 		CALL	INVSGN			; Negate result
01:A538 2146A5          	  3954: 		LD		HL,EXPTAB		; Coefficient table
01:A53B CD76A5          	  3955: 		CALL	SMSER1			; Sum the series
01:A53E 110000          	  3956: 		LD		DE,0			; Zero LSBs
01:A541 C1              	  3957: 		POP		BC				; Scaling factor
01:A542 4A              	  3958: 		LD		C,D				; Zero MSB
01:A543 C314A1          	  3959: 		JP		FPMULT			; Scale result to correct value
                        	  3960: 
01:A546 08              	  3961: EXPTAB: db	   8					; Table used by EXP
01:A547 40              	  3962: 		db	   040H,02EH,094H,074H	; -1/7! (-1/5040)
01:A548 2E
01:A549 94
01:A54A 74
01:A54B 70              	  3963: 		db	   070H,04FH,02EH,077H	;  1/6! ( 1/720)
01:A54C 4F
01:A54D 2E
01:A54E 77
01:A54F 6E              	  3964: 		db	   06EH,002H,088H,07AH	; -1/5! (-1/120)
01:A550 02
01:A551 88
01:A552 7A
01:A553 E6              	  3965: 		db	   0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
01:A554 A0
01:A555 2A
01:A556 7C
01:A557 50              	  3966: 		db	   050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
01:A558 AA
01:A559 AA
01:A55A 7E
01:A55B FF              	  3967: 		db	   0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
01:A55C FF
01:A55D 7F
01:A55E 7F
01:A55F 00              	  3968: 		db	   000H,000H,080H,081H	; -1/1! (-1/1)
01:A560 00
01:A561 80
01:A562 81
01:A563 00              	  3969: 		db	   000H,000H,000H,081H	;  1/0! ( 1/1)
01:A564 00
01:A565 00
01:A566 81
                        	  3970: 
01:A567 CD50A2          	  3971: SUMSER: CALL	STAKFP			; Put FPREG on stack
01:A56A 1112A1          	  3972: 		LD		DE,MULTT			; Multiply by "X"
01:A56D D5              	  3973: 		PUSH	DE				; To be done after
01:A56E E5              	  3974: 		PUSH	HL				; Save address of table
01:A56F CD6BA2          	  3975: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A572 CD14A1          	  3976: 		CALL	FPMULT			; Square the value
01:A575 E1              	  3977: 		POP		HL				; Restore address of table
01:A576 CD50A2          	  3978: SMSER1: CALL	STAKFP			; Put value on stack
01:A579 7E              	  3979: 		LD		A,(HL)			; Get number of coefficients
01:A57A 23              	  3980: 		INC		HL				; Point to start of table
01:A57B CD5DA2          	  3981: 		CALL	PHLTFP			; Move coefficient to FPREG
01:A57E 06              	  3982: 		db	   06H			   ; Skip "POP AF"
01:A57F F1              	  3983: SUMLP:	POP		AF				; Restore count
01:A580 C1              	  3984: 		POP		BC				; Restore number
01:A581 D1              	  3985: 		POP		DE
01:A582 3D              	  3986: 		DEC		A				; Cont coefficients
01:A583 C8              	  3987: 		RET		Z				; All done
01:A584 D5              	  3988: 		PUSH	DE				; Save number
01:A585 C5              	  3989: 		PUSH	BC
01:A586 F5              	  3990: 		PUSH	AF				; Save count
01:A587 E5              	  3991: 		PUSH	HL				; Save address in table
01:A588 CD14A1          	  3992: 		CALL	FPMULT			; Multiply FPREG by BCDE
01:A58B E1              	  3993: 		POP		HL				; Restore address in table
01:A58C CD6EA2          	  3994: 		CALL	LOADFP			; Number at HL to BCDE
01:A58F E5              	  3995: 		PUSH	HL				; Save address in table
01:A590 CDD99F          	  3996: 		CALL	FPADD			; Add coefficient to FPREG
01:A593 E1              	  3997: 		POP		HL				; Restore address in table
01:A594 C37FA5          	  3998: 		JP		SUMLP			; More coefficients
                        	  3999: 
01:A597 CD1FA2          	  4000: RND:	CALL	TSTSGN			; Test sign of FPREG
01:A59A 211910          	  4001: 		LD		HL,SEED+2		; Random number seed
01:A59D FAF8A5          	  4002: 		JP		M,RESEED		; Negative - Re-seed
01:A5A0 213A10          	  4003: 		LD		HL,LSTRND		; Last random number
01:A5A3 CD5DA2          	  4004: 		CALL	PHLTFP			; Move last RND to FPREG
01:A5A6 211910          	  4005: 		LD		HL,SEED+2		; Random number seed
01:A5A9 C8              	  4006: 		RET		Z				; Return if RND(0)
01:A5AA 86              	  4007: 		ADD		A,(HL)			; Add (SEED)+2)
01:A5AB E607            	  4008: 		AND		00000111B		; 0 to 7
01:A5AD 0600            	  4009: 		LD		B,0
01:A5AF 77              	  4010: 		LD		(HL),A			; Re-save seed
01:A5B0 23              	  4011: 		INC		HL				; Move to coefficient table
01:A5B1 87              	  4012: 		ADD		A,A				; 4 bytes
01:A5B2 87              	  4013: 		ADD		A,A				; per entry
01:A5B3 4F              	  4014: 		LD		C,A				; BC = Offset into table
01:A5B4 09              	  4015: 		ADD		HL,BC			; Point to coefficient
01:A5B5 CD6EA2          	  4016: 		CALL	LOADFP			; Coefficient to BCDE
01:A5B8 CD14A1          	  4017: 		CALL	FPMULT	;		; Multiply FPREG by coefficient
01:A5BB 3A1810          	  4018: 		LD		A,(SEED+1)		; Get (SEED+1)
01:A5BE 3C              	  4019: 		INC		A				; Add 1
01:A5BF E603            	  4020: 		AND		00000011B		; 0 to 3
01:A5C1 0600            	  4021: 		LD		B,0
01:A5C3 FE01            	  4022: 		CP		1				; Is it zero?
01:A5C5 88              	  4023: 		ADC		A,B				; Yes - Make it 1
01:A5C6 321810          	  4024: 		LD		(SEED+1),A		; Re-save seed
01:A5C9 21FCA5          	  4025: 		LD		HL,RNDTAB-4		; Addition table
01:A5CC 87              	  4026: 		ADD		A,A				; 4 bytes
01:A5CD 87              	  4027: 		ADD		A,A				; per entry
01:A5CE 4F              	  4028: 		LD		C,A				; BC = Offset into table
01:A5CF 09              	  4029: 		ADD		HL,BC			; Point to value
01:A5D0 CDCA9F          	  4030: 		CALL	ADDPHL			; Add value to FPREG
01:A5D3 CD6BA2          	  4031: RND1:	CALL	BCDEFP			; Move FPREG to BCDE
01:A5D6 7B              	  4032: 		LD		A,E				; Get LSB
01:A5D7 59              	  4033: 		LD		E,C				; LSB = MSB
01:A5D8 EE4F            	  4034: 		XOR		01001111B		; Fiddle around
01:A5DA 4F              	  4035: 		LD		C,A				; New MSB
01:A5DB 3680            	  4036: 		LD		(HL),80H		; Set exponent
01:A5DD 2B              	  4037: 		DEC		HL				; Point to MSB
01:A5DE 46              	  4038: 		LD		B,(HL)			; Get MSB
01:A5DF 3680            	  4039: 		LD		(HL),80H		; Make value -0.5
01:A5E1 211710          	  4040: 		LD		HL,SEED			; Random number seed
01:A5E4 34              	  4041: 		INC		(HL)			; Count seed
01:A5E5 7E              	  4042: 		LD		A,(HL)			; Get seed
01:A5E6 D6AB            	  4043: 		SUB		171				; Do it modulo 171
01:A5E8 C2EFA5          	  4044: 		JP		NZ,RND2			; Non-zero - Ok
01:A5EB 77              	  4045: 		LD		(HL),A			; Zero seed
01:A5EC 0C              	  4046: 		INC		C				; Fillde about
01:A5ED 15              	  4047: 		DEC		D				; with the
01:A5EE 1C              	  4048: 		INC		E				; number
01:A5EF CD2AA0          	  4049: RND2:	CALL	BNORM			; Normalise number
01:A5F2 213A10          	  4050: 		LD		HL,LSTRND		; Save random number
01:A5F5 C377A2          	  4051: 		JP		FPTHL			; Move FPREG to last and return
                        	  4052: 
01:A5F8 77              	  4053: RESEED: LD		(HL),A			; Re-seed random numbers
01:A5F9 2B              	  4054: 		DEC		HL
01:A5FA 77              	  4055: 		LD		(HL),A
01:A5FB 2B              	  4056: 		DEC		HL
01:A5FC 77              	  4057: 		LD		(HL),A
01:A5FD C3D3A5          	  4058: 		JP		RND1			; Return RND seed
                        	  4059: 
01:A600 68              	  4060: RNDTAB: db		068H,0B1H,046H,068H	; Table used by RND
01:A601 B1
01:A602 46
01:A603 68
01:A604 99              	  4061: 		db		099H,0E9H,092H,069H
01:A605 E9
01:A606 92
01:A607 69
01:A608 10              	  4062: 		db		010H,0D1H,075H,068H
01:A609 D1
01:A60A 75
01:A60B 68
                        	  4063: 
01:A60C 2156A6          	  4064: COS:	LD		HL,HALFPI		; Point to PI/2
01:A60F CDCA9F          	  4065: 		CALL	ADDPHL			; Add it to PPREG
01:A612 CD50A2          	  4066: SIN:	CALL	STAKFP			; Put angle on stack
01:A615 014983          	  4067: 		LD		BC,8349H		; BCDE = 2 PI
01:A618 11DB0F          	  4068: 		LD		DE,0FDBH
01:A61B CD60A2          	  4069: 		CALL	FPBCDE			; Move 2 PI to FPREG
01:A61E C1              	  4070: 		POP		BC				; Restore angle
01:A61F D1              	  4071: 		POP		DE
01:A620 CD75A1          	  4072: 		CALL	DVBCDE			; Divide angle by 2 PI
01:A623 CD50A2          	  4073: 		CALL	STAKFP			; Put it on stack
01:A626 CDF2A2          	  4074: 		CALL	INT				; Get INT of result
01:A629 C1              	  4075: 		POP		BC				; Restore number
01:A62A D1              	  4076: 		POP		DE
01:A62B CDD69F          	  4077: 		CALL	SUBCDE			; Make it 0 <= value < 1
01:A62E 215AA6          	  4078: 		LD		HL,QUARTR		; Point to 0.25
01:A631 CDD09F          	  4079: 		CALL	SUBPHL			; Subtract value from 0.25
01:A634 CD1FA2          	  4080: 		CALL	TSTSGN			; Test sign of value
01:A637 37              	  4081: 		SCF						; Flag positive
01:A638 F242A6          	  4082: 		JP		P,SIN1			; Positive - Ok
01:A63B CDC79F          	  4083: 		CALL	ROUND			; Add 0.5 to value
01:A63E CD1FA2          	  4084: 		CALL	TSTSGN			; Test sign of value
01:A641 B7              	  4085: 		OR		A				; Flag negative
01:A642 F5              	  4086: SIN1:	PUSH	AF				; Save sign
01:A643 F448A2          	  4087: 		CALL	P,INVSGN		; Negate value if positive
01:A646 215AA6          	  4088: 		LD		HL,QUARTR		; Point to 0.25
01:A649 CDCA9F          	  4089: 		CALL	ADDPHL			; Add 0.25 to value
01:A64C F1              	  4090: 		POP		AF				; Restore sign
01:A64D D448A2          	  4091: 		CALL	NC,INVSGN		; Negative - Make positive
01:A650 215EA6          	  4092: 		LD		HL,SINTAB		; Coefficient table
01:A653 C367A5          	  4093: 		JP		SUMSER			; Evaluate sum of series
                        	  4094: 
01:A656 DB              	  4095: HALFPI: db		0DBH,00FH,049H,081H	; 1.5708 (PI/2)
01:A657 0F
01:A658 49
01:A659 81
                        	  4096: 
01:A65A 00              	  4097: QUARTR: db		000H,000H,000H,07FH	; 0.25
01:A65B 00
01:A65C 00
01:A65D 7F
                        	  4098: 
01:A65E 05              	  4099: SINTAB: db		5					; Table used by SIN
01:A65F BA              	  4100: 		db		0BAH,0D7H,01EH,086H	; 39.711
01:A660 D7
01:A661 1E
01:A662 86
01:A663 64              	  4101: 		db		064H,026H,099H,087H	;-76.575
01:A664 26
01:A665 99
01:A666 87
01:A667 58              	  4102: 		db		058H,034H,023H,087H	; 81.602
01:A668 34
01:A669 23
01:A66A 87
01:A66B E0              	  4103: 		db		0E0H,05DH,0A5H,086H	;-41.342
01:A66C 5D
01:A66D A5
01:A66E 86
01:A66F DA              	  4104: 		db		0DAH,00FH,049H,083H	;  6.2832
01:A670 0F
01:A671 49
01:A672 83
                        	  4105: 
01:A673 CD50A2          	  4106: TAN:	CALL	STAKFP			; Put angle on stack
01:A676 CD12A6          	  4107: 		CALL	SIN				; Get SIN of angle
01:A679 C1              	  4108: 		POP		BC				; Restore angle
01:A67A E1              	  4109: 		POP		HL
01:A67B CD50A2          	  4110: 		CALL	STAKFP			; Save SIN of angle
01:A67E EB              	  4111: 		EX		DE,HL			; BCDE = Angle
01:A67F CD60A2          	  4112: 		CALL	FPBCDE			; Angle to FPREG
01:A682 CD0CA6          	  4113: 		CALL	COS				; Get COS of angle
01:A685 C373A1          	  4114: 		JP		DIV				; TAN = SIN / COS
                        	  4115: 
01:A688 CD1FA2          	  4116: ATN:	CALL	TSTSGN			; Test sign of value
01:A68B FCB3A4          	  4117: 		CALL	M,NEGAFT		; Negate result after if -ve
01:A68E FC48A2          	  4118: 		CALL	M,INVSGN		; Negate value if -ve
01:A691 3AE710          	  4119: 		LD		A,(FPEXP)		; Get exponent
01:A694 FE81            	  4120: 		CP		81H				; Number less than 1?
01:A696 DAA5A6          	  4121: 		JP		C,ATN1			; Yes - Get arc tangnt
01:A699 010081          	  4122: 		LD		BC,8100H		; BCDE = 1
01:A69C 51              	  4123: 		LD		D,C
01:A69D 59              	  4124: 		LD		E,C
01:A69E CD75A1          	  4125: 		CALL	DVBCDE			; Get reciprocal of number
01:A6A1 21D09F          	  4126: 		LD		HL,SUBPHL		; Sub angle from PI/2
01:A6A4 E5              	  4127: 		PUSH	HL				; Save for angle > 1
01:A6A5 21AFA6          	  4128: ATN1:	LD		HL,ATNTAB		; Coefficient table
01:A6A8 CD67A5          	  4129: 		CALL	SUMSER			; Evaluate sum of series
01:A6AB 2156A6          	  4130: 		LD		HL,HALFPI		; PI/2 - angle in case > 1
01:A6AE C9              	  4131: 		RET						; Number > 1 - Sub from PI/2
                        	  4132: 
01:A6AF 09              	  4133: ATNTAB: db		9					; Table used by ATN
01:A6B0 4A              	  4134: 		db		04AH,0D7H,03BH,078H	;  1/17
01:A6B1 D7
01:A6B2 3B
01:A6B3 78
01:A6B4 02              	  4135: 		db		002H,06EH,084H,07BH	; -1/15
01:A6B5 6E
01:A6B6 84
01:A6B7 7B
01:A6B8 FE              	  4136: 		db		0FEH,0C1H,02FH,07CH	;  1/13
01:A6B9 C1
01:A6BA 2F
01:A6BB 7C
01:A6BC 74              	  4137: 		db		074H,031H,09AH,07DH	; -1/11
01:A6BD 31
01:A6BE 9A
01:A6BF 7D
01:A6C0 84              	  4138: 		db		084H,03DH,05AH,07DH	;  1/9
01:A6C1 3D
01:A6C2 5A
01:A6C3 7D
01:A6C4 C8              	  4139: 		db		0C8H,07FH,091H,07EH	; -1/7
01:A6C5 7F
01:A6C6 91
01:A6C7 7E
01:A6C8 E4              	  4140: 		db		0E4H,0BBH,04CH,07EH	;  1/5
01:A6C9 BB
01:A6CA 4C
01:A6CB 7E
01:A6CC 6C              	  4141: 		db		06CH,0AAH,0AAH,07FH	; -1/3
01:A6CD AA
01:A6CE AA
01:A6CF 7F
01:A6D0 00              	  4142: 		db		000H,000H,000H,081H	;  1/1
01:A6D1 00
01:A6D2 00
01:A6D3 81
                        	  4143: 
                        	  4144: ARET:
01:A6D4 C9              	  4145: 	ret								; A RETurn instruction
                        	  4146: 
                        	  4147: GETINP:
01:A6D5 CDC980          	  4148: 	call	ReadChar				;input a character
01:A6D8 C9              	  4149: 	ret
                        	  4150: 
                        	  4151: CLS:
01:A6D9 C3AC82          	  4152: 	jp		ClearScreen
                        	  4153: 
                        	  4154: WIDTH:
01:A6DC CD9E9F          	  4155: 	call	GETINT					; Get integer 0-255
01:A6DF 7B              	  4156: 	ld		A,E						; Width to A
01:A6E0 324210          	  4157: 	ld		(LWIDTH),A				; Set width
01:A6E3 C9              	  4158: 	ret			
                        	  4159: 			
                        	  4160: LINES:			
01:A6E4 CD3D98          	  4161: 	call	GETNUM					; Get a number
01:A6E7 CD8994          	  4162: 	call	DEINT					; Get integer -32768 to 32767
01:A6EA ED534610        	  4163: 	ld		(LINESC),DE				; Set lines counter
01:A6EE ED534810        	  4164: 	ld		(LINESN),DE				; Set lines number
01:A6F2 C9              	  4165: 	ret			
                        	  4166: 			
                        	  4167: DEEK:			
01:A6F3 CD8994          	  4168: 	call	DEINT					; Get integer -32768 to 32767
01:A6F6 D5              	  4169: 	push	DE						; Save number
01:A6F7 E1              	  4170: 	pop		HL						; Number to HL
01:A6F8 46              	  4171: 	ld		B,(HL)					; Get LSB of contents
01:A6F9 23              	  4172: 	inc		HL			
01:A6FA 7E              	  4173: 	ld		A,(HL)					; Get MSB of contents
01:A6FB C3F89B          	  4174: 	jp		ABPASS					; Return integer AB
                        	  4175: 			
                        	  4176: DOKE:			
01:A6FE CD3D98          	  4177: 	call	GETNUM					; Get a number
01:A701 CD8994          	  4178: 	call	DEINT					; Get integer -32768 to 32767
01:A704 D5              	  4179: 	push	DE						; Save address
01:A705 CD4A92          	  4180: 	call	CHKSYN					; Make sure ',' follows
01:A708 2C              	  4181: 	db	   ','			
01:A709 CD3D98          	  4182: 	call	GETNUM					; Get a number
01:A70C CD8994          	  4183: 	call	DEINT					; Get integer -32768 to 32767
01:A70F E3              	  4184: 	ex		(SP),HL					; Save value,get address
01:A710 73              	  4185: 	ld		(HL),E					; Save LSB of value
01:A711 23              	  4186: 	inc		HL			
01:A712 72              	  4187: 	ld		(HL),D					; Save MSB of value
01:A713 E1              	  4188: 	pop		HL						; Restore code string address
01:A714 C9              	  4189: 	ret
                        	  4190: 
                        	  4191: 
                        	  4192: ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        	  4193: 
                        	  4194: HEX:
01:A715 CD4098          	  4195: 	call	TSTNUM					; Verify it's a number
01:A718 CD8994          	  4196: 	call	DEINT					; Get integer -32768 to 32767
01:A71B C5              	  4197: 	push	BC						; Save contents of BC
01:A71C 21E910          	  4198: 	ld		HL,PBUFF			
01:A71F 7A              	  4199: 	ld		A,D						; Get high order into A
01:A720 FE00            	  4200: 	cp		$0			
01:A722 280C            	  4201: 	jr		z,HEX2					; Skip output if both high digits are zero
01:A724 CD4DA7          	  4202: 	call	BYT2ASC					; Convert D to ASCII
01:A727 78              	  4203: 	ld		A,B			
01:A728 FE30            	  4204: 	cp		'0'			
01:A72A 2802            	  4205: 	jr		z,HEX1					; Don't store high digit if zero
01:A72C 70              	  4206: 	ld		(HL),B					; Store it to PBUFF
01:A72D 23              	  4207: 	inc		HL						; Next location
                        	  4208: HEX1:			
01:A72E 71              	  4209: 	ld		(HL),C					; Store C to PBUFF+1
01:A72F 23              	  4210: 	inc		HL						; Next location
                        	  4211: HEX2:			
01:A730 7B              	  4212: 	ld		A,E						; Get lower byte
01:A731 CD4DA7          	  4213: 	call	BYT2ASC					; Convert E to ASCII
01:A734 7A              	  4214: 	ld		A,D			
01:A735 FE00            	  4215: 	cp		$0			
01:A737 2005            	  4216: 	jr		nz,HEX3					; If upper byte was not zero then always print lower byte
01:A739 78              	  4217: 	ld		A,B			
01:A73A FE30            	  4218: 	cp		'0'						; If high digit of lower byte is zero then don't print
01:A73C 2802            	  4219: 	jr		z,HEX4			
                        	  4220: HEX3:			
01:A73E 70              	  4221: 	ld		(HL),B					; to PBUFF+2
01:A73F 23              	  4222: 	inc		HL						; Next location
                        	  4223: HEX4:			
01:A740 71              	  4224: 	ld		(HL),C					; to PBUFF+3
01:A741 23              	  4225: 	inc		HL						; PBUFF+4 to zero
01:A742 AF              	  4226: 	xor		A						; Terminating character
01:A743 77              	  4227: 	ld		(HL),A					; Store zero to terminate
01:A744 23              	  4228: 	inc		HL						; Make sure PBUFF is terminated
01:A745 77              	  4229: 	ld		(HL),A					; Store the double zero there
01:A746 C1              	  4230: 	pop		BC						; Get BC back
01:A747 21E910          	  4231: 	ld		HL,PBUFF				; Reset to start of PBUFF
01:A74A C3A69C          	  4232: 	jp		STR1					; Convert the PBUFF to a string and return it
                        	  4233: 			
                        	  4234: BYT2ASC:			
01:A74D 47              	  4235: 	ld		B,A						; Save original value
01:A74E E60F            	  4236: 	and		$0F						; Strip off upper nybble
01:A750 FE0A            	  4237: 	cp		$0A						; 0-9?
01:A752 3802            	  4238: 	jr		c,ADD30					; If A-F, add 7 more
01:A754 C607            	  4239: 	add		A,$07					; Bring value up to ASCII A-F
                        	  4240: ADD30:			
01:A756 C630            	  4241: 	add		A,$30					; And make ASCII
01:A758 4F              	  4242: 	ld		C,A						; Save converted char to C
01:A759 78              	  4243: 	ld		A,B						; Retrieve original value
01:A75A CB0F            	  4244: 	rrc		A							; and Rotate it right
01:A75C CB0F            	  4245: 	rrc		A			
01:A75E CB0F            	  4246: 	rrc		A			
01:A760 CB0F            	  4247: 	rrc		A			
01:A762 E60F            	  4248: 	and		$0F						; Mask off upper nybble
01:A764 FE0A            	  4249: 	cp		$0A						; 0-9? < A hex?
01:A766 3802            	  4250: 	jr		c,ADD301				; Skip Add 7
01:A768 C607            	  4251: 	add		A,$07					; Bring it up to ASCII A-F
                        	  4252: ADD301:			
01:A76A C630            	  4253: 	add		A,$30					; And make it full ASCII
01:A76C 47              	  4254: 	ld		B,A						; Store high order byte
01:A76D C9              	  4255: 	ret	
                        	  4256: 
                        	  4257: ; Convert "&Hnnnn" to FPREG
                        	  4258: ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        	  4259: ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
                        	  4260: HEXTFP:
01:A76E EB              	  4261: 	ex		DE,HL					; Move code string pointer to DE
01:A76F 210000          	  4262: 	ld		HL,$0000				; Zero out the value
01:A772 CD87A7          	  4263: 	call	GETHEX					; Check the number for valid hex
01:A775 DAA7A7          	  4264: 	jp		c,HXERR					; First value wasn't hex, HX error
01:A778 1805            	  4265: 	jr		HEXLP1					; Convert first character
                        	  4266: HEXLP:			
01:A77A CD87A7          	  4267: 	call	GETHEX					; Get second and addtional characters
01:A77D 381F            	  4268: 	jr		c,HEXIT					; Exit if not a hex character
                        	  4269: HEXLP1:			
01:A77F 29              	  4270: 	add		HL,HL					; Rotate 4 bits to the left
01:A780 29              	  4271: 	add		HL,HL			
01:A781 29              	  4272: 	add		HL,HL			
01:A782 29              	  4273: 	add		HL,HL			
01:A783 B5              	  4274: 	or		L						; Add in D0-D3 into L
01:A784 6F              	  4275: 	ld		L,A						; Save new value
01:A785 18F3            	  4276: 	jr		HEXLP					; And continue until all hex characters are in
                        	  4277: 			
                        	  4278: GETHEX:			
01:A787 13              	  4279: 	inc		DE						; Next location
01:A788 1A              	  4280: 	ld		A,(DE)					; Load character at pointer
01:A789 FE20            	  4281: 	cp		' '			
01:A78B CA87A7          	  4282: 	jp		z,GETHEX				; Skip spaces
01:A78E D630            	  4283: 	sub		$30						; Get absolute value
01:A790 D8              	  4284: 	ret		c						; < "0", error
01:A791 FE0A            	  4285: 	cp		$0A			
01:A793 3805            	  4286: 	jr		c,NOSUB7				; Is already in the range 0-9
01:A795 D607            	  4287: 	sub		$07						; Reduce to A-F
01:A797 FE0A            	  4288: 	cp		$0A						; Value should be $0A-$0F at this point
01:A799 D8              	  4289: 	ret		c						; CY set if was :			 ; < = > ? @
                        	  4290: NOSUB7:			
01:A79A FE10            	  4291: 	cp		$10						; > Greater than "F"?
01:A79C 3F              	  4292: 	ccf			
01:A79D C9              	  4293: 	ret								; CY set if it wasn't valid hex
                        	  4294: 				
                        	  4295: HEXIT:			
01:A79E EB              	  4296: 	ex		DE,HL					; Value into DE, Code string into HL
01:A79F 7A              	  4297: 	ld		A,D						; Load DE into AC
01:A7A0 4B              	  4298: 	ld		C,E						; For prep to 
01:A7A1 E5              	  4299: 	push	HL			
01:A7A2 CDF79B          	  4300: 	call	ACPASS					; ACPASS to set AC as integer into FPREG
01:A7A5 E1              	  4301: 	pop		HL
01:A7A6 C9              	  4302: 	ret
                        	  4303: 
                        	  4304: HXERR:
01:A7A7 1E26            	  4305: 	ld		E,HX					; ?HEX Error
01:A7A9 C3908F          	  4306: 	jp		ERROR
                        	  4307: 
                        	  4308: ; BIN$(NN) Convert integer to a 1-16 char binary string
                        	  4309: BIN:
01:A7AC CD4098          	  4310: 	call	TSTNUM					; Verify it's a number
01:A7AF CD8994          	  4311: 	call	DEINT					; Get integer -32768 to 32767
                        	  4312: BIN2:			
01:A7B2 C5              	  4313: 	push	BC						; Save contents of BC
01:A7B3 21E910          	  4314: 	ld		HL,PBUFF			
01:A7B6 0611            	  4315: 	ld		B,17					; One higher than max char count
                        	  4316: ZEROSUP:								; Suppress leading zeros
01:A7B8 05              	  4317: 	dec		B						; Max 16 chars
01:A7B9 78              	  4318: 	ld		A,B			
01:A7BA FE01            	  4319: 	cp		$01			
01:A7BC 2808            	  4320: 	jr		z,BITOUT				; Always output at least one character
01:A7BE CB13            	  4321: 	rl		E			
01:A7C0 CB12            	  4322: 	rl		D			
01:A7C2 30F4            	  4323: 	jr		NC,ZEROSUP			
01:A7C4 1804            	  4324: 	jr		BITOUT2			
                        	  4325: BITOUT:		 			
01:A7C6 CB13            	  4326: 	rl		E			
01:A7C8 CB12            	  4327: 	rl		D						; Top bit now in carry
                        	  4328: BITOUT2:			
01:A7CA 3E30            	  4329: 	ld		A,'0'					; Char for '0'
01:A7CC CE00            	  4330: 	adc		A,0						; If carry set then '0' --> '1'
01:A7CE 77              	  4331: 	ld		(HL),A			
01:A7CF 23              	  4332: 	inc		HL			
01:A7D0 05              	  4333: 	dec		B			
01:A7D1 20F3            	  4334: 	jr		NZ,BITOUT			
01:A7D3 AF              	  4335: 	xor		A						; Terminating character
01:A7D4 77              	  4336: 	ld		(HL),A					; Store zero to terminate
01:A7D5 23              	  4337: 	inc		HL						; Make sure PBUFF is terminated
01:A7D6 77              	  4338: 	ld		(HL),A					; Store the double zero there
01:A7D7 C1              	  4339: 	pop		BC
01:A7D8 21E910          	  4340: 	ld		HL,PBUFF
01:A7DB C3A69C          	  4341: 	jp		STR1
                        	  4342: 
                        	  4343: ; Convert "&Bnnnn" to FPREG
                        	  4344: ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
                        	  4345: BINTFP: 
01:A7DE EB              	  4346: 	ex		DE,HL					; Move code string pointer to DE
01:A7DF 210000          	  4347: 	ld		HL,$0000				; Zero out the value
01:A7E2 CDFBA7          	  4348: 	call	CHKBIN					; Check the number for valid bin
01:A7E5 DA09A8          	  4349: 	jp		c,BINERR				; First value wasn't bin, HX error
                        	  4350: BINIT:
01:A7E8 D630            	  4351: 	sub		'0'
01:A7EA 29              	  4352: 	add		HL,HL					; Rotate HL left
01:A7EB B5              	  4353: 	or		L
01:A7EC 6F              	  4354: 	ld		L,A
01:A7ED CDFBA7          	  4355: 	call	CHKBIN					; Get second and addtional characters
01:A7F0 30F6            	  4356: 	jr		NC,BINIT				; Process if a bin character
01:A7F2 EB              	  4357: 	ex		DE,HL					; Value into DE, Code string into HL
01:A7F3 7A              	  4358: 	ld		A,D						; Load DE into AC
01:A7F4 4B              	  4359: 	ld		C,E						; For prep to 
01:A7F5 E5              	  4360: 	push	HL
01:A7F6 CDF79B          	  4361: 	call	ACPASS					; ACPASS to set AC as integer into FPREG
01:A7F9 E1              	  4362: 	pop		HL
01:A7FA C9              	  4363: 	ret
                        	  4364: 
                        	  4365: ; Char is in A, NC if char is 0 or 1
                        	  4366: CHKBIN: 
01:A7FB 13              	  4367: 	inc		DE
01:A7FC 1A              	  4368: 	ld		A,(DE)
01:A7FD FE20            	  4369: 	cp		' '
01:A7FF CAFBA7          	  4370: 	jp		Z,CHKBIN				; Skip spaces
01:A802 FE30            	  4371: 	cp		'0'						; Set C if < '0'
01:A804 D8              	  4372: 	ret		c
01:A805 FE32            	  4373: 	cp		'2'
01:A807 3F              	  4374: 	ccf								; Set C if > '1'
01:A808 C9              	  4375: 	ret
                        	  4376: 
                        	  4377: BINERR:
01:A809 1E28            	  4378: 	ld		E,BN					; ?BIN Error
01:A80B C3908F          	  4379: 	jp		ERROR
                        	  4380: 
                        	  4381: JJUMP1: 
01:A80E DD21FFFF        	  4382: 	ld		IX,-1					; Flag cold start
01:A812 C3DB8B          	  4383: 	jp		CSTART					; Go and initialise
                        	  4384: 
                        	  4385: MONOUT: 
01:A815 C37680          	  4386: 	jp		PrintChar				; Output a char
                        	  4387: 
                        	  4388: MONITR: 
01:A818 C30080          	  4389: 	jp		$8000					; Restart (Normally Monitor Start)
                        	  4390: 
                        	  4391: INITST:
01:A81B 3E00            	  4392: 	ld		A,0						; Clear break flag
01:A81D 324D10          	  4393: 	ld		(BRKFLG),A
01:A820 C3E28B          	  4394: 	jp		INIT
                        	  4395: 
                        	  4396: ARETN:
01:A823 ED45            	  4397: 	retn							; Return from NMI
                        	  4398: 
                        	  4399: TSTBIT:
01:A825 F5              	  4400: 	push	AF						; Save bit mask
01:A826 A0              	  4401: 	and		B						; Get common bits
01:A827 C1              	  4402: 	pop		BC						; Restore bit mask
01:A828 B8              	  4403: 	cp		B						; Same bit set?
01:A829 3E00            	  4404: 	ld		A,0						; Return 0 in A
01:A82B C9              	  4405: 	ret
                        	  4406: 
                        	  4407: OUTNCR:
01:A82C CD5592          	  4408: 	call	OUTC					; Output character in A
01:A82F C38180          	  4409: 	jp		PrintCRLF				; Output CRLF
                        	  4410: 
                        	  4411: EXIT:
01:A832 C30080          	  4412: 	jp		$8000
                        	  4413: 

Source: "main.asm"
                        	   275: 	.include	"data.asm"			; Various data and text messages. Keep last in list of includes

Source: "data.asm"
                        	     1: ;  ____            _           
                        	     2: ; |  _ \    __ _  | |_    __ _ 
                        	     3: ; | | | |  / _` | | __|  / _` |
                        	     4: ; | |_| | | (_| | | |_  | (_| |
                        	     5: ; |____/   \__,_|  \__|  \__,_|
                        	     6: ;
                        	     7: ; ---------------------------------------------------------------------------------------------------------------------
                        	     8: 
                        	     9: BootMsg:
01:A835 5A65644569676874	    10: 	db		"ZedEighty Project by Frederic Segard",CR,LF
01:A83D 792050726F6A6563
01:A845 7420627920467265
01:A84D 6465726963205365
01:A855 67617264
01:A859 0D
01:A85A 0A
01:A85B 7777772E796F7574	    11: 	db		"www.youtube.com/@microhobbyist",CR,LF
01:A863 7562652E636F6D2F
01:A86B 406D6963726F686F
01:A873 626279697374
01:A879 0D
01:A87A 0A
01:A87B 7777772E67697468	    12: 	db		"www.github.com/FredericSegard",CR,LF,0
01:A883 75622E636F6D2F46
01:A88B 7265646572696353
01:A893 6567617264
01:A898 0D
01:A899 0A
01:A89A 00
01:A89B 42494F5320302E37	    13: 	db		"BIOS 0.7  (c)2023  ",0," bytes free",CR,LF,LF,0
01:A8A3 2020286329323032
01:A8AB 332020
01:A8AE 00
01:A8AF 2062797465732066
01:A8B7 726565
01:A8BA 0D
01:A8BB 0A
01:A8BC 0A
01:A8BD 00
                        	    14: 
                        	    15: CommandList:						; Commands must be in uppercase, and the jp opcode also acts as a delimiter
01:A8BE 41444452        	    16: 	db		"ADDR"					; Sets current address
01:A8C2 C3A187          	    17: 	jp		SetAddress				;
01:A8C5 42414E4B        	    18: 	db		"BANK"					; Sets current bank
01:A8C9 C3C287          	    19: 	jp		SetBank					;
01:A8CC 4241534943      	    20: 	db		"BASIC"					; Tiny Basic
01:A8D1 C34B8B          	    21: 	jp		BASIC					;
01:A8D4 434C53          	    22: 	db		"CLS"					; Clear screen command
01:A8D7 C3AC82          	    23: 	jp		ClearScreen				;
01:A8DA 434F5059        	    24: 	db		"COPY"					; Copy data from one place to another (destructive)
01:A8DE C3B582          	    25: 	jp		CopyBlock				;
01:A8E1 44494147        	    26: 	db		"DIAG"					; Test RAM (and eventually other system components)
01:A8E5 C31A83          	    27: 	jp		Diagnostics				;
01:A8E8 46494C4C        	    28: 	db		"FILL"					; Fill a region of memory with a byte of data 
01:A8EC C3EA83          	    29: 	jp		FillMemory				;
                        	    30: ;	db		"FORTH"					; Camel Forth
                        	    31: ;	jp		FORTH					;
01:A8EF 44554D50        	    32: 	db		"DUMP"					; Hex dump command
01:A8F3 C38B84          	    33: 	jp		HexDump					;
01:A8F6 48414C54        	    34: 	db		"HALT"					; Halt the CPU
01:A8FA C38984          	    35: 	jp		HaltCmd
01:A8FD 4C495354        	    36: 	db		"LIST"					; List of commands
01:A901 C3D785          	    37: 	jp		ListCmd					;
01:A904 4C4F4144        	    38: 	db		"LOAD"					; Intel Hex load command
01:A908 C30785          	    39: 	jp		IntelHex				;
01:A90B 5045454B        	    40: 	db		"PEEK"					; Read a byte from I/O port
01:A90F C3E685          	    41: 	jp		PeekCmd					;
01:A912 504F4B45        	    42: 	db		"POKE"					; Write a byte to I/O port
01:A916 C31486          	    43: 	jp		PokeCmd					;
01:A919 524547          	    44: 	db		"REG"					; Prints the content of the registers
01:A91C C35486          	    45: 	jp		Registers				;
01:A91F 52554E          	    46: 	db		"RUN"					; Execute a program in RAM
01:A922 C38E87          	    47: 	jp		RunCode					;
01:A925 535953494E464F  	    48: 	db		"SYSINFO"				; Info command
01:A92C C3F387          	    49: 	jp		SysInfo					;
01:A92F 5752495445      	    50: 	db		"WRITE"					; Write up to 8 bytes of data
01:A934 C31088          	    51: 	jp		Write					;
01:A937 5A45524F        	    52: 	db		"ZERO"					; Zero all memory, including banks
01:A93B C36088          	    53: 	jp		ZeroAllRam				;
01:A93E FF              	    54: 	db		EOT
                        	    55: 
                        	    56: ListOfCommands:
                        	    57: 	;		"                                        "
01:A93F 0A              	    58: 	db		LF
01:A940 4D6F6E69746F7220	    59: 	db		"Monitor Commands",CR,LF,0
01:A948 436F6D6D616E6473
01:A950 0D
01:A951 0A
01:A952 00
01:A953 2D2041444452205B	    60: 	db		"- ADDR [AAAA]: Sets current address",CR,LF
01:A95B 414141415D3A2053
01:A963 6574732063757272
01:A96B 656E742061646472
01:A973 657373
01:A976 0D
01:A977 0A
01:A978 2D2042414E4B205B	    61: 	db		"- BANK [N]: Sets current bank",CR,LF
01:A980 4E5D3A2053657473
01:A988 2063757272656E74
01:A990 2062616E6B
01:A995 0D
01:A996 0A
01:A997 2D2042415349433A	    62: 	db		"- BASIC: Nascom MS BASIC",CR,LF
01:A99F 204E6173636F6D20
01:A9A7 4D53204241534943
01:A9AF 0D
01:A9B0 0A
01:A9B1 2D20434C533A2043	    63: 	db		"- CLS: Clear screen",CR,LF
01:A9B9 6C65617220736372
01:A9C1 65656E
01:A9C4 0D
01:A9C5 0A
01:A9C6 2D20434F50592053	    64: 	db		"- COPY SSSS DDDD BBBB: Copy memory block",CR,LF
01:A9CE 5353532044444444
01:A9D6 20424242423A2043
01:A9DE 6F7079206D656D6F
01:A9E6 727920626C6F636B
01:A9EE 0D
01:A9EF 0A
01:A9F0 2D20444941473A20	    65: 	db		"- DIAG: Diagnostics (RAM)",CR,LF
01:A9F8 446961676E6F7374
01:AA00 696373202852414D
01:AA08 29
01:AA09 0D
01:AA0A 0A
01:AA0B 2D2044554D50205B	    66: 	db		"- DUMP [AAAA] [LL]: Memory hex dump",CR,LF
01:AA13 414141415D205B4C
01:AA1B 4C5D3A204D656D6F
01:AA23 7279206865782064
01:AA2B 756D70
01:AA2E 0D
01:AA2F 0A
01:AA30 2D2046494C4C2053	    67: 	db		"- FILL SSSS EEEE BB: Fill memory",CR,LF
01:AA38 5353532045454545
01:AA40 2042423A2046696C
01:AA48 6C206D656D6F7279
01:AA50 0D
01:AA51 0A
                        	    68: ;	db		"- FORTH: Camel Forth, by Brad Rodriguez",CR,LF
01:AA52 2D204C4953543A20	    69: 	db		"- LIST: List of commands",CR,LF
01:AA5A 4C697374206F6620
01:AA62 636F6D6D616E6473
01:AA6A 0D
01:AA6B 0A
01:AA6C 2D204C4F41443A20	    70: 	db		"- LOAD: Intel Hex loader",CR,LF
01:AA74 496E74656C204865
01:AA7C 78206C6F61646572
01:AA84 0D
01:AA85 0A
01:AA86 2D205045454B2050	    71: 	db		"- PEEK PP: Read a byte from I/O port",CR,LF
01:AA8E 503A205265616420
01:AA96 6120627974652066
01:AA9E 726F6D20492F4F20
01:AAA6 706F7274
01:AAAA 0D
01:AAAB 0A
01:AAAC 2D20504F4B452050	    72: 	db		"- POKE PP BB: Write a byte to I/O port",CR,LF
01:AAB4 502042423A205772
01:AABC 6974652061206279
01:AAC4 746520746F20492F
01:AACC 4F20706F7274
01:AAD2 0D
01:AAD3 0A
01:AAD4 2D205245473A205A	    73: 	db		"- REG: Z80 registers",CR,LF
01:AADC 3830207265676973
01:AAE4 74657273
01:AAE8 0D
01:AAE9 0A
01:AAEA 2D2052554E205B41	    74: 	db		"- RUN [AAAA]: Execute a program",CR,LF
01:AAF2 4141415D3A204578
01:AAFA 6563757465206120
01:AB02 70726F6772616D
01:AB09 0D
01:AB0A 0A
01:AB0B 2D20535953494E46	    75: 	db		"- SYSINFO: System information",CR,LF
01:AB13 4F3A205379737465
01:AB1B 6D20696E666F726D
01:AB23 6174696F6E
01:AB28 0D
01:AB29 0A
01:AB2A 2D20575249544520	    76: 	db		"- WRITE AAAA BB [BB]...: Write to RAM",CR,LF
01:AB32 4141414120424220
01:AB3A 5B42425D2E2E2E3A
01:AB42 2057726974652074
01:AB4A 6F2052414D
01:AB4F 0D
01:AB50 0A
01:AB51 2D205A45524F3A20	    77: 	db		"- ZERO: Zero free RAM, banks included",CR,LF
01:AB59 5A65726F20667265
01:AB61 652052414D2C2062
01:AB69 616E6B7320696E63
01:AB71 6C75646564
01:AB76 0D
01:AB77 0A
01:AB78 0A              	    78: 	db		LF
01:AB79 202A205479706520	    79: 	db		" * Type ? in command parameter for help",CR,LF
01:AB81 3F20696E20636F6D
01:AB89 6D616E6420706172
01:AB91 616D657465722066
01:AB99 6F722068656C70
01:ABA0 0D
01:ABA1 0A
01:ABA2 0A              	    80: 	db		LF,0
01:ABA3 00
                        	    81: 
                        	    82: FlagBits:
01:ABA4 737A68766E63    	    83: 	db		"szhvnc"				; Flag short hand. Use UpperCase to indicate set, else lowercase indicated clear
                        	    84: 	
                        	    85: ClearScreenSeq:
01:ABAA 1B              	    86: 	db		ESC, "[", "2", "J"		; Clears the screen
01:ABAB 5B
01:ABAC 32
01:ABAD 4A
01:ABAE 1B              	    87: 	db		ESC, "[", "0", "1", ";", "0", "1", "H", 0 ; Sets to home position
01:ABAF 5B
01:ABB0 30
01:ABB1 31
01:ABB2 3B
01:ABB3 30
01:ABB4 31
01:ABB5 48
01:ABB6 00
                        	    88: 	
                        	    89: SysInfoMsg:
                        	    90: 	;		"                                        "
01:ABB7 0A              	    91: 	db		LF
01:ABB8 5A65644569676874	    92: 	db		"ZedEighty System Information",CR,LF,0
01:ABC0 792053797374656D
01:ABC8 20496E666F726D61
01:ABD0 74696F6E
01:ABD4 0D
01:ABD5 0A
01:ABD6 00
01:ABD7 2D204350553A2020	    93: 	db		"- CPU:   Z84C00 Z80 @",0,"7.3728 MHz",CR,LF
01:ABDF 205A383443303020
01:ABE7 5A38302040
01:ABEC 00
01:ABED 372E33373238204D
01:ABF5 487A
01:ABF7 0D
01:ABF8 0A
01:ABF9 2D20524F4D3A2020	    94: 	db		"- ROM:   64KB FLASH (Shadow ROM)",CR,LF
01:AC01 2036344B4220464C
01:AC09 4153482028536861
01:AC11 646F7720524F4D29
01:AC19 0D
01:AC1A 0A
01:AC1B 2D2052414D3A2020	    95: 	db		"- RAM:   64KB SRAM, ",0," bytes free",CR,LF
01:AC23 2036344B42205352
01:AC2B 414D2C20
01:AC2F 00
01:AC30 2062797465732066
01:AC38 726565
01:AC3B 0D
01:AC3C 0A
01:AC3D 2D2042414E4B533A	    96: 	db		"- BANKS: 480KB (15x 32KB in lower RAM)",CR,LF
01:AC45 203438304B422028
01:AC4D 3135782033324B42
01:AC55 20696E206C6F7765
01:AC5D 722052414D29
01:AC63 0D
01:AC64 0A
01:AC65 2D20554152543A20	    97: 	db		"- UART:  Z84C40 SIO/0",CR,LF
01:AC6D 205A383443343020
01:AC75 53494F2F30
01:AC7A 0D
01:AC7B 0A
01:AC7C 0A              	    98: 	db		LF,0
01:AC7D 00
                        	    99: 
                        	   100: 
                        	   101: 
                        	   102: 
                        	   103: ;  __  __                                                 
                        	   104: ; |  \/  |   ___   ___   ___    __ _    __ _    ___   ___ 
                        	   105: ; | |\/| |  / _ \ / __| / __|  / _` |  / _` |  / _ \ / __|
                        	   106: ; | |  | | |  __/ \__ \ \__ \ | (_| | | (_| | |  __/ \__ \
                        	   107: ; |_|  |_|  \___| |___/ |___/  \__,_|  \__, |  \___| |___/
                        	   108: ;                                      |___/
                        	   109: ; ---------------------------------------------------------------------------------------------------------------------
                        	   110: ; SYSTEM MESSAGES, AND ERROR MESSAGES
                        	   111: 
                        	   112: 
01:AC7E 436F6D6D616E6420	   113: ParseInvalidErr:		db	"Command not found or invalid syntax",CR,LF,0
01:AC86 6E6F7420666F756E
01:AC8E 64206F7220696E76
01:AC96 616C69642073796E
01:AC9E 746178
01:ACA1 0D
01:ACA2 0A
01:ACA3 00
01:ACA4 496E76616C696420	   114: InvalidHexDigitErr:		db	"Invalid hexadecimal digit in parameter",CR,LF,0
01:ACAC 6865786164656369
01:ACB4 6D616C2064696769
01:ACBC 7420696E20706172
01:ACC4 616D65746572
01:ACCA 0D
01:ACCB 0A
01:ACCC 00
01:ACCD 546F6F206D616E79	   115: TooManyDigitsErr:		db	"Too many number of digits in parameter",CR,LF,0
01:ACD5 206E756D62657220
01:ACDD 6F66206469676974
01:ACE5 7320696E20706172
01:ACED 616D65746572
01:ACF3 0D
01:ACF4 0A
01:ACF5 00
01:ACF6 4D697373696E6720	   116: MissingParameterErr:	db	"Missing Parameter(s)",CR,LF,0
01:ACFE 506172616D657465
01:AD06 72287329
01:AD0A 0D
01:AD0B 0A
01:AD0C 00
01:AD0D 556E7265636F676E	   117: UnrecognizedParamErr:	db	"Unrecognized parameter",CR,LF,0
01:AD15 697A656420706172
01:AD1D 616D65746572
01:AD23 0D
01:AD24 0A
01:AD25 00
01:AD26 5374617274206772	   118: StartGreaterEndErr:		db	"Start greater than end address",CR,LF,0
01:AD2E 6561746572207468
01:AD36 616E20656E642061
01:AD3E 646472657373
01:AD44 0D
01:AD45 0A
01:AD46 00
01:AD47 5265636F72642074	   119: IntelHexUnsupportedErr:	db	"Record type unsupported: ",0
01:AD4F 79706520756E7375
01:AD57 70706F727465643A
01:AD5F 20
01:AD60 00
01:AD61 5265736572766564	   120: InvalidVectorRangeErr:	db	"Reserved vector/stack area",CR,LF,0
01:AD69 20766563746F722F
01:AD71 737461636B206172
01:AD79 6561
01:AD7B 0D
01:AD7C 0A
01:AD7D 00
01:AD7E 5265736572766564	   121: ReservedBiosAreaErr:	db	"Reserved BIOS range",CR,LF,0
01:AD86 2042494F53207261
01:AD8E 6E6765
01:AD91 0D
01:AD92 0A
01:AD93 00
01:AD94 52616E6765206973	   122: RangeTooSmallErr:		db	"Range is null or too small",CR,LF,0
01:AD9C 206E756C6C206F72
01:ADA4 20746F6F20736D61
01:ADAC 6C6C
01:ADAE 0D
01:ADAF 0A
01:ADB0 00
01:ADB1 496E76616C696420	   123: InvalidBankNumberErr:	db	"Invalid bank number ($0-$E)",CR,LF,0
01:ADB9 62616E6B206E756D
01:ADC1 626572202824302D
01:ADC9 244529
01:ADCC 0D
01:ADCD 0A
01:ADCE 00
01:ADCF 496E76616C696420	   124: InvalidDecimalNumberErr	db	"Invalid decimal number",CR,LF,0
01:ADD7 646563696D616C20
01:ADDF 6E756D626572
01:ADE5 0D
01:ADE6 0A
01:ADE7 00
01:ADE8 4E756D6265722069	   125: NumberOutOfRangeErr		db	"Number is out of range",CR,LF,0
01:ADF0 73206F7574206F66
01:ADF8 2072616E6765
01:ADFE 0D
01:ADFF 0A
01:AE00 00
01:AE01 4572726F72206174	   126: BadMemory1Err:			db	"Error at ",0
01:AE09 20
01:AE0A 00
01:AE0B 2C20676F7420    	   127: BadMemory2Err:			db	", got ",0,", expected ",0
01:AE11 00
01:AE12 2C20657870656374
01:AE1A 656420
01:AE1D 00
01:AE1E 4E6F7468696E6720	   128: NothingToCopyErr:		db	"Nothing to copy",CR,LF,0
01:AE26 746F20636F7079
01:AE2D 0D
01:AE2E 0A
01:AE2F 00
                        	   129: 
01:AE30 54657374696E6720	   130: TestingBankNumberMsg:	db	"Testing Bank RAM #",0
01:AE38 42616E6B2052414D
01:AE40 2023
01:AE42 00
01:AE43 54657374696E6720	   131: TestingHighRamMsg:		db	"Testing High RAM",CR,LF,0
01:AE4B 486967682052414D
01:AE53 0D
01:AE54 0A
01:AE55 00
01:AE56 4D656D6F72792074	   132: MemoryTestPassedMsg:	db	"Memory test Passed",CR,LF,0
01:AE5E 6573742050617373
01:AE66 6564
01:AE68 0D
01:AE69 0A
01:AE6A 00
01:AE6B 4164647265737320	   133: RangeMsg:				db	"Address range:",0
01:AE73 72616E67653A
01:AE79 00
01:AE7A 46696C6520747261	   134: IntelHexFinishedMsg:	db	"File transfer: ",0
01:AE82 6E736665723A20
01:AE89 00
01:AE8A 756E737563636573	   135: IntelHexSuccessMsg:		db	"unsuccessful",CR,LF,0
01:AE92 7366756C
01:AE96 0D
01:AE97 0A
01:AE98 00
01:AE99 4C6F616420612070	   136: IntelHexLoadMsg:		db	"Load a program using Intel Hex format",CR,LF,"Press ESC to cancel",CR,LF,0
01:AEA1 726F6772616D2075
01:AEA9 73696E6720496E74
01:AEB1 656C204865782066
01:AEB9 6F726D6174
01:AEBE 0D
01:AEBF 0A
01:AEC0 5072657373204553
01:AEC8 4320746F2063616E
01:AED0 63656C
01:AED3 0D
01:AED4 0A
01:AED5 00
01:AED6 5472616E73666572	   137: IntelHexAbortedMsg:		db	"Transfer aborted by user",CR,LF,0
01:AEDE 2061626F72746564
01:AEE6 2062792075736572
01:AEEE 0D
01:AEEF 0A
01:AEF0 00
01:AEF1 2062797465732074	   138: DownloadedBytesMsg:		db	" bytes transfered",CR,LF,0
01:AEF9 72616E7366657265
01:AF01 64
01:AF02 0D
01:AF03 0A
01:AF04 00
                        	   139: 
                        	   140: ;					"                                        "
01:AF05 46696C6C73206120	   141: FillHelp:		db	"Fills a range of memory with a byte.",CR,LF
01:AF0D 72616E6765206F66
01:AF15 206D656D6F727920
01:AF1D 7769746820612062
01:AF25 7974652E
01:AF29 0D
01:AF2A 0A
01:AF2B 50726F7465637473	   142: 				db	"Protects the vector areas and the BIOS.",CR,LF
01:AF33 2074686520766563
01:AF3B 746F722061726561
01:AF43 7320616E64207468
01:AF4B 652042494F532E
01:AF52 0D
01:AF53 0A
01:AF54 55736167653A2046	   143: 				db	"Usage: Fill 2400 A400 8A",CR,LF,LF,0
01:AF5C 696C6C2032343030
01:AF64 2041343030203841
01:AF6C 0D
01:AF6D 0A
01:AF6E 0A
01:AF6F 00
                        	   144: 
01:AF70 446973706C617973	   145: HexDumpHelp:	db	"Displays the content of memory. The",CR,LF
01:AF78 2074686520636F6E
01:AF80 74656E74206F6620
01:AF88 6D656D6F72792E20
01:AF90 546865
01:AF93 0D
01:AF94 0A
01:AF95 7365636F6E642070	   146: 				db	"second parameter is the number of lines.",CR,LF
01:AF9D 6172616D65746572
01:AFA5 2069732074686520
01:AFAD 6E756D626572206F
01:AFB5 66206C696E65732E
01:AFBD 0D
01:AFBE 0A
01:AFBF 55736167653A2044	   147: 				db	"Usage: DUMP 1000 4",CR,LF,LF,0
01:AFC7 554D502031303030
01:AFCF 2034
01:AFD1 0D
01:AFD2 0A
01:AFD3 0A
01:AFD4 00
                        	   148: 
01:AFD5 4C6F616420496E74	   149: IntelHexHelp:	db	"Load IntelHex binary programs via the",CR,LF
01:AFDD 656C486578206269
01:AFE5 6E6172792070726F
01:AFED 6772616D73207669
01:AFF5 6120746865
01:AFFA 0D
01:AFFB 0A
01:AFFC 53494F20506F7274	   150: 				db	"SIO Port A.",CR,LF
01:B004 20412E
01:B007 0D
01:B008 0A
01:B009 55736167653A204C	   151: 				db	"Usage: LOAD",CR,LF,LF,0
01:B011 4F4144
01:B014 0D
01:B015 0A
01:B016 0A
01:B017 00
                        	   152: 
                        	   153: Range:
01:B018 E5              	   154: 	push	HL
01:B019 216BAE          	   155: 	ld		HL,RangeMsg
01:B01C CDB080          	   156: 	call	PrintString
01:B01F E1              	   157: 	pop		HL
01:B020 C9              	   158: 	ret
                        	   159: 
                        	   160: InvalidVectorRange:
01:B021 E5              	   161: 	push	HL
01:B022 2161AD          	   162: 	ld		HL,InvalidVectorRangeErr
01:B025 CDB080          	   163: 	call	PrintString
01:B028 E1              	   164: 	pop		HL
01:B029 C9              	   165: 	ret
                        	   166: 
                        	   167: RangeTooSmall:
01:B02A E5              	   168: 	push	HL
01:B02B 2194AD          	   169: 	ld		HL,RangeTooSmallErr
01:B02E CDB080          	   170: 	call	PrintString
01:B031 E1              	   171: 	pop		HL
01:B032 C9              	   172: 	ret
                        	   173: 
                        	   174: BiosRange:
01:B033 E5              	   175: 	push	HL
01:B034 217EAD          	   176: 	ld		HL,ReservedBiosAreaErr
01:B037 CDB080          	   177: 	call	PrintString
01:B03A E1              	   178: 	pop		HL
01:B03B C9              	   179: 	ret
                        	   180: 
                        	   181: RangeInverted:
01:B03C E5              	   182: 	push	HL
01:B03D 2126AD          	   183: 	ld		HL,StartGreaterEndErr
01:B040 CDB080          	   184: 	call	PrintString
01:B043 E1              	   185: 	pop		HL
01:B044 C9              	   186: 	ret
                        	   187: 
                        	   188: NoParameter:
01:B045 E5              	   189: 	push	HL
01:B046 CDC289          	   190: 	call	PrintErrorPointer
01:B049 21F6AC          	   191: 	ld		HL,MissingParameterErr
01:B04C CDB080          	   192: 	call	PrintString
01:B04F E1              	   193: 	pop		HL
01:B050 C9              	   194: 	ret
                        	   195: 
                        	   196: InvalidBank:
01:B051 E5              	   197: 	push	HL
01:B052 21B1AD          	   198: 	ld		HL,InvalidBankNumberErr
01:B055 CDB080          	   199: 	call	PrintString
01:B058 E1              	   200: 	pop		HL
01:B059 C9              	   201: 	ret
                        	   202: 
                        	   203: TooManyDigits:
01:B05A E5              	   204: 	push	HL
01:B05B 21CDAC          	   205: 	ld		HL,TooManyDigitsErr
01:B05E CDB080          	   206: 	call	PrintString
01:B061 E1              	   207: 	pop		HL
01:B062 C9              	   208: 	ret
                        	   209: 
                        	   210: InvalidHexDigit:
01:B063 E5              	   211: 	push	HL
01:B064 21A4AC          	   212: 	ld		HL,InvalidHexDigitErr
01:B067 CDB080          	   213: 	call	PrintString
01:B06A E1              	   214: 	pop		HL
01:B06B C9              	   215: 	ret
                        	   216: 
                        	   217: NumberOutOfRange:
01:B06C E5              	   218: 	push	HL
01:B06D 21E8AD          	   219: 	ld		HL,NumberOutOfRangeErr
01:B070 CDB080          	   220: 	call	PrintString
01:B073 E1              	   221: 	pop		HL
01:B074 C9              	   222: 	ret
                        	   223: 
                        	   224: InvalidDecimalNumber:
01:B075 E5              	   225: 	push	HL
01:B076 21CFAD          	   226: 	ld		HL,InvalidDecimalNumberErr
01:B079 CDB080          	   227: 	call	PrintString
01:B07C E1              	   228: 	pop		HL
01:B07D C9              	   229: 	ret
                        	   230: 
                        	   231: NothingToCopy:
01:B07E E5              	   232: 	push	HL
01:B07F CDC588          	   233: 	call	DecErrorPointer
01:B082 CDC289          	   234: 	call	PrintErrorPointer
01:B085 211EAE          	   235: 	ld		HL,NothingToCopyErr
01:B088 CDB080          	   236: 	call	PrintString
01:B08B E1              	   237: 	pop		HL
01:B08C C9              	   238: 	ret
                        	   239: 	

Source: "main.asm"
                        	   276: 
                        	   277: 
                        	   278: ; __     __                 _           _       _              
                        	   279: ; \ \   / /   __ _   _ __  (_)   __ _  | |__   | |   ___   ___ 
                        	   280: ;  \ \ / /   / _` | | '__| | |  / _` | | '_ \  | |  / _ \ / __|
                        	   281: ;   \ V /   | (_| | | |    | | | (_| | | |_) | | | |  __/ \__ \
                        	   282: ;    \_/     \__,_| |_|    |_|  \__,_| |_.__/  |_|  \___| |___/
                        	   283: ;
                        	   284: ; ---------------------------------------------------------------------------------------------------------------------
                        	   285: ; VARIABLES ARE DECLARED IN BYTE SIZE
                        	   286: 
01:B08D 00              	   287: CommandBuffer:		ds	HorizTextRes; Command prompt buffer
01:B08E *
01:B0B5 00              	   288: BufferPointer:		ds	2			; Buffer pointer
01:B0B6 *
01:B0B7 00              	   289: CmdErrorPointer:	ds	1			; Command line error pointer
01:B0B8 00              	   290: CurrentBank:		ds	1			; Keep track of current bank
01:B0B9 00              	   291: CurrentAddress:		ds	2			; Current Address for prompt
01:B0BA *
01:B0BB 00              	   292: CurrentPort:		ds	1			; Current I/O port
01:B0BC 00              	   293: DigitString			ds	9			; Digit string for numeric conversions (so they are printable with PrintString)
01:B0BD *
01:B0C5 0200            	   294: ParseSaveHL			dw	2			; Saves the HL, as HL is used to call routines, and interferes with registers
01:B0C7 00              	   295: RegA:				ds	1			; Register A
01:B0C8 00              	   296: RegBC:				ds	2			; Register BC
01:B0C9 *
01:B0CA 00              	   297: RegDE:				ds	2			; Register DE
01:B0CB *
01:B0CC 00              	   298: RegHL:				ds	2			; Register HL
01:B0CD *
01:B0CE 00              	   299: RegIX:				ds	2			; Index IX
01:B0CF *
01:B0D0 00              	   300: RegIY:				ds	2			; Index IY
01:B0D1 *
01:B0D2 00              	   301: StackPtr:			ds	2			; Index SP
01:B0D3 *
01:B0D4 00              	   302: FlagsReg:			ds	1			; Status flags
                        	   303: ;RegI:				ds	1			; 
                        	   304: ;RegR:				ds	1			; 
01:B0D5 00              	   305: StartAddress:		ds	2			; Original start or source address
01:B0D6 *
01:B0D7 00              	   306: EndAddress:			ds	2			; Original end or destination address
01:B0D8 *
01:B0D9 00              	   307: StartAddressAlt:	ds	2			; Original start or source address
01:B0DA *
01:B0DB 00              	   308: EndAddressAlt: 		ds	2			; Original end or destination address
01:B0DC *
01:B0DD 00              	   309: ByteTransfer:		ds	1			; Byte to copy/transfer
01:B0DE 00              	   310: UserCodeSize:		ds	2			; Size of uploaded user code
01:B0DF *
                        	   311: 
                        	   312: EndOfCode:
01:B0E0 FF              	   313: 	ds	VectorTable-$,0xFF			; Fill gap with 0xFF to optimize speed when programming the FLASH/EEPROM
01:B0E1 *
                        	   314: 
                        	   315: 
                        	   316: ; __     __                _                      _____           _       _        
                        	   317: ; \ \   / /   ___    ___  | |_    ___    _ __    |_   _|   __ _  | |__   | |   ___ 
                        	   318: ;  \ \ / /   / _ \  / __| | __|  / _ \  | '__|     | |    / _` | | '_ \  | |  / _ \
                        	   319: ;   \ V /   |  __/ | (__  | |_  | (_) | | |        | |   | (_| | | |_) | | | |  __/
                        	   320: ;    \_/     \___|  \___|  \__|  \___/  |_|        |_|    \__,_| |_.__/  |_|  \___|
                        	   321: ;
                        	   322: ; ---------------------------------------------------------------------------------------------------------------------
                        	   323: ; CONSTANT VALUES SO EXTERNALLY LOADED PROGRAMS CAN ACCESS SPECIFIC INFORMATION
                        	   324: 	.org	0xFD00
                        	   325: 
                        	   326: VectorTable:
                        	   327: 
02:FD00 8000            	   328: IntVectorEnd:		dw	InterruptVectorEnd	;= 0xFD00			; End of interrupt vector table
02:FD02 00FD            	   329: VectorTableStart:	dw	VectorTable			;= 0xFD02			; Start of vector and jump tables
02:FD04 0080            	   330: CodeStartAddr:		dw	StartOfCode			;= 0xFD04			; Start of code address
02:FD06 E0B0            	   331: CodeEndAddr:		dw	EndOfCode			;= 0xFD06			; End of code address
                        	   332: 
02:FD08 FF              	   333: 	ds	JumpTable-$,0xFF				; 0xFF up to the jump table
02:FD09 *
                        	   334: 
                        	   335: 
                        	   336: ;      _                                 _____           _       _        
                        	   337: ;     | |  _   _   _ __ ___    _ __     |_   _|   __ _  | |__   | |   ___ 
                        	   338: ;  _  | | | | | | | '_ ` _ \  | '_ \      | |    / _` | | '_ \  | |  / _ \
                        	   339: ; | |_| | | |_| | | | | | | | | |_) |     | |   | (_| | | |_) | | | |  __/
                        	   340: ;  \___/   \__,_| |_| |_| |_| | .__/      |_|    \__,_| |_.__/  |_|  \___|
                        	   341: ;                             |_|                                         
                        	   342: ; ---------------------------------------------------------------------------------------------------------------------
                        	   343: ; JUMP TABLE TO CALL ROUTINES FROM AN EXTERNAL PROGRAM
                        	   344: 
                        	   345: 	.org	0xFE00
                        	   346: 	
                        	   347: JumpTable:
03:FE00 C36B81          	   348: 	jp		Ascii2HexNibble		;= 0xFE00				; [A -> A][A -> A]
03:FE03 C38F81          	   349: 	jp		Ascii2HexByte		;= 0xFE03				; [(HL) -> A][(HL) -> A]
03:FE06 C3AE81          	   350: 	jp		Ascii2HexWord		;= 0xFE06				; [(HL) -> BC][(HL) -> BC]
03:FE09 C3AC82          	   351: 	jp		ClearScreen			;= 0xFE09				; [][]
03:FE0C C3CF88          	   352: 	jp		GetHexParameter		;= 0xFE0C				; [(HL) -> BC,A,(HL)][(HL) -> BC,A,(HL)]
03:FE0F C37680          	   353: 	jp		PrintChar			;= 0xFE0F				; [A ->][A ->]
03:FE12 C3B080          	   354: 	jp		PrintString			;= 0xFE12				; [HL ->][HL ->]
03:FE15 C38180          	   355: 	jp		PrintCRLF			;= 0xFE15				; [][]
03:FE18 C3A080          	   356: 	jp		PrintNibble			;= 0xFE18				; [A ->][A ->]
03:FE1B C36380          	   357: 	jp		PrintByte			;= 0xFE1B				; [A ->][A ->]
03:FE1E C3BE80          	   358: 	jp		PrintWord			;= 0xFE1E				; [HL ->][HL ->]
03:FE21 C3DA89          	   359: 	jp		RangeValidation		;= 0xFE21				; Start&EndAddress -> C, Start&EndAddress, Start&EndAddressAlt)
03:FE24 C3C980          	   360: 	jp		ReadChar			;= 0xFE24				; [-> A][-> A]
03:FE27 C3D280          	   361: 	jp		ReadCharNoWait		;= 0xFE27
03:FE2A C3F080          	   362: 	jp		ReadString			;= 0xFE2A				; [HL ->][HL ->]
03:FE2D C3DD80          	   363: 	jp		ReadByte			;= 0xFE2D				; [-> A][-> A]
03:FE30 C33F81          	   364: 	jp		ReadWord			;= 0xFE30				; [-> HL][-> HL]
03:FE33 C33D8B          	   365: 	jp		SkipSpaces			;= 0xFE33				; [HL -> HL][HL -> HL]
03:FE36 C3A182          	   366: 	jp		UpperCase			;= 0xFE36				; [A -> A][A -> A]
03:FE39 C35486          	   367: 	jp		Registers			;= 0xFE39				; [][]
03:FE3C C3C181          	   368: 	jp		Dec2Hex				;= 0xFE3C				; [(HL) -> BC]
                        	   369: 
                        	   370: VectorEnd:
03:FE3F FF              	   371: 	ds		StackPage-$,0xFF		; 0xFF the rest of the jump table all the way to the stack area
03:FE40 *
                        	   372: 
                        	   373: 
                        	   374: ;  ____    _                    _    
                        	   375: ; / ___|  | |_    __ _    ___  | | __
                        	   376: ; \___ \  | __|  / _` |  / __| | |/ /
                        	   377: ;  ___) | | |_  | (_| | | (__  |   < 
                        	   378: ; |____/   \__|  \__,_|  \___| |_|\_\
                        	   379: ;
                        	   380: ; ---------------------------------------------------------------------------------------------------------------------
                        	   381: ; STACK AREA, ClEAR OUT WITH ZEROS
                        	   382: 
                        	   383: 	.org	0xFF00
                        	   384: 
                        	   385: StackPage:
                        	   386: 
04:FF00 00              	   387: 	ds		0xFFFF-$,0x00			; Zero the stack all the way to end of ROM
04:FF01 *
                        	   388: 
                        	   389: BiosEnd:
                        	   390: .end


Symbols by name:
ABPASS                           A:9BF8
ABS                              A:A244
ACCSUM                           A:9468
ACPASS                           A:9BF7
ADD30                            A:A756
ADD301                           A:A76A
ADDEXP                           A:A1DD
ADDIG                            A:A383
ADDPHL                           A:9FCA
ALLFOL                           A:9EC6
ANTVLU                           A:9761
ARET                             A:A6D4
ARETN                            A:A823
ARLDSV                           A:9B18
ARREND                           E:10DA
ARRLP                            A:9D91
ASCC                             A:9E97
Ascii2BcdDigit                   A:816B
Ascii2HexByte                    A:818F
Ascii2HexByteErr                 A:81AB
Ascii2HexNibble                  A:816B
Ascii2HexNibbleEnd               A:8188
Ascii2HexNibbleErr               A:818D
Ascii2HexNibbleOK                A:8180
Ascii2HexWord                    A:81AE
Ascii2HexWordErr                 A:81BE
ASCTFP                           A:A326
ASPCS                            A:96C3
ATN                              A:A688
ATN1                             A:A6A5
ATNTAB                           A:A6AF
ATOH                             A:94A3
BADINP                           A:96E8
BadMemory1Err                    A:AE01
BadMemory2Err                    A:AE0B
BAKSTK                           A:8F25
BAKTMP                           A:9E77
BankCopyLoop                     A:0083
BankSelect                       E:0030
BASIC                            A:8B4B
BASTXT                           E:105E
BCDEFP                           A:A26B
BFREE                            A:8C77
BIN                              A:A7AC
BIN2                             A:A7B2
BINERR                           A:A809
BINIT                            A:A7E8
BINTFP                           A:A7DE
BiosEnd                          A:FFFF
BiosRange                        A:B033
BITOUT                           A:A7C6
BITOUT2                          A:A7CA
BKSP                             E:0008
BN                               E:0028
BNORM                            A:A02A
BNRMLP                           A:A02D
BootMsg                          A:A835
BRK                              A:941A
BRKFLG                           E:104D
BRKLIN                           E:10CE
BRKMSG                           A:8F1F
BRKRET                           A:8C71
BS                               E:0010
BSERR                            A:9B4B
BUFFER                           E:1061
BufferPointer                    A:B0B5
BYT2ASC                          A:A74D
BytesFree                        E:CBA0
ByteTransfer                     A:B0DD
BYTSFT                           A:A162
Carry                            E:0000
CFEVAL                           A:9AAE
CHARTY                           A:9A5C
CheckIfCold                      A:8B5A
CheckIfWarm                      A:8B67
ChecksumErr                      E:0001
CHEKFN                           A:9C8F
CHKBIN                           A:A7FB
CHKLTR                           A:9475
CHKSTK                           A:8F59
CHKSUM                           E:104A
CHKSYN                           A:924A
CHKTYP                           A:9842
CHR                              A:9EA8
CLEAR                            A:94C8
ClearScreen                      A:82AC
ClearScreenSeq                   A:ABAA
CLOTST                           A:927F
CLREG                            A:90AE
CLRPTR                           A:9089
CLS                              A:A6D9
CmdErrorPointer                  A:B0B7
CMPFP                            A:A2B4
CMPLG1                           A:99C2
CMPLOG                           A:99C0
CMPNUM                           A:A29A
CMPRES                           A:9A04
CMPSTR                           A:99EC
CN                               E:0020
CNVNUM                           A:A332
CodeEndAddr                      A:FD06
CodeStartAddr                    A:FD04
COLD                             A:8BD0
ColdOrWarm                       A:8B54
COMMAN                           E:1043
CommandBuffer                    A:B08D
CommandList                      A:A8BE
CommandPrompt                    A:88A5
COMPL                            A:A08A
CONCAT                           A:9E0C
CONEXP                           A:A362
CONPOS                           A:A027
CONT                             A:944D
CONTAD                           E:10D4
CONVAR                           A:992D
CopyBlock                        A:82B5
CopyDestinationAddress           A:82CA
CopyEnd                          A:8315
CopyNoOverlap                    A:8309
CopyNoParameter                  A:830D
CopyNothing                      A:8312
CopyNumberOfBytes                A:82D8
CopySourceAddress                A:82BC
COPYY                            A:8BEA
COS                              A:A60C
COUNT                            A:92EF
CPDEHL                           A:9244
CPYLIT                           A:9180
CR                               E:000D
CRARLP                           A:9B6B
CREARY                           A:9B50
CRESTR                           A:95C7
CRNCLP                           A:90E1
CRTMST                           A:9CC8
CRTST                            A:9CD4
CRTSTE                           A:9CEA
CRUNCH                           A:90D8
CSTART                           A:8BDB
CTLOFG                           E:1045
CTRLC                            E:0003
CTRLG                            E:0007
CTRLO                            E:000F
CTRLQ                            E:0011
CTRLR                            E:0012
CTRLS                            E:0013
CTRLU                            E:0015
CUROPR                           E:10C5
CURPOS                           E:10AB
CurrentAddress                   A:B0B9
CurrentBank                      A:B0B8
CurrentPort                      A:B0BB
DATAA                            A:956E
DATFLG                           E:10AE
DATLIN                           E:10C9
DATSNR                           A:8F76
DCBCDE                           A:A2EB
DD                               E:0012
DDERR                            A:8F85
Dec2Hex                          A:81C1
Dec2HexEnd                       A:820B
Dec2HexInvalidDec                A:8204
Dec2HexLoop                      A:81CA
Dec2HexOutOfRange                A:81FE
Dec2HexShuffleRegs               A:81F8
DecErrorPointer                  A:88C5
DEEK                             A:A6F3
DEF                              A:9C0C
DEFSIZ                           A:9B73
DEINT                            A:9489
DEL                              E:007F
DELCHR                           A:91B0
DELIMITER                        E:0020
DEPINT                           A:9483
DETHL4                           A:A27A
DETHLB                           A:A27C
DiagMemoryAddr                   A:83AE
DiagMemoryError                  A:8397
Diagnostics                      A:831A
DiagnosticsBankLoop              A:8328
DiagnosticsEnd                   A:83D1
DiagnosticsEnd2                  A:83E1
DiagnosticsTest                  A:8363
DiagnosticsTestLoop              A:8366
DigitString                      A:B0BC
DIGTXT                           A:A42C
DIM                              A:9A2E
DIMRET                           A:9A25
DINPOS                           A:9279
DIV                              A:A173
DIV1                             E:100A
DIV10                            A:A167
DIV2                             E:100E
DIV3                             E:1012
DIV4                             E:1015
DIVLP                            A:A19A
DIVSUP                           E:1009
DOAGN                            A:90C7
DOCOM                            A:9694
DODEL                            A:9190
DOEBIT                           A:A46C
DOFN                             A:9C39
DOKE                             A:A6FE
DONULL                           A:9682
DOSPC                            A:96BE
DOTAB                            A:96AB
DownloadedBytesMsg               A:AEF1
DPOINT                           A:A35E
DTSTR                            A:9CD8
DVBCDE                           A:A175
DZ                               E:0014
DZERR                            A:8F7F
ECHDEL                           A:91A4
EDIGIT                           A:A3A5
EndAddress                       A:B0D7
EndAddressAlt                    A:B0DB
ENDBUF                           A:9187
ENDCON                           A:A371
ENDDIM                           A:9BD2
ENDINP                           A:967A
ENDNAM                           A:9A50
EndOfCode                        A:B0E0
ENDPRG                           A:9429
ENFMEM                           A:8F62
EOT                              E:00FF
ERRIN                            A:8FB0
ERRLIN                           E:10D2
ERRMSG                           A:8F0D
ERROR                            A:8F90
ERRORPTR                         E:005E
ErrorPtrOffset                   E:0009
ERRORS                           A:8E83
ESC                              E:001B
EVAL                             A:984F
EVAL1                            A:9852
EVAL2                            A:985B
EVAL3                            A:985E
EVLPAR                           A:9914
EVNOT                            A:9A0E
EXCUTE                           A:93B4
EXIT                             A:A832
EXPLP                            A:A350
EXPP                             A:A506
EXPTAB                           A:A546
EXPTEN                           A:A47E
EXTIG                            A:97BD
FANDT                            A:97E7
FC                               E:0008
FCERR                            A:949E
FDTLP                            A:97CE
FillByte                         A:8414
FillEndAddr                      A:8407
FillHelp                         A:AF05
FillMemory                       A:83EA
FillMemoryEnd                    A:8484
FillNoParameter                  A:8478
FillPrintHelp                    A:847E
FillRange1                       A:8426
FillRange2                       A:844E
FillStartAddr                    A:83F1
FINDEL                           A:9BAE
FlagBits                         A:ABA4
FlagCarryClear                   A:877E
FlagHalfClear                    A:875A
FlagNegativeClear                A:8772
FlagOverClear                    A:8766
FlagSignClear                    A:8742
FlagsReg                         A:B0D4
FlagZeroClear                    A:874E
FLGDIF                           A:A22A
FLGREL                           A:A231
FNARG                            E:10E0
FNCTAB                           A:8CC7
FNDARY                           A:9B1E
FNDELP                           A:9BB3
FNDEND                           A:905C
FNDNUM                           A:9F9B
FNDTOK                           A:92CE
FNDVAR                           A:9A95
FNDWRD                           A:910B
FNOFST                           A:993E
FNRGNM                           E:10DE
FNTHR                            A:9AA3
FNVAL                            A:9965
FOPRND                           A:9887
FOR                              A:931B
FORFLG                           E:10CB
FORFND                           A:934B
FORSLP                           A:932F
FPADD                            A:9FD9
FPBCDE                           A:A260
FPEXP                            E:10E7
FPINT                            A:A2C7
FPMULT                           A:A114
FPREG                            E:10E4
FPROND                           A:A071
FPSINT                           A:947D
FPTHL                            A:A277
FRE                              A:9BD6
FRENUM                           A:9BF2
FRMEVL                           A:9930
GARBGE                           A:9D59
GARBLP                           A:9D5C
GETCHR                           A:93D4
GETCMD                           A:8FD4
GetErrorPointerLoop              A:893B
GETHEX                           A:A787
GetHexParameter                  A:88CF
GETINP                           A:A6D5
GETINT                           A:9F9E
GETLEN                           A:9E8C
GETLIN                           A:91C1
GETLN                            A:94A4
GETNUM                           A:983D
GETNXT                           A:9126
GetParamCount                    A:88D5
GetParamErrorEnd                 A:894E
GetParameterEnd                  A:8932
GetParamFetch                    A:88E6
GetParamFetch0                   A:88EB
GetParamFetch1                   A:88F3
GetParamFetch2                   A:8903
GetParamFetch3                   A:8911
GetParamFetch4                   A:8927
GetParamHelp                     A:8934
GetParamHexError                 A:8948
GetParamNumberError              A:8939
GETSTR                           A:9E56
GETVAR                           A:9A33
GNXARY                           A:9D90
GOFUNC                           A:996D
GOSUB                            A:951A
GOTO                             A:952B
GRBARY                           A:9DB0
GRBDON                           A:9D31
GRBLP                            A:9D6A
GSTRCU                           A:9E59
GSTRDE                           A:9E5D
GSTRHL                           A:9E5C
GTFLNM                           A:9E9B
GTFNAM                           A:9A38
GTLNLP                           A:94A7
GTSIXD                           A:A3F6
GTVLUS                           A:9739
HALF                             A:A49D
HalfCarry                        E:0004
HALFPI                           A:A656
HaltCmd                          A:8489
HELP                             E:000F
HEX                              A:A715
HEX1                             A:A72E
HEX2                             A:A730
Hex2Dec                          A:820E
Hex2Dec1                         A:828B
Hex2Dec10                        A:826E
Hex2Dec100                       A:8251
Hex2Dec1000                      A:8234
Hex2Dec10000                     A:8219
Hex2Dec10000Loop                 A:821B
Hex2Dec10000Set                  A:822B
Hex2Dec1000Loop                  A:8236
Hex2Dec1000Set                   A:8248
Hex2Dec100Loop                   A:8253
Hex2Dec100Set                    A:8265
Hex2Dec10Loop                    A:8270
Hex2Dec10Set                     A:8282
Hex2DecEnd                       A:8298
HEX3                             A:A73E
HEX4                             A:A740
HexDefaultLines                  A:84B6
HexDisplayContent                A:84B8
HexDump                          A:848B
HexDumpEnd                       A:8502
HexDumpHelp                      A:AF70
HexDumpPrintHelp                 A:84FC
HEXIT                            A:A79E
HexLinesToRead                   A:84A3
HEXLP                            A:A77A
HEXLP1                           A:A77F
HexNextByte                      A:84C9
HexNextChar                      A:84DC
HexNextLine                      A:84B9
HexPrintChar                     A:84E9
HexReplaceDot                    A:84E7
HEXTFP                           A:A76E
HorizTextRes                     E:0028
HX                               E:0026
HXERR                            A:A7A7
ID                               E:0016
IDTEST                           A:9C81
IFF                              A:95FD
IFGO                             A:960B
IFJMP                            A:93BB
IncErrorPointer                  A:8950
INCHL                            A:A275
INCLEN                           A:9275
INDFND                           A:8F3F
INEWLN                           A:9024
INIT                             A:8BE2
INITAB                           A:8EAD
INITBE                           A:8F0D
INITST                           A:A81B
INMSG                            A:8F14
INP                              A:9F5B
INPBIN                           A:978B
INPBRK                           A:9426
INPORT                           E:103F
INPSUB                           E:103E
INPUT                            A:96F9
INRNG                            A:A3FF
INT                              A:A2F2
IntelHex                         A:8507
IntelHexAbort                    A:85AC
IntelHexAbortedMsg               A:AED6
IntelHexAddress                  A:8539
IntelHexByteCount                A:8534
IntelHexCheckOk                  A:857A
IntelHexChecksum                 A:856C
IntelHexData                     A:8561
IntelHexEnd                      A:85D0
IntelHexFinishedMsg              A:AE7A
IntelHexHelp                     A:AFD5
IntelHexLoadMsg                  A:AE99
IntelHexParamError               A:85C2
IntelHexPrintEndMsg              A:8587
IntelHexPrintHelp                A:85CA
IntelHexPrintNotOk               A:8599
IntelHexPrintStatus              A:857C
IntelHexRecordType               A:854E
IntelHexStartCode                A:8526
IntelHexSuccessMsg               A:AE8A
IntelHexUnsupported              A:85B4
IntelHexUnsupportedErr           A:AD47
InterruptVectorEnd               A:0080
INTVAR                           A:9098
IntVectorEnd                     A:FD00
InvalidBank                      A:B051
InvalidBankNumberErr             A:ADB1
InvalidDecimalNumber             A:B075
InvalidDecimalNumberErr          A:ADCF
InvalidHexDigit                  A:B063
InvalidHexDigitErr               A:ACA4
InvalidVectorRange               A:B021
InvalidVectorRangeErr            A:AD61
INVSGN                           A:A248
ITMSEP                           A:977C
JJUMP1                           A:A80E
JSTZER                           A:A488
JUMP                             E:00C3
JumpTable                        A:FE00
KILFOR                           A:982D
KILIN                            A:91BB
LastRec                          E:0007
LCRFLG                           E:10AC
LEFT                             A:9EB8
LEN                              A:9E88
LET                              A:9585
LETNUM                           A:95D8
LETSTR                           A:95A0
LF                               E:000A
LFRGNM                           A:9F51
LINEAT                           E:105C
LINEIN                           A:A3B1
LINES                            A:A6E4
LINESC                           E:1046
LINESN                           E:1048
LINFND                           A:900D
ListCmd                          A:85D7
LISTLP                           A:929C
ListOfCommands                   A:A93F
LISTT                            A:9290
LOADFP                           A:A26E
LOG                              A:A0D3
LOGTAB                           A:A0C6
LOKFOR                           A:8F29
LOOPST                           E:10C7
LS                               E:001C
LSTBIN                           E:10CC
LSTLP2                           A:92BC
LSTLP3                           A:92BF
LSTRAM                           E:10AF
LSTRND                           E:103A
LTSTND                           A:9796
LWIDTH                           E:1042
Main                             A:8046
MAKINT                           A:9FA1
MAKNUM                           A:A41B
MANLP                            A:A33A
MATCH                            A:9158
MEMMSG                           A:8CBC
MemoryTestPassedMsg              A:AE56
MID                              A:9EF2
MID1                             A:9EBE
MIDNUM                           A:9F56
MINCDE                           A:A019
MINUS                            A:991C
MissingParameterErr              A:ACF6
MKTMST                           A:9CC5
MLDBLP                           A:A313
MLDEBC                           A:A30B
MLOOP                            A:8C12
MLSP10                           A:A208
MO                               E:0024
MONITR                           A:A818
MONOUT                           A:A815
MORDT                            A:97A2
MORINP                           A:91CA
MOVBUF                           A:9043
MOVDIR                           A:9160
MOVLP                            A:8F4E
MOVSTR                           A:8F4B
MOVUP                            A:8F48
MRPRNT                           A:961D
MSIZE                            A:8BFF
MUL8LP                           A:A13F
MULLN2                           A:A10B
MULT8                            A:A136
MULTEN                           A:A37C
MULTT                            A:A112
MULVAL                           E:10F6
MVSTPT                           A:95CF
NEDMOR                           A:9735
NEGAFT                           A:A4B3
Negative                         E:0001
NEW                              A:9088
NEXITM                           A:96CE
NEXT                             A:97F2
NEXT1                            A:97F5
NF                               E:0000
NFERR                            A:8F82
NMI66                            A:0066
NOCHNG                           A:9150
NOENED                           A:A48B
NOLIN                            A:943C
NOMADD                           A:A150
NOMLAD                           A:A321
NoParameter                      A:B045
NOPMPT                           A:9713
NORMAL                           A:A044
NOSPC                            A:9147
NOSUB7                           A:A79A
NOSWAP                           A:9FF3
NOTAMP                           A:98F1
NothingToCopy                    A:B07E
NothingToCopyErr                 A:AE1E
NOTSTR                           A:9A6B
NOXOR                            A:9F81
NSCFOR                           A:9A7B
NULFLG                           E:1044
NULLL                            A:9460
NULLP                            A:9689
NULLS                            E:1041
NUMASC                           A:A3C4
NumberOutOfRange                 A:B06C
NumberOutOfRangeErr              A:ADE8
NXTARY                           A:9B32
NXTBYT                           A:9136
NXTCHR                           A:9177
NXTDAT                           E:10DC
NXTDTA                           A:956D
NXTITM                           A:972D
NXTOPR                           E:10D0
NXTSTL                           A:9574
NXTSTT                           A:9577
OD                               E:0006
OKMSG                            A:8F19
OM                               E:000C
OMERR                            A:8F71
ON                               A:95DF
ONGO                             A:95EE
ONGOLP                           A:95EF
ONJMP                            A:93BC
OPNPAR                           A:984B
OPRND                            A:98C6
OS                               E:001A
OTKLN                            A:91B8
OTPORT                           E:1007
OUTC                             A:9255
OUTEXP                           A:A47C
OUTIT                            A:9236
OUTNBS                           A:923C
OUTNCR                           A:A82C
OUTSUB                           E:1006
OUTWRD                           A:92D8
OV                               E:000A
Overflow                         E:0002
OVERR                            A:8F8B
OVTST1                           A:A1FB
OVTST2                           A:A200
OVTST3                           A:A201
PADD                             A:A3A0
PAND                             A:9987
ParseEnd                         A:89BB
ParseExecute                     A:89A6
ParseInvalid                     A:89B5
ParseInvalidErr                  A:AC7E
ParseNextChar                    A:8974
ParseNextCmd                     A:898C
Parser                           A:895A
ParseSaveHL                      A:B0C5
ParseValidate                    A:899D
PASSA                            A:9C07
PBUFF                            E:10E9
PEEK                             A:9FAF
PeekAddress                      A:85EC
PeekCmd                          A:85E6
PeekEnd                          A:8610
PeekError                        A:8610
PeekNoParameter                  A:860A
PeekRead                         A:85F6
PEND                             A:9421
PHLTFP                           A:A25D
PLUCDE                           A:A07E
PNORM                            A:A04C
POINT                            E:1051
POKE                             A:9FB6
PokeCmd                          A:8614
PokeEnd                          A:8650
PokeError                        A:8650
PokeGetByte                      A:8628
PokeGetPort                      A:861A
PokeNoParameter                  A:864A
PokeWrite                        A:8633
POPAF                            A:9D4B
POPHL                            A:9E75
POPHRT                           A:A160
POPNOK                           A:8FC6
POR                              A:9986
POR1                             A:99A9
POS                              A:9C04
POSINT                           A:9480
POUT                             A:9F67
POWER                            A:A4C1
POWER1                           A:A4D1
POWER2                           A:A4EE
POWERS                           A:A4A1
PrintByte                        A:8063
PrintChar                        A:8076
PrintCharTxWait                  A:8077
PrintCRLF                        A:8081
PrintDec                         A:805A
PrintErrorLoop                   A:89C8
PrintErrorPointer                A:89C2
PrintLine                        A:808E
PrintLineLoop                    A:8095
PrintNibble                      A:80A0
PrintNibbleEnd                   A:80AB
PrintString                      A:80B0
PrintStringEnd                   A:80BC
PrintStringLoop                  A:80B1
PRINTT                           A:9621
PrintWord                        A:80BE
PRITAB                           A:8E6E
PRNTHL                           A:A3B9
PRNTLP                           A:9624
PRNTNB                           A:9667
PRNTOK                           A:8FC7
PRNTST                           A:966B
PRNUMS                           A:9D15
PROCES                           A:91E3
PROGND                           E:10D6
PROGST                           E:10F9
PROMPT                           A:90CB
PRS                              A:9D16
PRS1                             A:9D19
PRSLP                            A:9D20
PSET                             E:1054
PSUB                             A:9FD4
PTRLP                            A:9050
PUTBUF                           A:9222
PUTCTL                           A:9227
PUTFID                           A:9390
QTSTLP                           A:9CDB
QTSTR                            A:9CD5
QUARTR                           A:A65A
Range                            A:B018
RangeInverted                    A:B03C
RangeMsg                         A:AE6B
RangeTooSmall                    A:B02A
RangeTooSmallErr                 A:AD94
RangeValidation                  A:89DA
RangeValidationEnd               A:8B31
RangeValidationError             A:8B2D
READ                             A:9728
ReadByte                         A:80DD
ReadChar                         A:80C9
ReadCharNoWait                   A:80D2
READFG                           E:10CD
ReadString                       A:80F0
ReadStringBS                     A:811B
ReadStringChar                   A:80F8
ReadStringCR                     A:8135
ReadStringESC                    A:8134
ReadStringSave                   A:810F
ReadWord                         A:813F
REDO                             A:96D5
RegA                             A:B0C7
RegBC                            A:B0C8
RegDE                            A:B0CA
RegHL                            A:B0CC
Registers                        A:8654
RegIX                            A:B0CE
RegIY                            A:B0D0
REM                              A:9570
RESDIV                           A:A1AD
RESEED                           A:A5F8
ReservedBiosAreaErr              A:AD7E
RESET                            E:1057
ResetErrorPointer                A:8B35
RESTNL                           A:93F9
RESTOR                           A:93E4
RESZER                           A:A03F
RETADR                           A:9AE2
RETINT                           A:A236
RETLIN                           A:9568
RETNAD                           A:915C
RETNUL                           A:9AE5
RETNUM                           A:9928
RETREL                           A:A228
RETURN                           A:9549
RG                               E:0004
RIGHT                            A:9EE8
RIGHT1                           A:9EBC
RINPUT                           E:104E
RLTLP                            A:986B
RND                              A:A597
RND1                             A:A5D3
RND2                             A:A5EF
RNDTAB                           A:A600
RNGTST                           A:A48E
ROMCopy                          A:0098
RomDisable                       E:0038
RONDB                            A:A060
RONDUP                           A:A05F
ROUND                            A:9FC7
RSCALE                           A:A39A
RSLNBK                           A:9312
RST00                            A:0000
RST08                            A:0008
RST10                            A:0010
RST18                            A:0018
RST20                            A:0020
RST28                            A:0028
RST30                            A:0030
RST38                            A:0038
RSTSTR                           A:9F0B
RUN                              A:950E
RunCallBC                        A:879E
RUNCNT                           A:9394
RunCode                          A:878E
RunEnd                           A:87A0
RUNFST                           A:9094
RUNLIN                           A:952A
SAVEXP                           A:A040
SAVSTP                           A:9387
SAVSTR                           A:9CB0
SBSCPT                           A:9AF0
SCALE                            A:A09E
SCALLP                           A:A0A0
SCALMI                           A:A365
SCALPL                           A:A37B
SCNEND                           A:9DE7
SCPTLP                           A:9AF6
SEARCH                           A:9124
SEED                             E:1017
SetAddress                       A:87A1
SetAddressDefault                A:87B7
SetAddressEnd                    A:87BD
SetBank                          A:87C2
SetBankDefault                   A:87E2
SetBankEnd                       A:87EE
SetBankError                     A:87EB
SETIO                            A:9F8B
SETLIN                           A:92E6
SETLIT                           A:916E
SETPTR                           A:904B
SETTOP                           A:8C36
SFTPRG                           A:9015
SGN                              A:A22E
SGNEXP                           A:9976
SGNRES                           E:10E8
ShadowCopy                       A:0080
SHRITE                           A:A0AD
SHRLP                            A:A0B0
SHRT1                            A:A0B4
Sign                             E:0007
SIGNON                           A:8C86
SignOnMsg                        A:8B74
SIGNS                            A:A285
SIN                              A:A612
SIN1                             A:A642
SINTAB                           A:A65E
SIO_Init                         A:814D
SIO_PortA_Ctrl                   E:0006
SIO_PortA_Data                   E:0004
SIXDIG                           A:A3E1
SkipSpaces                       A:8B3D
SkipSpacesEnd                    A:8B49
SkipSpacesLoop                   A:8B3E
SMPVAR                           A:9D7B
SMSER1                           A:A576
SN                               E:0002
SNERR                            A:8F7C
SPCFST                           A:A3D2
SPCLP                            A:96C7
SQR                              A:A4B8
SRCHLN                           A:9068
SRCHLP                           A:906B
SSTSA                            A:9E43
ST                               E:001E
STACK                            E:1066
StackPage                        A:FF00
StackPtr                         A:B0D2
STAKFP                           A:A250
STALL                            A:940E
StartAddr                        E:0000
StartAddress                     A:B0D5
StartAddressAlt                  A:B0D9
StartGreaterEndErr               A:AD26
StartOfCode                      A:8000
STKTHS                           A:98AF
STLOOK                           E:115D
STOPP                            A:941F
STORED                           A:94EB
STPOOL                           A:9DBE
STR1                             A:9CA6
STRADD                           A:9DC1
STRBOT                           E:10C3
STRENT                           A:977F
STRR                             A:9CA0
STRSPC                           E:105A
STTLIN                           A:9672
SUBCDE                           A:9FD6
SUBPHL                           A:9FD0
SUMLP                            A:A57F
SUMSER                           A:A567
SUPTLZ                           A:A460
SVNAM2                           A:9A4F
SVSTAD                           A:9CCE
SysInfo                          A:87F3
SysInfoMsg                       A:ABB7
TAN                              A:A673
TestingBankNumberMsg             A:AE30
TestingHighRamMsg                A:AE43
TESTOS                           A:9D4D
TESTR                            A:9D2F
TM                               E:0018
TMERR                            A:8F8E
TMPSTR                           E:10BF
TMSTPL                           E:10B3
TMSTPT                           E:10B1
TooManyDigits                    A:B05A
TooManyDigitsErr                 A:ACCD
TOPOOL                           A:9EB4
TOSTRA                           A:9E4C
TRYAGN                           A:A43B
TSALP                            A:9E4D
TSTBIT                           A:A825
TSTBRK                           A:93FF
TSTMEM                           A:8C24
TSTNUM                           A:9840
TSTOPL                           A:9CF6
TSTRED                           A:99AE
TSTREM                           A:9171
TSTSGN                           A:A21F
TSTSTR                           A:9841
TTYLIN                           A:91C1
TYPE                             E:10AD
UF                               E:0022
UFERR                            A:8F88
UL                               E:000E
ULERR                            A:9544
UNITY                            A:A0C2
UnrecognizedParamErr             A:AD0D
UPDATA                           A:93FA
UpperCase                        A:82A1
UpperCaseEnd                     A:82AB
UserCodeSize                     A:B0DE
USR                              E:1003
VAL                              A:9F22
VAL1                             A:9F40
VAL2                             A:9F4A
VAL3                             A:9F4D
ValBiosOverlap                   A:8AA2
ValBiosRangeError                A:8B1B
ValCheckBiosHi                   A:8A3D
ValCheckBiosLow                  A:8A32
ValCheckHigh                     A:8A4B
ValCheckHighBios                 A:8A71
ValCheckHighLimit                A:8A15
ValCheckHighLimit2               A:8A26
ValCheckIfZeroDataHigh           A:8ACE
ValCheckIfZeroDataLow            A:8ABE
ValCheckInverted                 A:89E8
ValCheckLow                      A:8A7F
ValCheckLowBios                  A:8A99
ValCheckLowLimit                 A:89F8
ValCheckLowLimit2                A:8A09
ValInvertedError                 A:8B27
ValPrintRange                    A:8ADE
ValPrintRange1                   A:8AE1
ValPrintRange2                   A:8AFB
ValPrintRangeEnd                 A:8B15
ValRangeTooSmallError            A:8B21
VAREND                           E:10D8
VectorCopy                       A:00A3
VectorEnd                        A:FE3F
VectorTable                      A:FD00
VectorTableStart                 A:FD02
VertTextRes                      E:0018
WAIT                             A:9F6D
WAITLP                           A:9F82
WARM                             A:8C6E
WIDTH                            A:A6DC
WORDS                            A:8CFF
WORDTB                           A:8E22
Write                            A:8810
WriteEnd                         A:885B
WriteFirstByte                   A:8823
WriteGetAddress                  A:8817
WriteNoParameter                 A:8858
WriteRemainingBytes              A:8837
WriteTooManyDigits               A:884D
WRKSPC                           E:1000
ZDATA                            E:0083
ZEND                             E:0080
ZEQUAL                           E:00B4
ZERARY                           A:9B91
ZERBYT                           E:8F18
Zero                             E:0006
ZeroAllRam                       A:8860
ZeroEnd                          A:88A0
ZeroHighRange                    A:8887
ZeroLowRange                     A:8866
ZEROLP                           A:9AD4
ZEROSUP                          A:A7B8
ZFN                              E:00A7
ZFOR                             E:0081
ZGOSUB                           E:008C
ZGOTO                            E:0088
ZGTR                             E:00B3
ZLEFT                            E:00CF
ZLTH                             E:00B5
ZMINUS                           E:00AD
ZNEW                             E:00A4
ZNOT                             E:00AA
ZONELP                           A:96A2
ZOR                              E:00B2
ZPLUS                            E:00AC
ZPRINT                           E:009E
ZREM                             E:008E
ZSGN                             E:00B6
ZSPC                             E:00A8
ZSTEP                            E:00AB
ZTAB                             E:00A5
ZTHEN                            E:00A9
ZTO                              E:00A6

Symbols by value:
0000 Carry
0000 StartAddr
0000 NF
0000 RST00
0001 Negative
0001 ChecksumErr
0002 Overflow
0002 SN
0003 CTRLC
0004 RG
0004 HalfCarry
0004 SIO_PortA_Data
0006 Zero
0006 OD
0006 SIO_PortA_Ctrl
0007 LastRec
0007 CTRLG
0007 Sign
0008 FC
0008 RST08
0008 BKSP
0009 ErrorPtrOffset
000A LF
000A OV
000C OM
000D CR
000E UL
000F HELP
000F CTRLO
0010 RST10
0010 BS
0011 CTRLQ
0012 CTRLR
0012 DD
0013 CTRLS
0014 DZ
0015 CTRLU
0016 ID
0018 VertTextRes
0018 TM
0018 RST18
001A OS
001B ESC
001C LS
001E ST
0020 DELIMITER
0020 CN
0020 RST20
0022 UF
0024 MO
0026 HX
0028 BN
0028 HorizTextRes
0028 RST28
0030 RST30
0030 BankSelect
0038 RST38
0038 RomDisable
005E ERRORPTR
0066 NMI66
007F DEL
0080 ShadowCopy
0080 ZEND
0080 InterruptVectorEnd
0081 ZFOR
0083 BankCopyLoop
0083 ZDATA
0088 ZGOTO
008C ZGOSUB
008E ZREM
0098 ROMCopy
009E ZPRINT
00A3 VectorCopy
00A4 ZNEW
00A5 ZTAB
00A6 ZTO
00A7 ZFN
00A8 ZSPC
00A9 ZTHEN
00AA ZNOT
00AB ZSTEP
00AC ZPLUS
00AD ZMINUS
00B2 ZOR
00B3 ZGTR
00B4 ZEQUAL
00B5 ZLTH
00B6 ZSGN
00C3 JUMP
00CF ZLEFT
00FF EOT
1000 WRKSPC
1003 USR
1006 OUTSUB
1007 OTPORT
1009 DIVSUP
100A DIV1
100E DIV2
1012 DIV3
1015 DIV4
1017 SEED
103A LSTRND
103E INPSUB
103F INPORT
1041 NULLS
1042 LWIDTH
1043 COMMAN
1044 NULFLG
1045 CTLOFG
1046 LINESC
1048 LINESN
104A CHKSUM
104D BRKFLG
104E RINPUT
1051 POINT
1054 PSET
1057 RESET
105A STRSPC
105C LINEAT
105E BASTXT
1061 BUFFER
1066 STACK
10AB CURPOS
10AC LCRFLG
10AD TYPE
10AE DATFLG
10AF LSTRAM
10B1 TMSTPT
10B3 TMSTPL
10BF TMPSTR
10C3 STRBOT
10C5 CUROPR
10C7 LOOPST
10C9 DATLIN
10CB FORFLG
10CC LSTBIN
10CD READFG
10CE BRKLIN
10D0 NXTOPR
10D2 ERRLIN
10D4 CONTAD
10D6 PROGND
10D8 VAREND
10DA ARREND
10DC NXTDAT
10DE FNRGNM
10E0 FNARG
10E4 FPREG
10E7 FPEXP
10E8 SGNRES
10E9 PBUFF
10F6 MULVAL
10F9 PROGST
115D STLOOK
8000 StartOfCode
8046 Main
805A PrintDec
8063 PrintByte
8076 PrintChar
8077 PrintCharTxWait
8081 PrintCRLF
808E PrintLine
8095 PrintLineLoop
80A0 PrintNibble
80AB PrintNibbleEnd
80B0 PrintString
80B1 PrintStringLoop
80BC PrintStringEnd
80BE PrintWord
80C9 ReadChar
80D2 ReadCharNoWait
80DD ReadByte
80F0 ReadString
80F8 ReadStringChar
810F ReadStringSave
811B ReadStringBS
8134 ReadStringESC
8135 ReadStringCR
813F ReadWord
814D SIO_Init
816B Ascii2BcdDigit
816B Ascii2HexNibble
8180 Ascii2HexNibbleOK
8188 Ascii2HexNibbleEnd
818D Ascii2HexNibbleErr
818F Ascii2HexByte
81AB Ascii2HexByteErr
81AE Ascii2HexWord
81BE Ascii2HexWordErr
81C1 Dec2Hex
81CA Dec2HexLoop
81F8 Dec2HexShuffleRegs
81FE Dec2HexOutOfRange
8204 Dec2HexInvalidDec
820B Dec2HexEnd
820E Hex2Dec
8219 Hex2Dec10000
821B Hex2Dec10000Loop
822B Hex2Dec10000Set
8234 Hex2Dec1000
8236 Hex2Dec1000Loop
8248 Hex2Dec1000Set
8251 Hex2Dec100
8253 Hex2Dec100Loop
8265 Hex2Dec100Set
826E Hex2Dec10
8270 Hex2Dec10Loop
8282 Hex2Dec10Set
828B Hex2Dec1
8298 Hex2DecEnd
82A1 UpperCase
82AB UpperCaseEnd
82AC ClearScreen
82B5 CopyBlock
82BC CopySourceAddress
82CA CopyDestinationAddress
82D8 CopyNumberOfBytes
8309 CopyNoOverlap
830D CopyNoParameter
8312 CopyNothing
8315 CopyEnd
831A Diagnostics
8328 DiagnosticsBankLoop
8363 DiagnosticsTest
8366 DiagnosticsTestLoop
8397 DiagMemoryError
83AE DiagMemoryAddr
83D1 DiagnosticsEnd
83E1 DiagnosticsEnd2
83EA FillMemory
83F1 FillStartAddr
8407 FillEndAddr
8414 FillByte
8426 FillRange1
844E FillRange2
8478 FillNoParameter
847E FillPrintHelp
8484 FillMemoryEnd
8489 HaltCmd
848B HexDump
84A3 HexLinesToRead
84B6 HexDefaultLines
84B8 HexDisplayContent
84B9 HexNextLine
84C9 HexNextByte
84DC HexNextChar
84E7 HexReplaceDot
84E9 HexPrintChar
84FC HexDumpPrintHelp
8502 HexDumpEnd
8507 IntelHex
8526 IntelHexStartCode
8534 IntelHexByteCount
8539 IntelHexAddress
854E IntelHexRecordType
8561 IntelHexData
856C IntelHexChecksum
857A IntelHexCheckOk
857C IntelHexPrintStatus
8587 IntelHexPrintEndMsg
8599 IntelHexPrintNotOk
85AC IntelHexAbort
85B4 IntelHexUnsupported
85C2 IntelHexParamError
85CA IntelHexPrintHelp
85D0 IntelHexEnd
85D7 ListCmd
85E6 PeekCmd
85EC PeekAddress
85F6 PeekRead
860A PeekNoParameter
8610 PeekEnd
8610 PeekError
8614 PokeCmd
861A PokeGetPort
8628 PokeGetByte
8633 PokeWrite
864A PokeNoParameter
8650 PokeEnd
8650 PokeError
8654 Registers
8742 FlagSignClear
874E FlagZeroClear
875A FlagHalfClear
8766 FlagOverClear
8772 FlagNegativeClear
877E FlagCarryClear
878E RunCode
879E RunCallBC
87A0 RunEnd
87A1 SetAddress
87B7 SetAddressDefault
87BD SetAddressEnd
87C2 SetBank
87E2 SetBankDefault
87EB SetBankError
87EE SetBankEnd
87F3 SysInfo
8810 Write
8817 WriteGetAddress
8823 WriteFirstByte
8837 WriteRemainingBytes
884D WriteTooManyDigits
8858 WriteNoParameter
885B WriteEnd
8860 ZeroAllRam
8866 ZeroLowRange
8887 ZeroHighRange
88A0 ZeroEnd
88A5 CommandPrompt
88C5 DecErrorPointer
88CF GetHexParameter
88D5 GetParamCount
88E6 GetParamFetch
88EB GetParamFetch0
88F3 GetParamFetch1
8903 GetParamFetch2
8911 GetParamFetch3
8927 GetParamFetch4
8932 GetParameterEnd
8934 GetParamHelp
8939 GetParamNumberError
893B GetErrorPointerLoop
8948 GetParamHexError
894E GetParamErrorEnd
8950 IncErrorPointer
895A Parser
8974 ParseNextChar
898C ParseNextCmd
899D ParseValidate
89A6 ParseExecute
89B5 ParseInvalid
89BB ParseEnd
89C2 PrintErrorPointer
89C8 PrintErrorLoop
89DA RangeValidation
89E8 ValCheckInverted
89F8 ValCheckLowLimit
8A09 ValCheckLowLimit2
8A15 ValCheckHighLimit
8A26 ValCheckHighLimit2
8A32 ValCheckBiosLow
8A3D ValCheckBiosHi
8A4B ValCheckHigh
8A71 ValCheckHighBios
8A7F ValCheckLow
8A99 ValCheckLowBios
8AA2 ValBiosOverlap
8ABE ValCheckIfZeroDataLow
8ACE ValCheckIfZeroDataHigh
8ADE ValPrintRange
8AE1 ValPrintRange1
8AFB ValPrintRange2
8B15 ValPrintRangeEnd
8B1B ValBiosRangeError
8B21 ValRangeTooSmallError
8B27 ValInvertedError
8B2D RangeValidationError
8B31 RangeValidationEnd
8B35 ResetErrorPointer
8B3D SkipSpaces
8B3E SkipSpacesLoop
8B49 SkipSpacesEnd
8B4B BASIC
8B54 ColdOrWarm
8B5A CheckIfCold
8B67 CheckIfWarm
8B74 SignOnMsg
8BD0 COLD
8BDB CSTART
8BE2 INIT
8BEA COPYY
8BFF MSIZE
8C12 MLOOP
8C24 TSTMEM
8C36 SETTOP
8C6E WARM
8C71 BRKRET
8C77 BFREE
8C86 SIGNON
8CBC MEMMSG
8CC7 FNCTAB
8CFF WORDS
8E22 WORDTB
8E6E PRITAB
8E83 ERRORS
8EAD INITAB
8F0D INITBE
8F0D ERRMSG
8F14 INMSG
8F18 ZERBYT
8F19 OKMSG
8F1F BRKMSG
8F25 BAKSTK
8F29 LOKFOR
8F3F INDFND
8F48 MOVUP
8F4B MOVSTR
8F4E MOVLP
8F59 CHKSTK
8F62 ENFMEM
8F71 OMERR
8F76 DATSNR
8F7C SNERR
8F7F DZERR
8F82 NFERR
8F85 DDERR
8F88 UFERR
8F8B OVERR
8F8E TMERR
8F90 ERROR
8FB0 ERRIN
8FC6 POPNOK
8FC7 PRNTOK
8FD4 GETCMD
900D LINFND
9015 SFTPRG
9024 INEWLN
9043 MOVBUF
904B SETPTR
9050 PTRLP
905C FNDEND
9068 SRCHLN
906B SRCHLP
9088 NEW
9089 CLRPTR
9094 RUNFST
9098 INTVAR
90AE CLREG
90C7 DOAGN
90CB PROMPT
90D8 CRUNCH
90E1 CRNCLP
910B FNDWRD
9124 SEARCH
9126 GETNXT
9136 NXTBYT
9147 NOSPC
9150 NOCHNG
9158 MATCH
915C RETNAD
9160 MOVDIR
916E SETLIT
9171 TSTREM
9177 NXTCHR
9180 CPYLIT
9187 ENDBUF
9190 DODEL
91A4 ECHDEL
91B0 DELCHR
91B8 OTKLN
91BB KILIN
91C1 TTYLIN
91C1 GETLIN
91CA MORINP
91E3 PROCES
9222 PUTBUF
9227 PUTCTL
9236 OUTIT
923C OUTNBS
9244 CPDEHL
924A CHKSYN
9255 OUTC
9275 INCLEN
9279 DINPOS
927F CLOTST
9290 LISTT
929C LISTLP
92BC LSTLP2
92BF LSTLP3
92CE FNDTOK
92D8 OUTWRD
92E6 SETLIN
92EF COUNT
9312 RSLNBK
931B FOR
932F FORSLP
934B FORFND
9387 SAVSTP
9390 PUTFID
9394 RUNCNT
93B4 EXCUTE
93BB IFJMP
93BC ONJMP
93D4 GETCHR
93E4 RESTOR
93F9 RESTNL
93FA UPDATA
93FF TSTBRK
940E STALL
941A BRK
941F STOPP
9421 PEND
9426 INPBRK
9429 ENDPRG
943C NOLIN
944D CONT
9460 NULLL
9468 ACCSUM
9475 CHKLTR
947D FPSINT
9480 POSINT
9483 DEPINT
9489 DEINT
949E FCERR
94A3 ATOH
94A4 GETLN
94A7 GTLNLP
94C8 CLEAR
94EB STORED
950E RUN
951A GOSUB
952A RUNLIN
952B GOTO
9544 ULERR
9549 RETURN
9568 RETLIN
956D NXTDTA
956E DATAA
9570 REM
9574 NXTSTL
9577 NXTSTT
9585 LET
95A0 LETSTR
95C7 CRESTR
95CF MVSTPT
95D8 LETNUM
95DF ON
95EE ONGO
95EF ONGOLP
95FD IFF
960B IFGO
961D MRPRNT
9621 PRINTT
9624 PRNTLP
9667 PRNTNB
966B PRNTST
9672 STTLIN
967A ENDINP
9682 DONULL
9689 NULLP
9694 DOCOM
96A2 ZONELP
96AB DOTAB
96BE DOSPC
96C3 ASPCS
96C7 SPCLP
96CE NEXITM
96D5 REDO
96E8 BADINP
96F9 INPUT
9713 NOPMPT
9728 READ
972D NXTITM
9735 NEDMOR
9739 GTVLUS
9761 ANTVLU
977C ITMSEP
977F STRENT
978B INPBIN
9796 LTSTND
97A2 MORDT
97BD EXTIG
97CE FDTLP
97E7 FANDT
97F2 NEXT
97F5 NEXT1
982D KILFOR
983D GETNUM
9840 TSTNUM
9841 TSTSTR
9842 CHKTYP
984B OPNPAR
984F EVAL
9852 EVAL1
985B EVAL2
985E EVAL3
986B RLTLP
9887 FOPRND
98AF STKTHS
98C6 OPRND
98F1 NOTAMP
9914 EVLPAR
991C MINUS
9928 RETNUM
992D CONVAR
9930 FRMEVL
993E FNOFST
9965 FNVAL
996D GOFUNC
9976 SGNEXP
9986 POR
9987 PAND
99A9 POR1
99AE TSTRED
99C0 CMPLOG
99C2 CMPLG1
99EC CMPSTR
9A04 CMPRES
9A0E EVNOT
9A25 DIMRET
9A2E DIM
9A33 GETVAR
9A38 GTFNAM
9A4F SVNAM2
9A50 ENDNAM
9A5C CHARTY
9A6B NOTSTR
9A7B NSCFOR
9A95 FNDVAR
9AA3 FNTHR
9AAE CFEVAL
9AD4 ZEROLP
9AE2 RETADR
9AE5 RETNUL
9AF0 SBSCPT
9AF6 SCPTLP
9B18 ARLDSV
9B1E FNDARY
9B32 NXTARY
9B4B BSERR
9B50 CREARY
9B6B CRARLP
9B73 DEFSIZ
9B91 ZERARY
9BAE FINDEL
9BB3 FNDELP
9BD2 ENDDIM
9BD6 FRE
9BF2 FRENUM
9BF7 ACPASS
9BF8 ABPASS
9C04 POS
9C07 PASSA
9C0C DEF
9C39 DOFN
9C81 IDTEST
9C8F CHEKFN
9CA0 STRR
9CA6 STR1
9CB0 SAVSTR
9CC5 MKTMST
9CC8 CRTMST
9CCE SVSTAD
9CD4 CRTST
9CD5 QTSTR
9CD8 DTSTR
9CDB QTSTLP
9CEA CRTSTE
9CF6 TSTOPL
9D15 PRNUMS
9D16 PRS
9D19 PRS1
9D20 PRSLP
9D2F TESTR
9D31 GRBDON
9D4B POPAF
9D4D TESTOS
9D59 GARBGE
9D5C GARBLP
9D6A GRBLP
9D7B SMPVAR
9D90 GNXARY
9D91 ARRLP
9DB0 GRBARY
9DBE STPOOL
9DC1 STRADD
9DE7 SCNEND
9E0C CONCAT
9E43 SSTSA
9E4C TOSTRA
9E4D TSALP
9E56 GETSTR
9E59 GSTRCU
9E5C GSTRHL
9E5D GSTRDE
9E75 POPHL
9E77 BAKTMP
9E88 LEN
9E8C GETLEN
9E97 ASCC
9E9B GTFLNM
9EA8 CHR
9EB4 TOPOOL
9EB8 LEFT
9EBC RIGHT1
9EBE MID1
9EC6 ALLFOL
9EE8 RIGHT
9EF2 MID
9F0B RSTSTR
9F22 VAL
9F40 VAL1
9F4A VAL2
9F4D VAL3
9F51 LFRGNM
9F56 MIDNUM
9F5B INP
9F67 POUT
9F6D WAIT
9F81 NOXOR
9F82 WAITLP
9F8B SETIO
9F9B FNDNUM
9F9E GETINT
9FA1 MAKINT
9FAF PEEK
9FB6 POKE
9FC7 ROUND
9FCA ADDPHL
9FD0 SUBPHL
9FD4 PSUB
9FD6 SUBCDE
9FD9 FPADD
9FF3 NOSWAP
A019 MINCDE
A027 CONPOS
A02A BNORM
A02D BNRMLP
A03F RESZER
A040 SAVEXP
A044 NORMAL
A04C PNORM
A05F RONDUP
A060 RONDB
A071 FPROND
A07E PLUCDE
A08A COMPL
A09E SCALE
A0A0 SCALLP
A0AD SHRITE
A0B0 SHRLP
A0B4 SHRT1
A0C2 UNITY
A0C6 LOGTAB
A0D3 LOG
A10B MULLN2
A112 MULTT
A114 FPMULT
A136 MULT8
A13F MUL8LP
A150 NOMADD
A160 POPHRT
A162 BYTSFT
A167 DIV10
A173 DIV
A175 DVBCDE
A19A DIVLP
A1AD RESDIV
A1DD ADDEXP
A1FB OVTST1
A200 OVTST2
A201 OVTST3
A208 MLSP10
A21F TSTSGN
A228 RETREL
A22A FLGDIF
A22E SGN
A231 FLGREL
A236 RETINT
A244 ABS
A248 INVSGN
A250 STAKFP
A25D PHLTFP
A260 FPBCDE
A26B BCDEFP
A26E LOADFP
A275 INCHL
A277 FPTHL
A27A DETHL4
A27C DETHLB
A285 SIGNS
A29A CMPNUM
A2B4 CMPFP
A2C7 FPINT
A2EB DCBCDE
A2F2 INT
A30B MLDEBC
A313 MLDBLP
A321 NOMLAD
A326 ASCTFP
A332 CNVNUM
A33A MANLP
A350 EXPLP
A35E DPOINT
A362 CONEXP
A365 SCALMI
A371 ENDCON
A37B SCALPL
A37C MULTEN
A383 ADDIG
A39A RSCALE
A3A0 PADD
A3A5 EDIGIT
A3B1 LINEIN
A3B9 PRNTHL
A3C4 NUMASC
A3D2 SPCFST
A3E1 SIXDIG
A3F6 GTSIXD
A3FF INRNG
A41B MAKNUM
A42C DIGTXT
A43B TRYAGN
A460 SUPTLZ
A46C DOEBIT
A47C OUTEXP
A47E EXPTEN
A488 JSTZER
A48B NOENED
A48E RNGTST
A49D HALF
A4A1 POWERS
A4B3 NEGAFT
A4B8 SQR
A4C1 POWER
A4D1 POWER1
A4EE POWER2
A506 EXPP
A546 EXPTAB
A567 SUMSER
A576 SMSER1
A57F SUMLP
A597 RND
A5D3 RND1
A5EF RND2
A5F8 RESEED
A600 RNDTAB
A60C COS
A612 SIN
A642 SIN1
A656 HALFPI
A65A QUARTR
A65E SINTAB
A673 TAN
A688 ATN
A6A5 ATN1
A6AF ATNTAB
A6D4 ARET
A6D5 GETINP
A6D9 CLS
A6DC WIDTH
A6E4 LINES
A6F3 DEEK
A6FE DOKE
A715 HEX
A72E HEX1
A730 HEX2
A73E HEX3
A740 HEX4
A74D BYT2ASC
A756 ADD30
A76A ADD301
A76E HEXTFP
A77A HEXLP
A77F HEXLP1
A787 GETHEX
A79A NOSUB7
A79E HEXIT
A7A7 HXERR
A7AC BIN
A7B2 BIN2
A7B8 ZEROSUP
A7C6 BITOUT
A7CA BITOUT2
A7DE BINTFP
A7E8 BINIT
A7FB CHKBIN
A809 BINERR
A80E JJUMP1
A815 MONOUT
A818 MONITR
A81B INITST
A823 ARETN
A825 TSTBIT
A82C OUTNCR
A832 EXIT
A835 BootMsg
A8BE CommandList
A93F ListOfCommands
ABA4 FlagBits
ABAA ClearScreenSeq
ABB7 SysInfoMsg
AC7E ParseInvalidErr
ACA4 InvalidHexDigitErr
ACCD TooManyDigitsErr
ACF6 MissingParameterErr
AD0D UnrecognizedParamErr
AD26 StartGreaterEndErr
AD47 IntelHexUnsupportedErr
AD61 InvalidVectorRangeErr
AD7E ReservedBiosAreaErr
AD94 RangeTooSmallErr
ADB1 InvalidBankNumberErr
ADCF InvalidDecimalNumberErr
ADE8 NumberOutOfRangeErr
AE01 BadMemory1Err
AE0B BadMemory2Err
AE1E NothingToCopyErr
AE30 TestingBankNumberMsg
AE43 TestingHighRamMsg
AE56 MemoryTestPassedMsg
AE6B RangeMsg
AE7A IntelHexFinishedMsg
AE8A IntelHexSuccessMsg
AE99 IntelHexLoadMsg
AED6 IntelHexAbortedMsg
AEF1 DownloadedBytesMsg
AF05 FillHelp
AF70 HexDumpHelp
AFD5 IntelHexHelp
B018 Range
B021 InvalidVectorRange
B02A RangeTooSmall
B033 BiosRange
B03C RangeInverted
B045 NoParameter
B051 InvalidBank
B05A TooManyDigits
B063 InvalidHexDigit
B06C NumberOutOfRange
B075 InvalidDecimalNumber
B07E NothingToCopy
B08D CommandBuffer
B0B5 BufferPointer
B0B7 CmdErrorPointer
B0B8 CurrentBank
B0B9 CurrentAddress
B0BB CurrentPort
B0BC DigitString
B0C5 ParseSaveHL
B0C7 RegA
B0C8 RegBC
B0CA RegDE
B0CC RegHL
B0CE RegIX
B0D0 RegIY
B0D2 StackPtr
B0D4 FlagsReg
B0D5 StartAddress
B0D7 EndAddress
B0D9 StartAddressAlt
B0DB EndAddressAlt
B0DD ByteTransfer
B0DE UserCodeSize
B0E0 EndOfCode
CBA0 BytesFree
FD00 VectorTable
FD00 IntVectorEnd
FD02 VectorTableStart
FD04 CodeStartAddr
FD06 CodeEndAddr
FE00 JumpTable
FE3F VectorEnd
FF00 StackPage
FFFF BiosEnd

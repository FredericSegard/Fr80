Sections:
00: "seg0" (0-8000)
01: "seg8000" (8000-FD00)
02: "segfd00" (FD00-FE00)
03: "segfe00" (FE00-FF00)
04: "segff00" (FF00-FFFF)


Source: "main.asm"
                        	     1: ; --------------------------------------------------------------------------------------------------------------
                        	     2: ;         :::::::::     ::::::::       :::::::            :::::::::     :::::::::::     ::::::::       :::::::: 
                        	     3: ;             :+:     :+:    :+:     :+:   :+:           :+:    :+:        :+:        :+:    :+:     :+:    :+: 
                        	     4: ;           +:+      +:+    +:+     +:+   +:+           +:+    +:+        +:+        +:+    +:+     +:+         
                        	     5: ;         +#+        +#++:++#      +#+   +:+           +#++:++#+         +#+        +#+    +:+     +#++:++#++   
                        	     6: ;       +#+        +#+    +#+     +#+   +#+           +#+    +#+        +#+        +#+    +#+            +#+    
                        	     7: ;     #+#         #+#    #+#     #+#   #+#           #+#    #+#        #+#        #+#    #+#     #+#    #+#     
                        	     8: ;   #########     ########       #######            #########     ###########     ########       ########       
                        	     9: ; ------------------------------------------------------------------------------------------------------
                        	    10: 
                        	    11: ; *********************************************************************************************************************
                        	    12: ; * Z80 Project, code nema Fre80 (Freddy) by Frédéric Segard, a.k.a. MicroHobbyist
                        	    13: ; * https://www.youtube.com/@microhobbyist
                        	    14: ; * https://github.com/FredericSegard
                        	    15: ; *
                        	    16: ; * Copyright (C) 2023 Frédéric Segard
                        	    17: ; *
                        	    18: ; * This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General
                        	    19: ; * Public License as published by the Free Software Foundation. You can use all or part of the code, regardless of
                        	    20: ; * the version. But there is no warrenty of any kind.
                        	    21: ; *
                        	    22: ; * Reference:	ASCII text: https://www.messletters.com/en/big-text/ (alligator, standard)
                        	    23: ; *				Editor tab-stops set to 4
                        	    24: ; *				Assembler: VASM  (BIN: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fbin -o %1.out -L %1.txt)
                        	    25: ; *								 (HEX: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fihex)
                        	    26: ; * Version 0.7
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: 
                        	    30: ;   ____                         _                     _         
                        	    31: ;  / ___|   ___    _ __    ___  | |_    __ _   _ __   | |_   ___ 
                        	    32: ; | |      / _ \  | '_ \  / __| | __|  / _` | | '_ \  | __| / __|
                        	    33: ; | |___  | (_) | | | | | \__ \ | |_  | (_| | | | | | | |_  \__ \
                        	    34: ;  \____|  \___/  |_| |_| |___/  \__|  \__,_| |_| |_|  \__| |___/
                        	    35: ;
                        	    36: ; ---------------------------------------------------------------------------------------------------------------------
                        	    37: ; VARIOUS CONSTANTS AND ADDRESSES USED IN THE CODE
                        	    38: 
                        	    39: ; GENERAL EQUATES
                        	    40: NULL			= $00
                        	    41: CTRLC			= $03				; Control-C (Break)
                        	    42: CTRLG			= $07				; Control-G (Bell)
                        	    43: BKSP			= $08				; Backspace
                        	    44: TAB				= $09				; Horizontal tab
                        	    45: LF				= $0A				; Line-feed character
                        	    46: CS				= $0C				; Clear Screen
                        	    47: CR				= $0D				; Carriage-return character
                        	    48: CTRLO			= $0F				; Control "O"
                        	    49: CTRLQ			= $11				; Control "Q"
                        	    50: CTRLR			= $12				; Control "R"
                        	    51: CTRLS			= $13				; Control "S"
                        	    52: CTRLU			= $15				; Control "U"
                        	    53: ESC				= $1B				; Escape
                        	    54: SPACE			= $20				; Space character
                        	    55: DEL				= $7F				; Delete
                        	    56: 
                        	    57: DELIMITER		= " "				; Space delimiter between command line parameters
                        	    58: ERRORPTR		= "^"				; Error pointer symbol (used for pointing to the error position on command line)
                        	    59: QUOTE			= $22
                        	    60: JUMP			= $C3				; Delimiter for command list items (It's the actual jp command opcode)
                        	    61: HELP			= $0F
                        	    62: EOT				= $FF				; End of table
                        	    63: 
                        	    64: ;PARAMETERS
                        	    65: HorizTextRes	= 40				; Horizontal text resolution (40 or 80)
                        	    66: VertTextRes		= 24				; Vertical text resolution (typical 24 or 25)
                        	    67: ErrorPtrOffset	= 9					; Take into account the command prompt width
                        	    68: BytesFree		= (VectorTable-EndOfCode)+(StartOfCode-InterruptVectorEnd)	; Base free bytes
                        	    69: 
                        	    70: ; I/O ADDRESSES
                        	    71: SIO_PortA_Data	= $00				; SIO data port A
                        	    72: SIO_PortB_Data	= $01				; SIO data port B
                        	    73: SIO_PortA_Ctrl	= $02				; SIO control port A
                        	    74: SIO_PortB_Ctrl	= $03				; SIO control port B
                        	    75: 
                        	    76: BankSelect		= $30				; RAM bank select address (values ($00 to $FF)
                        	    77: RomDisable		= $38				; ROM dissable address (any value)
                        	    78: 
                        	    79: ; STATUS INDICATOR FLAGS (BIT NUMBER... 3 and 5 are not used
                        	    80: Carry			= 0					; (F) Carry flag
                        	    81: Negative		= 1					; (N) Add/substract flag
                        	    82: Parity			= 2					; (P) Parity flag (Same bit position as bellow, depends on the instruction)
                        	    83: Overflow		= 2					; (V) Overflow flag (Same bit position as above, depends on the instruction)
                        	    84: HalfCarry		= 4					; (H) Half-carry flag
                        	    85: Zero			= 6					; (Z) Zero flag
                        	    86: Sign			= 7					; (S) Sign flag
                        	    87: 
                        	    88: 
                        	    89: ;  ___           _                                          _    __     __                _                        
                        	    90: ; |_ _|  _ __   | |_    ___   _ __   _ __   _   _   _ __   | |_  \ \   / /   ___    ___  | |_    ___    _ __   ___ 
                        	    91: ;  | |  | '_ \  | __|  / _ \ | '__| | '__| | | | | | '_ \  | __|  \ \ / /   / _ \  / __| | __|  / _ \  | '__| / __|
                        	    92: ;  | |  | | | | | |_  |  __/ | |    | |    | |_| | | |_) | | |_    \ V /   |  __/ | (__  | |_  | (_) | | |    \__ \
                        	    93: ; |___| |_| |_|  \__|  \___| |_|    |_|     \__,_| | .__/   \__|    \_/     \___|  \___|  \__|  \___/  |_|    |___/
                        	    94: ;                                                  |_|                                                             
                        	    95: ; ---------------------------------------------------------------------------------------------------------------------
                        	    96: ; RESET AND INTERRUPT VECTORS (8-BYTE VECTORS EACH)
                        	    97: 
                        	    98: 	.org	$0000
                        	    99: 	
                        	   100: RST00:								; Reset vector 0: Standard boot up reset vector
00:0000 C38000          	   101: 	jp		ShadowCopy				; Shadow copy BIOS and vectors
00:0003 FF              	   102: 	ds		$0008-$,$FF
00:0004 *
                        	   103: 
                        	   104: RST08:								; Reset Vector 1
00:0008 76              	   105: 	halt
00:0009 FF              	   106: 	ds		$0010-$,$FF
00:000A *
                        	   107: 
                        	   108: RST10:								; Reset Vector 2
00:0010 76              	   109: 	halt
00:0011 FF              	   110: 	ds		$0018-$,$FF
00:0012 *
                        	   111: 	
                        	   112: RST18:								; Reset Vector 3
00:0018 76              	   113: 	halt
00:0019 FF              	   114: 	ds		$0020-$,$FF
00:001A *
                        	   115: 
                        	   116: RST20:								; Reset Vector 4
00:0020 76              	   117: 	halt
00:0021 FF              	   118: 	ds		$0028-$,$FF
00:0022 *
                        	   119: 
                        	   120: RST28:								; Reset Vector 5
00:0028 76              	   121: 	halt
00:0029 FF              	   122: 	ds		$0030-$,$FF
00:002A *
                        	   123: 
                        	   124: RST30:								; Reset Vector 6
00:0030 76              	   125: 	halt
00:0031 FF              	   126: 	ds		$0038-$,$FF
00:0032 *
                        	   127: 
                        	   128: RST38:								; Reset vector 7: Interrupt Mode 1
00:0038 76              	   129: 	halt
00:0039 FF              	   130: 	ds		$0066-$,$FF
00:003A *
                        	   131: 
                        	   132: NMI66:								; Non-masquable interreupt vector
00:0066 76              	   133: 	halt
00:0067 FF              	   134: 	ds		$0080-$,$FF
00:0068 *
                        	   135: 
                        	   136: InterruptVectorEnd:
                        	   137: 
                        	   138: 
                        	   139: ;  ____    _                   _                         ____                         
                        	   140: ; / ___|  | |__     __ _    __| |   ___   __      __    / ___|   ___    _ __    _   _ 
                        	   141: ; \___ \  | '_ \   / _` |  / _` |  / _ \  \ \ /\ / /   | |      / _ \  | '_ \  | | | |
                        	   142: ;  ___) | | | | | | (_| | | (_| | | (_) |  \ V  V /    | |___  | (_) | | |_) | | |_| |
                        	   143: ; |____/  |_| |_|  \__,_|  \__,_|  \___/    \_/\_/      \____|  \___/  | .__/   \__, |
                        	   144: ;                                                                      |_|      |___/ 
                        	   145: ; ---------------------------------------------------------------------------------------------------------------------
                        	   146: ; SHADOW COPY VECTORS AND BIOS FROM FLASH TO RAM
                        	   147: 
                        	   148: ShadowCopy:
00:0080 F3              	   149: 	di								; Disable interrupts
                        	   150: 	
                        	   151: ; COPY INTERRUPT VECTORS TO ALL BANKS
00:0081 3E0E            	   152: 	ld		A,$0E					; Starting bank number
                        	   153: BankCopyLoop:						; Loop to copy reset vectors to all banks
00:0083 D330            	   154: 	out		(BankSelect),A			; Sets bank number to value in accumulator
                        	   155: 	; Perform vector copy
00:0085 210000          	   156: 	ld      HL,$0000				; Set start at address $0000 (ROM)
00:0088 110000          	   157: 	ld      DE,$0000				; Set destination address (RAM)
00:008B 018000          	   158: 	ld      BC,InterruptVectorEnd	; Set counter to copy the interrupt vector table only
00:008E EDB0            	   159: 	ldir							; Copy, paste, and repeat, until the end of BC has been reached
                        	   160: 	; Check for next iteration
00:0090 3D              	   161: 	dec		A						; Decrement accumulator to move on to next bank
00:0091 FEFF            	   162: 	cp		$FF						; Has accumulator reached the end of the loop (past zero)?
00:0093 20EE            	   163: 	jr		nz,BankCopyLoop			; If not then do next bank the loop, else Bank 0 is already pre-selected
00:0095 32AFB0          	   164: 	ld		(CurrentBank),A			; Save Current Bank
                        	   165: 
                        	   166: ; COPY THE BIOS TO RAM
                        	   167: ROMCopy:
00:0098 210080          	   168:     ld      HL,StartOfCode			; Source address
00:009B 110080          	   169:     ld      DE,StartOfCode			; Destination address
00:009E 01D730          	   170:     ld      BC,EndOfCode-StartOfCode; Bytes to copy
00:00A1 EDB0            	   171:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   172: 
                        	   173: ; COPY THE VECTORS AND BLANK STACK TO RAM
                        	   174: VectorCopy:
00:00A3 2100FD          	   175:     ld      HL,VectorTable			; Source address
00:00A6 1100FD          	   176:     ld      DE,VectorTable			; Destination address
00:00A9 01FF02          	   177:     ld      BC,$FFFF-VectorTable	; Bytes to copy
00:00AC EDB0            	   178:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   179: 
00:00AE C30080          	   180: 	jp		StartOfCode
                        	   181: 
00:00B1 FF              	   182: 	ds		StartOfCode-$,$FF		; Fill the rest of memory to start of code with $FF for fast FLASH programming
00:00B2 *
                        	   183: 
                        	   184: 
                        	   185: ;  ___           _   _     _           _   _              
                        	   186: ; |_ _|  _ __   (_) | |_  (_)   __ _  | | (_)  ____   ___ 
                        	   187: ;  | |  | '_ \  | | | __| | |  / _` | | | | | |_  /  / _ \
                        	   188: ;  | |  | | | | | | | |_  | | | (_| | | | | |  / /  |  __/
                        	   189: ; |___| |_| |_| |_|  \__| |_|  \__,_| |_| |_| /___|  \___|
                        	   190: ;
                        	   191: ; ---------------------------------------------------------------------------------------------------------------------
                        	   192: ; START OF CODE
                        	   193: 
                        	   194: 	.org	$8000					; Start of code at beginning of high memory
                        	   195: 
                        	   196: StartOfCode:
01:8000 3E00            	   197: 	ld		A,0
01:8002 D338            	   198: 	out		(RomDisable),A			; Disable the ROM
01:8004 31FFFF          	   199: 	ld      SP,$FFFF				; Set top of stack pointer to page FF
                        	   200: 	
01:8007 CD4D81          	   201: 	call	SIO_Init				; Initializes the SIO
                        	   202: 
                        	   203: 	; Print Boot message with bytes free
01:800A CDAC82          	   204: 	call	ClearScreen				; Clear the terminal screen (with ANSI codes)
01:800D 2133A8          	   205: 	ld		HL,BootMsg
01:8010 CDB080          	   206: 	call	PrintString				; Print first line of boot message
01:8013 CD8E80          	   207: 	call	PrintLine				; Print a separator line
01:8016 CDB080          	   208: 	call	PrintString				; Print second line of boot message
01:8019 E5              	   209: 	push	HL
01:801A 21A9CB          	   210: 	ld		HL,BytesFree			; Load the amount of bytes free
01:801D CD5A80          	   211: 	call	PrintDec
01:8020 E1              	   212: 	pop		HL
01:8021 CDB080          	   213: 	call	PrintString
                        	   214: 
01:8024 210000          	   215: 	ld		HL,$0000				; Set default current address
01:8027 22B0B0          	   216: 	ld		(CurrentAddress),HL		; Save in CurrentAddress variable
01:802A 3E00            	   217: 	ld		A,0
01:802C D330            	   218: 	out		(BankSelect),A			; Set the bank to number 0
01:802E 32AFB0          	   219: 	ld		(CurrentBank),A			; Save the Current Bank
                        	   220: 
                        	   221: 	; Clear the registers
01:8031 3E00            	   222: 	ld		A,0
01:8033 010000          	   223: 	ld		BC,0
01:8036 110000          	   224: 	ld		DE,0
01:8039 210000          	   225: 	ld		HL,0
01:803C DD210000        	   226: 	ld		IX,0
01:8040 FD210000        	   227: 	ld		IY,0
01:8044 C5              	   228: 	push	BC						; LSB to clear the flag
01:8045 F1              	   229: 	pop		AF						; Clear flag
                        	   230: 
                        	   231: ;	ei								; Enable interrupts
                        	   232: 
                        	   233: 
                        	   234: ;  __  __           _         
                        	   235: ; |  \/  |   __ _  (_)  _ __  
                        	   236: ; | |\/| |  / _` | | | | '_ \ 
                        	   237: ; | |  | | | (_| | | | | | | |
                        	   238: ; |_|  |_|  \__,_| |_| |_| |_|
                        	   239: ;
                        	   240: ; ----------------------------
                        	   241: ; MAIN LOOP
                        	   242: 
                        	   243: Main:
01:8046 CDA388          	   244: 	call	CommandPrompt			; Print the command prompt (0000>)
                        	   245: 	
01:8049 C5              	   246: 	push	BC
01:804A E5              	   247: 	push	HL
                        	   248: 	
01:804B 061E            	   249: 	ld		B,30					; Set the maximum number of bytes to read
01:804D 2184B0          	   250: 	ld		HL,CommandBuffer		; Set the memory area to read the string to
01:8050 CDF080          	   251: 	call	ReadString				; Read a string from console (HL is the address of buffer, BC is character count)
                        	   252: 	
01:8053 E1              	   253: 	pop		HL
01:8054 C1              	   254: 	pop		BC
                        	   255: 	
01:8055 CD5889          	   256: 	call	Parser					; Parse the entered command
                        	   257: 	
01:8058 18EC            	   258: 	jr		Main
                        	   259: 
                        	   260: 
                        	   261: ;  ____            _                              _     _                      
                        	   262: ; / ___|   _   _  | |__    _ __    ___    _   _  | |_  (_)  _ __     ___   ___ 
                        	   263: ; \___ \  | | | | | '_ \  | '__|  / _ \  | | | | | __| | | | '_ \   / _ \ / __|
                        	   264: ;  ___) | | |_| | | |_) | | |    | (_) | | |_| | | |_  | | | | | | |  __/ \__ \
                        	   265: ; |____/   \__,_| |_.__/  |_|     \___/   \__,_|  \__| |_| |_| |_|  \___| |___/
                        	   266: ;
                        	   267: ; ---------------------------------------------------------------------------------------------------------------------
                        	   268: ; ALL SUBROUTINES ARE EMBEDED IN VARIOUS INCLUDE FILES
                        	   269: 
                        	   270: 	.include	"io.asm"			; Input and output subroutines

Source: "io.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- PrintChar		[A ->]
                        	     4: ;	- PrintString	[HL ->]
                        	     5: ;	- PrintCRLF
                        	     6: ;	- PrintNibble	[A ->]
                        	     7: ;	- PrintByte		[A ->]
                        	     8: ;	- PrintWord		[HL ->]
                        	     9: ;	- ReadChar		[-> A]
                        	    10: ;	- ReadString	[HL ->]
                        	    11: ;	- ReadByte		[-> A]
                        	    12: ;	- ReadWord		[-> HL]
                        	    13: ;	- SIO_Init
                        	    14: 
                        	    15: 
                        	    16: ;  ____           _           _     ____                
                        	    17: ; |  _ \   _ __  (_)  _ __   | |_  |  _ \    ___    ___ 
                        	    18: ; | |_) | | '__| | | | '_ \  | __| | | | |  / _ \  / __|
                        	    19: ; |  __/  | |    | | | | | | | |_  | |_| | |  __/ | (__ 
                        	    20: ; |_|     |_|    |_| |_| |_|  \__| |____/   \___|  \___|
                        	    21: ;
                        	    22: ;
                        	    23: ; *********************************************************************************************************************
                        	    24: ; Prints a hex number to Decimal on the console
                        	    25: ;	- Input:	HL = 16-bit hex number
                        	    26: ;	- Ouput:	HL = Untouched 16-bit hex number
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: PrintDec:
01:805A E5              	    30: 	push	HL
01:805B CD0E82          	    31: 	call	Hex2Dec
01:805E CDB080          	    32: 	call	PrintString
01:8061 E1              	    33: 	pop		HL
01:8062 C9              	    34: 	ret
                        	    35: 
                        	    36: 
                        	    37: ;  ____           _           _     ____            _          
                        	    38: ; |  _ \   _ __  (_)  _ __   | |_  | __ )   _   _  | |_    ___ 
                        	    39: ; | |_) | | '__| | | | '_ \  | __| |  _ \  | | | | | __|  / _ \
                        	    40: ; |  __/  | |    | | | | | | | |_  | |_) | | |_| | | |_  |  __/
                        	    41: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__, |  \__|  \___|
                        	    42: ;                                           |___/              
                        	    43: ;
                        	    44: ; *********************************************************************************************************************
                        	    45: ; Prints a byte to the console
                        	    46: ;	- Input:	A (Byte to print)
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: PrintByte:
01:8063 F5              	    50: 	push	AF
01:8064 F5              	    51: 	push	AF
01:8065 CB3F            	    52: 	srl		A					; Push the uppermost nibble to the lower half
01:8067 CB3F            	    53: 	srl		A
01:8069 CB3F            	    54: 	srl		A
01:806B CB3F            	    55: 	srl		A
01:806D CDA080          	    56: 	call	PrintNibble			; Print the first nibble of the byte
01:8070 F1              	    57: 	pop		AF
01:8071 CDA080          	    58: 	call	PrintNibble			; Print the second nibble of the byte
01:8074 F1              	    59: 	pop		AF
01:8075 C9              	    60: 	ret
                        	    61: 
                        	    62: 
                        	    63: ;  ____           _           _      ____   _                    
                        	    64: ; |  _ \   _ __  (_)  _ __   | |_   / ___| | |__     __ _   _ __ 
                        	    65: ; | |_) | | '__| | | | '_ \  | __| | |     | '_ \   / _` | | '__|
                        	    66: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | (_| | | |   
                        	    67: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| |_|  \__,_| |_|   
                        	    68: ;
                        	    69: 
                        	    70: ; *********************************************************************************************************************
                        	    71: ; Print a character to the console
                        	    72: ;	- Input: A (Character to transmit)
                        	    73: ; *********************************************************************************************************************
                        	    74: 
                        	    75: PrintChar:
01:8076 F5              	    76: 	push	AF
                        	    77: PrintCharTxWait:
01:8077 DB02            	    78: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in accumulator
01:8079 E604            	    79: 	and		%00000100				; Isolate bit 2: TX Buffer Empty
01:807B 28FA            	    80: 	jr		z,PrintCharTxWait		; If it's busy, then wait
01:807D F1              	    81: 	pop		AF
01:807E D300            	    82: 	out		(SIO_PortA_Data),A		; Transmit the character in accumulator
01:8080 C9              	    83: 	ret
                        	    84: 
                        	    85: 
                        	    86: ;  ____           _           _      ____   ____    _       _____ 
                        	    87: ; |  _ \   _ __  (_)  _ __   | |_   / ___| |  _ \  | |     |  ___|
                        	    88: ; | |_) | | '__| | | | '_ \  | __| | |     | |_) | | |     | |_   
                        	    89: ; |  __/  | |    | | | | | | | |_  | |___  |  _ <  | |___  |  _|  
                        	    90: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| \_\ |_____| |_|    
                        	    91: 
                        	    92: 
                        	    93: ; *********************************************************************************************************************
                        	    94: ; Print a carriage-return and line-feed to serial port A
                        	    95: ; *********************************************************************************************************************
                        	    96: 
                        	    97: PrintCRLF:
01:8081 F5              	    98: 	push	AF
01:8082 3E0D            	    99: 	ld		A,CR
01:8084 CD7680          	   100: 	call	PrintChar				; Print carriage-return
01:8087 3E0A            	   101: 	ld		A,LF
01:8089 CD7680          	   102: 	call	PrintChar				; Print line-feed
01:808C F1              	   103: 	pop		AF
01:808D C9              	   104: 	ret
                        	   105: 
                        	   106: 
                        	   107: ;  ____           _           _     _       _                
                        	   108: ; |  _ \   _ __  (_)  _ __   | |_  | |     (_)  _ __     ___ 
                        	   109: ; | |_) | | '__| | | | '_ \  | __| | |     | | | '_ \   / _ \
                        	   110: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | | |  __/
                        	   111: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_| |_| |_|  \___|
                        	   112: 
                        	   113: 
                        	   114: ; *********************************************************************************************************************
                        	   115: ; Prints a line (the size of HorizTextRes)
                        	   116: ; *********************************************************************************************************************
                        	   117: 
                        	   118: PrintLine:
01:808E F5              	   119: 	push	AF
01:808F C5              	   120: 	push	BC
01:8090 3E28            	   121: 	ld		A,HorizTextRes			; Load the screen width constant
01:8092 47              	   122: 	ld		B,A						; Place it register B
01:8093 3E2D            	   123: 	ld		A,"-"					; Load the dash character
                        	   124: PrintLineLoop:
01:8095 CD7680          	   125: 	call	PrintChar				; Print the dash
01:8098 10FB            	   126: 	djnz	PrintLineLoop			; Decrement B, and loop until B is 0
01:809A CD8180          	   127: 	call	PrintCRLF				; Change line
01:809D C1              	   128: 	pop		BC
01:809E F1              	   129: 	pop		AF
01:809F C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____           _           _     _   _   _   _       _       _        
                        	   134: ; |  _ \   _ __  (_)  _ __   | |_  | \ | | (_) | |__   | |__   | |   ___ 
                        	   135: ; | |_) | | '__| | | | '_ \  | __| |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	   136: ; |  __/  | |    | | | | | | | |_  | |\  | | | | |_) | | |_) | | | |  __/
                        	   137: ; |_|     |_|    |_| |_| |_|  \__| |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	   138: 
                        	   139: 
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Prints a nibble to the console
                        	   142: ;	- Input:	A (LSB to print)
                        	   143: ; *********************************************************************************************************************
                        	   144: 
                        	   145: PrintNibble:
01:80A0 F5              	   146: 	push	AF
01:80A1 E60F            	   147: 	and		$0F						; Filter out MSB
01:80A3 C630            	   148: 	add     "0"						; Add ASCII character 0
01:80A5 FE3A            	   149: 	cp      "9"+1					; Is the value numeric values?
01:80A7 3802            	   150: 	jr		c,PrintNibbleEnd		; Yes, then exit with 0 through 9
01:80A9 C607            	   151: 	add     "A"-"9"-1				; No, then exit with A through F
                        	   152: PrintNibbleEnd:
01:80AB CD7680          	   153: 	call	PrintChar				; Print the nibble
01:80AE F1              	   154: 	pop		AF
01:80AF C9              	   155: 	ret
                        	   156: 	
                        	   157: 	
                        	   158: ;  ____           _           _     ____    _            _                 
                        	   159: ; |  _ \   _ __  (_)  _ __   | |_  / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   160: ; | |_) | | '__| | | | '_ \  | __| \___ \  | __| | '__| | | | '_ \   / _` |
                        	   161: ; |  __/  | |    | | | | | | | |_   ___) | | |_  | |    | | | | | | | (_| |
                        	   162: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   163: ;                                                                    |___/ 
                        	   164: ;
                        	   165: ; *********************************************************************************************************************
                        	   166: ; Prints a string to serial port A, until the null character is reached
                        	   167: ;	- Input:	HL = Address pointer of string to transmit
                        	   168: ;	- Output:	HL = Address pointer to the next character, past NULL (Practical for printing lines in between text)
                        	   169: ; *********************************************************************************************************************
                        	   170: 
                        	   171: PrintString:
01:80B0 F5              	   172: 	push	AF
                        	   173: PrintStringLoop:
01:80B1 7E              	   174: 	ld		A,(HL)					; Load character to print in accumulator
01:80B2 23              	   175: 	inc		HL						; Increment HL to next character to print
01:80B3 FE00            	   176: 	cp		0					; Is it the end of the string?
01:80B5 2805            	   177: 	jr		z,PrintStringEnd		; Yes, then exit routine
01:80B7 CD7680          	   178: 	call	PrintChar				; Print the character
01:80BA 18F5            	   179: 	jr		PrintStringLoop			; Repeat the loop until null character is reached
                        	   180: PrintStringEnd:
01:80BC F1              	   181: 	pop		AF
01:80BD C9              	   182: 	ret
                        	   183: 
                        	   184: 
                        	   185: ;  ____           _           _    __        __                     _ 
                        	   186: ; |  _ \   _ __  (_)  _ __   | |_  \ \      / /   ___    _ __    __| |
                        	   187: ; | |_) | | '__| | | | '_ \  | __|  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   188: ; |  __/  | |    | | | | | | | |_    \ V  V /   | (_) | | |    | (_| |
                        	   189: ; |_|     |_|    |_| |_| |_|  \__|    \_/\_/     \___/  |_|     \__,_|
                        	   190: 
                        	   191: 
                        	   192: ; *********************************************************************************************************************
                        	   193: ; Prints a 16-bit word (double-byte) to the console
                        	   194: ;	- Input: HL (Word to print)
                        	   195: ; *********************************************************************************************************************
                        	   196: 
                        	   197: PrintWord:
01:80BE F5              	   198: 	push	AF
01:80BF 7C              	   199: 	ld		A,H						; Get the first byte in accumulator
01:80C0 CD6380          	   200: 	call	PrintByte				; Print first byte
01:80C3 7D              	   201: 	ld		A,L						; Get the second byte in accumulator
01:80C4 CD6380          	   202: 	call	PrintByte				; Print second byte
01:80C7 F1              	   203: 	pop		AF
01:80C8 C9              	   204: 	ret
                        	   205: 
                        	   206: 
                        	   207: ;  ____                       _    ____   _                    
                        	   208: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __ 
                        	   209: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__|
                        	   210: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |   
                        	   211: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|   
                        	   212: 
                        	   213: 
                        	   214: ; *********************************************************************************************************************
                        	   215: ; Read a character from the console (waiting)
                        	   216: ;	- Output:	Character received in A
                        	   217: ; *********************************************************************************************************************
                        	   218: 
                        	   219: ReadChar:
01:80C9 DB02            	   220: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80CB E601            	   221: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80CD 28FA            	   222: 	jr		z,ReadChar				; If there's no character in buffer, loop until one is present
01:80CF DB00            	   223: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80D1 C9              	   224: 	ret
                        	   225: 
                        	   226: 
                        	   227: ;  ____                       _    ____   _                      _   _          __        __          _   _   
                        	   228: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __  | \ | |   ___   \ \      / /   __ _  (_) | |_ 
                        	   229: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__| |  \| |  / _ \   \ \ /\ / /   / _` | | | | __|
                        	   230: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |    | |\  | | (_) |   \ V  V /   | (_| | | | | |_ 
                        	   231: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|    |_| \_|  \___/     \_/\_/     \__,_| |_|  \__|
                        	   232: ;
                        	   233: ;
                        	   234: ; *********************************************************************************************************************
                        	   235: ; Read a character from the console if present (non-waiting)
                        	   236: ;	- Output:	Character in A if received.
                        	   237: ;				A = 0 if no character received.
                        	   238: ;				Z = not ready, NZ = has character
                        	   239: ; *********************************************************************************************************************
                        	   240: 
                        	   241: ReadCharNoWait:
01:80D2 DB02            	   242: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80D4 E601            	   243: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80D6 3E00            	   244: 	ld		A,$00					; Put nothing in A
01:80D8 C8              	   245: 	ret		z						; Return if not ready
01:80D9 DB00            	   246: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80DB B7              	   247: 	or		A						; Resets the carry flag (and zero)
01:80DC C9              	   248: 	ret
                        	   249: 
                        	   250: 
                        	   251: ;  ____                       _   ____            _          
                        	   252: ; |  _ \    ___    __ _    __| | | __ )   _   _  | |_    ___ 
                        	   253: ; | |_) |  / _ \  / _` |  / _` | |  _ \  | | | | | __|  / _ \
                        	   254: ; |  _ <  |  __/ | (_| | | (_| | | |_) | | |_| | | |_  |  __/
                        	   255: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__, |  \__|  \___|
                        	   256: ;                                         |___/              
                        	   257: ;
                        	   258: ; *********************************************************************************************************************
                        	   259: ; Read a byte (2 ASCII Hex characters) from the console (waiting)
                        	   260: ;	- Output: Byte received in A
                        	   261: ; *********************************************************************************************************************
                        	   262: 
                        	   263: ReadByte:
01:80DD E5              	   264: 	push	HL
01:80DE 21B3B0          	   265: 	ld		HL,DigitString			; Point to staging area to convert ASCII Characters to a byte
01:80E1 CDC980          	   266: 	call	ReadChar				; Read first character
01:80E4 77              	   267: 	ld		(HL),A					; Store it
01:80E5 23              	   268: 	inc		HL						; Point to the next cell
01:80E6 CDC980          	   269: 	call	ReadChar				; Read second character
01:80E9 77              	   270: 	ld		(HL),A					; Store it
01:80EA 2B              	   271: 	dec		HL						; Point back to the beginning
01:80EB CD8F81          	   272: 	call	Ascii2HexByte
01:80EE E1              	   273: 	pop		HL
01:80EF C9              	   274: 	ret
                        	   275: 
                        	   276: 
                        	   277: ;  ____                       _   ____    _            _                 
                        	   278: ; |  _ \    ___    __ _    __| | / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   279: ; | |_) |  / _ \  / _` |  / _` | \___ \  | __| | '__| | | | '_ \   / _` |
                        	   280: ; |  _ <  |  __/ | (_| | | (_| |  ___) | | |_  | |    | | | | | | | (_| |
                        	   281: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   282: ;                                                                  |___/ 
                        	   283: 
                        	   284: ; *********************************************************************************************************************
                        	   285: ; Read a string from console
                        	   286: ;	- Input:	HL = Points to the memory area to store string
                        	   287: ;				B = Bytes to count
                        	   288: ;	- Output:	HL = Points to the start of string
                        	   289: ; *********************************************************************************************************************
                        	   290: 
                        	   291: ReadString:
01:80F0 F5              	   292: 	push	AF
01:80F1 C5              	   293: 	push	BC
01:80F2 D5              	   294: 	push	DE
01:80F3 E5              	   295: 	push	HL						; Store the start position
                        	   296: 
01:80F4 0E00            	   297: 	ld		C,0						; Character counter initialized to zero
01:80F6 E5              	   298: 	push	HL						; Save HL's start position...
01:80F7 D1              	   299: 	pop		DE						; in DE for later use
                        	   300: ;	ld		HL,CommandBuffer		; Load CommandBuffer location in HL
                        	   301: 
                        	   302: ; READ A CHARACTER AND VALIDATE
                        	   303: ReadStringChar:	
01:80F8 CDC980          	   304: 	call	ReadChar				; Read a character from console
01:80FB FE08            	   305: 	cp		BKSP					; Is it the backspace?
01:80FD 281C            	   306: 	jr		z,ReadStringBS			; If it is, then erase last character
01:80FF FE1B            	   307: 	cp		ESC						; Is it the escape key?
01:8101 2831            	   308: 	jr		z,ReadStringESC			; If it is, then ignore whatever has been entered
01:8103 FE0D            	   309: 	cp		CR						; Is it the carriage return?
01:8105 282E            	   310: 	jr		z,ReadStringCR			; If it is, then end the routine
01:8107 FE80            	   311: 	cp		$80						; Is it a character above or equal to the ASCII value $80?
01:8109 30ED            	   312: 	jr		nc,ReadStringChar		; Loop to get a valid ASCII character
01:810B FE20            	   313: 	cp		$20						; Is it any other non-printable character?
01:810D 38E9            	   314: 	jr		c,ReadStringChar		; Loop to get a valid ASCII character
                        	   315: 
                        	   316: ; STORE THE CHARACTER IN THE BUFFER
                        	   317: ReadStringSave:
01:810F CD7680          	   318: 	call	PrintChar				; Echo typed character on screen
                        	   319: ;	call	UpperCase				; *** (Optional) *****************************
01:8112 77              	   320: 	ld		(HL),A					; Store character in memory
01:8113 23              	   321: 	inc		HL						; Increment buffer to next spot
01:8114 0C              	   322: 	inc		C						; Increment bytes counter
01:8115 78              	   323: 	ld		A,B						; Load total bytes to read in accumulator
01:8116 B9              	   324: 	cp		C						; Has the total number of characters been read?
01:8117 3802            	   325: 	jr		c,ReadStringBS			; If it was one too many characters, backspace
01:8119 18DD            	   326: 	jr		ReadStringChar			; Else, loop to get the next character
                        	   327: 
                        	   328: ReadStringBS:
01:811B 79              	   329: 	ld		A,C						; Load characther counter in accumulator
01:811C FE00            	   330: 	cp		0						; Are there any characters to erase?
01:811E CAF880          	   331: 	jp		z,ReadStringChar		; No, then go read another character
01:8121 0D              	   332: 	dec		C						; Else, decrement character counter by one
01:8122 2B              	   333: 	dec		HL						; And decrement buffer to previous spot
01:8123 3E08            	   334: 	ld		A,BKSP					; Erace character on screen...
01:8125 CD7680          	   335: 	call	PrintChar				; Go back one previous character
01:8128 3E20            	   336: 	ld		A," "					;
01:812A CD7680          	   337: 	call	PrintChar				; Overwrite the character with a space
01:812D 3E08            	   338: 	ld		A,BKSP					;
01:812F CD7680          	   339: 	call	PrintChar				; Then go back one character again
01:8132 18C4            	   340: 	jr		ReadStringChar			; Get the next character
                        	   341: 	
                        	   342: ReadStringESC:
01:8134 EB              	   343: 	ex		DE,HL					; Restore start position of HL
                        	   344: ;	ld		HL,CommandBuffer		; Point CommandBuffer to start
                        	   345: 
                        	   346: ReadStringCR:
01:8135 3600            	   347: 	ld		(HL),0					; Write NULL character in buffer to indicate end of string
01:8137 CD8180          	   348: 	call	PrintCRLF				; Change line
                        	   349: 	
01:813A E1              	   350: 	pop		HL						; Points to the start of the string
01:813B D1              	   351: 	pop		DE
01:813C C1              	   352: 	pop		BC
01:813D F1              	   353: 	pop		AF
01:813E C9              	   354: 	ret
                        	   355: 
                        	   356: 
                        	   357: ;  ____                       _  __        __                     _ 
                        	   358: ; |  _ \    ___    __ _    __| | \ \      / /   ___    _ __    __| |
                        	   359: ; | |_) |  / _ \  / _` |  / _` |  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   360: ; |  _ <  |  __/ | (_| | | (_| |   \ V  V /   | (_) | | |    | (_| |
                        	   361: ; |_| \_\  \___|  \__,_|  \__,_|    \_/\_/     \___/  |_|     \__,_|
                        	   362: 
                        	   363: 
                        	   364: ; *********************************************************************************************************************
                        	   365: ; Read a word (4 ASCII Hex characters) from the console (waiting)
                        	   366: ;	- Output: Word received in HL
                        	   367: ; *********************************************************************************************************************
                        	   368: 
                        	   369: ReadWord:
01:813F F5              	   370: 	push	AF
01:8140 CDDD80          	   371: 	call	ReadByte			; Read first byte (first and second ASCII character)
01:8143 67              	   372: 	ld		H,A					; Store the MSB
01:8144 CDDD80          	   373: 	call	ReadByte			; Read second byte (third and fourth ASCII character)
01:8147 6F              	   374: 	ld		L,A					; Store the LSB
01:8148 CDAE81          	   375: 	call	Ascii2HexWord		; Convert the ASCII characters to a word, result in BC
01:814B F1              	   376: 	pop		AF
01:814C C9              	   377: 	ret
                        	   378: 
                        	   379: 	
                        	   380: ;  ____    ___    ___            ___           _   _   
                        	   381: ; / ___|  |_ _|  / _ \          |_ _|  _ __   (_) | |_ 
                        	   382: ; \___ \   | |  | | | |          | |  | '_ \  | | | __|
                        	   383: ;  ___) |  | |  | |_| |          | |  | | | | | | | |_ 
                        	   384: ; |____/  |___|  \___/   _____  |___| |_| |_| |_|  \__|
                        	   385: ;                       |_____|                        
                        	   386: 
                        	   387: ; *********************************************************************************************************************
                        	   388: ; Initializes SIO port A
                        	   389: ;   - Destroys: AF, HL, BC (There's usually no need to save registers in the init stage)
                        	   390: ; *********************************************************************************************************************
                        	   391: 
                        	   392: SIO_Init:
01:814D 3E18            	   393: 	ld		A,%00011000				; Perform channel reset
01:814F D302            	   394: 	out		(SIO_PortA_Ctrl),A		; Requires four extra clock cycles for the SIO reset time
01:8151 00              	   395: 	nop
01:8152 3E04            	   396: 	ld		A,%00000100				; WR0: select register 4
01:8154 D302            	   397: 	out		(SIO_PortA_Ctrl),A
01:8156 3E44            	   398: 	ld		A,%01000100				; WR4: 1/16 (115200 @ 1.8432MHZ), 8-bit sync, 1 stop bit, no parity
01:8158 D302            	   399: 	out		(SIO_PortA_Ctrl),A
01:815A 3E03            	   400: 	ld		A,%00000011				; WR0: select register 3
01:815C D302            	   401: 	out		(SIO_PortA_Ctrl),A
01:815E 3EC1            	   402: 	ld		A,%11000001				; WR3: 8-bits/char, RX enabled
01:8160 D302            	   403: 	out		(SIO_PortA_Ctrl),A
01:8162 3E05            	   404: 	ld		A,%00000101				; WR0: select register 5
01:8164 D302            	   405: 	out		(SIO_PortA_Ctrl),A
01:8166 3E68            	   406: 	ld		A,%01101000				; WR5: DTR=0, 8-bits/char, TX enabled
01:8168 D302            	   407: 	out		(SIO_PortA_Ctrl),A
01:816A C9              	   408: 	ret
                        	   409: 

Source: "main.asm"
                        	   271: 	.include	"convert.asm"		; Convert and process data subroutines

Source: "convert.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- Ascii2HexNibble	[A -> A]
                        	     4: ;	- Ascii2HexByte		[HL -> A]
                        	     5: ;	- Ascii2HexWord		[HL -> BC]
                        	     6: ;	- UpperCase			[A -> A]
                        	     7: 
                        	     8: ; *********************************************************************************************************************
                        	     9: ; Converts a single decimal digit to BCD
                        	    10: ;	- Input:	A = Contains the ASCII character to convert to BCD
                        	    11: ;	- Output:	A = Contains the 4-bit BCD value in LSB
                        	    12: ;				Carry set if valid; Carry clear if error
                        	    13: ; *********************************************************************************************************************
                        	    14: 
                        	    15: Ascii2BcdDigit:
                        	    16: 
                        	    17: ;     _                   _   _   ____    _   _                 _   _   _   _       _       _        
                        	    18: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | \ | | (_) | |__   | |__   | |   ___ 
                        	    19: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	    20: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |\  | | | | |_) | | |_) | | | |  __/
                        	    21: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	    22: ;
                        	    23: 
                        	    24: ; *********************************************************************************************************************
                        	    25: ; Converts a single ASCII hex character to a nibble, and validate if it's ok
                        	    26: ;	- Input:	A = Contains the ASCII character to convert to hex value
                        	    27: ;	- Output:	A = Converted 4-bit value in LSB
                        	    28: ;				Carry set if valid; Carry clear if error
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: Ascii2HexNibble:
01:816B CDA182          	    32: 	call	UpperCase				; Convert a-f to uppercase
01:816E FE30            	    33: 	cp		"0"						; If it's anything bellow 0
01:8170 381B            	    34: 	jr		c,Ascii2HexNibbleErr	; Then indicate an error
01:8172 FE47            	    35: 	cp		"F"+1					; If it's anything above F
01:8174 3017            	    36: 	jr		nc,Ascii2HexNibbleErr	; Then indicate an error
01:8176 FE3A            	    37: 	cp		"9"+1					; Check if it's less then 9
01:8178 3806            	    38: 	jr		c,Ascii2HexNibbleOK		; Then it's a valid 0-9 digit
01:817A FE41            	    39: 	cp		"A"						; Check if it's above A
01:817C 3002            	    40: 	jr		nc,Ascii2HexNibbleOK	; Then it's a valid A-F hex digit
01:817E 180D            	    41: 	jr		Ascii2HexNibbleErr		; Else, anything in between is an error
                        	    42: 
                        	    43: Ascii2HexNibbleOK:
01:8180 D630            	    44: 	sub		$30						; Substract $30 to transform character 0-9 into a number
01:8182 FE0A            	    45: 	cp		9+1						; Is it a decimal 0-9 digit?
01:8184 3802            	    46: 	jr		c,Ascii2HexNibbleEnd	; If it's then return value it as is
01:8186 D607            	    47: 	sub		$07						; If not, then substract the alpha offset to get A-F
                        	    48: 
                        	    49: Ascii2HexNibbleEnd:
01:8188 CD4E89          	    50: 	call	IncErrorPointer			; Increment command line error pointer
01:818B 37              	    51: 	scf								; Set carry flag
01:818C C9              	    52: 	ret
                        	    53: 
                        	    54: Ascii2HexNibbleErr:
01:818D B7              	    55: 	or		A						; Clear carry flag
01:818E C9              	    56: 	ret
                        	    57: 
                        	    58: 
                        	    59: ;     _                   _   _   ____    _   _                 ____            _          
                        	    60: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	    61: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	    62: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	    63: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	    64: ;                                                                       |___/              
                        	    65: ;
                        	    66: ; *********************************************************************************************************************
                        	    67: ; Converts a pair of ASCII hex characters to a byte and validate if it's ok
                        	    68: ;	- Input:	HL = Points to the two characters to convert
                        	    69: ;	- Output:	A = Converted 8-bit byte
                        	    70: ;				HL = points to the next position
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: Ascii2HexByte:
01:818F C5              	    75: 	push	BC
01:8190 7E              	    76: 	ld		A,(HL)
01:8191 23              	    77: 	inc		HL
01:8192 CD6B81          	    78: 	call	Ascii2HexNibble			; Convert the first character (MSB)
01:8195 3014            	    79: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:8197 CB27            	    80: 	sla		A						; Place result to the MSB position...
01:8199 CB27            	    81: 	sla		A						;	by shifting it 4 times to the left...
01:819B CB27            	    82: 	sla		A						;	and zeroing out the LSB in the process
01:819D CB27            	    83: 	sla		A						;
01:819F 47              	    84: 	ld		B,A						; Save resulting MSB
01:81A0 7E              	    85: 	ld		A,(HL)
01:81A1 23              	    86: 	inc		HL
01:81A2 CD6B81          	    87: 	call	Ascii2HexNibble			; Convert the second character (LSB)
01:81A5 3004            	    88: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:81A7 B0              	    89: 	or		B						; Merge MSB with LSB, result in A
01:81A8 C1              	    90: 	pop		BC
01:81A9 37              	    91: 	scf								; Set carry flag
01:81AA C9              	    92: 	ret
                        	    93: 
                        	    94: Ascii2HexByteErr:
01:81AB C1              	    95: 	pop		BC
01:81AC B7              	    96: 	or		A						; Clear carry flag
01:81AD C9              	    97: 	ret
                        	    98: 
                        	    99: 
                        	   100: ;     _                   _   _   ____    _   _                 ____            _          
                        	   101: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	   102: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	   103: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	   104: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	   105: ;                                                                       |___/              
                        	   106: ;
                        	   107: ; *********************************************************************************************************************
                        	   108: ; Converts four ASCII hex characters to a 16-bit word and validate if it's ok
                        	   109: ;	- Input:	HL = Points to the 4 characters to be converted
                        	   110: ;	- Output:	BC = Contains the 16-bit value
                        	   111: ;				HL = points to the next position
                        	   112: ;				Carry set if valid; Carry clear if error
                        	   113: ; *********************************************************************************************************************
                        	   114: 
                        	   115: Ascii2HexWord:
01:81AE F5              	   116: 	push	AF
01:81AF CD8F81          	   117: 	call	Ascii2HexByte			; Convert the upper 2 characters (MSB)
01:81B2 300A            	   118: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81B4 47              	   119: 	ld		B,A						; Save the MSB result to B
01:81B5 CD8F81          	   120: 	call	Ascii2HexByte			; Convert the lower 2 characters (LSB)
01:81B8 3004            	   121: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81BA 4F              	   122: 	ld		C,A						; Save the the LSB
01:81BB F1              	   123: 	pop		AF
01:81BC 37              	   124: 	scf								; Set carry flag
01:81BD C9              	   125: 	ret
                        	   126: 	
                        	   127: Ascii2HexWordErr:
01:81BE F1              	   128: 	pop		AF
01:81BF B7              	   129: 	or		A						; Clear carry flag
01:81C0 C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____                  ____    _   _               
                        	   134: ; |  _ \    ___    ___  |___ \  | | | |   ___  __  __
                        	   135: ; | | | |  / _ \  / __|   __) | | |_| |  / _ \ \ \/ /
                        	   136: ; | |_| | |  __/ | (__   / __/  |  _  | |  __/  >  < 
                        	   137: ; |____/   \___|  \___| |_____| |_| |_|  \___| /_/\_\
                        	   138: ;
                        	   139: ;
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Convert decimal digits in a string to a hex number
                        	   142: ;	- Input:	HL = Points to the string the decimal characters are
                        	   143: ;	- Output:	BC = 16-bit hex value
                        	   144: ;				HL = Points to the next position after the last decimal number
                        	   145: ; *********************************************************************************************************************
                        	   146: 
                        	   147: Dec2Hex:
01:81C1 F5              	   148: 	push	AF
01:81C2 D5              	   149: 	push	DE
                        	   150: 	
01:81C3 CD3B8B          	   151: 	call	SkipSpaces
01:81C6 EB              	   152: 	ex		DE,HL					; HL is normally processed for strings, but ADD requires HL in this routine
01:81C7 210000          	   153: 	ld		HL,0
                        	   154: Dec2HexLoop:		
01:81CA 1A              	   155: 	ld		A,(DE)					; HL is required for add, so DE is used to grab the string instead of HL
01:81CB FE00            	   156: 	cp		0
01:81CD 2829            	   157: 	jr		z,Dec2HexShuffleRegs
01:81CF FE20            	   158: 	cp		DELIMITER
01:81D1 2825            	   159: 	jr		z,Dec2HexShuffleRegs
                        	   160: 	
01:81D3 FE30            	   161: 	cp		"0"						; If it's anything bellow 0
01:81D5 382D            	   162: 	jr		c,Dec2HexInvalidDec		; Then indicate an error
01:81D7 FE3A            	   163: 	cp		"9"+1					; Check if it's less then 9
01:81D9 3029            	   164: 	jr		nc,Dec2HexInvalidDec	; Then indicate an error
                        	   165: 
01:81DB D630            	   166: 	sub		$30						; Convert ASCII decimal to BCD
01:81DD 13              	   167: 	inc		DE						; Increment buffer pointer
01:81DE CD4E89          	   168: 	call	IncErrorPointer
                        	   169: 
01:81E1 E5              	   170: 	push	HL
01:81E2 C1              	   171: 	pop		BC
                        	   172: 
01:81E3 29              	   173: 	add		HL,HL
01:81E4 3818            	   174: 	jr		c,Dec2HexOutOfRange
01:81E6 29              	   175: 	add		HL,HL	
01:81E7 3815            	   176: 	jr		c,Dec2HexOutOfRange
01:81E9 09              	   177: 	add		HL,BC	
01:81EA 3812            	   178: 	jr		c,Dec2HexOutOfRange
01:81EC 29              	   179: 	add		HL,HL
01:81ED 380F            	   180: 	jr		c,Dec2HexOutOfRange
                        	   181: 	
01:81EF 85              	   182: 	add		L	
01:81F0 6F              	   183: 	ld		L,A	
01:81F1 30D7            	   184: 	jr		nc,Dec2HexLoop
01:81F3 24              	   185: 	inc		H
01:81F4 3808            	   186: 	jr		c,Dec2HexOutOfRange
01:81F6 18D2            	   187: 	jr		Dec2HexLoop
                        	   188: 
                        	   189: Dec2HexShuffleRegs:
01:81F8 E5              	   190: 	push	HL						; Push result in BC
01:81F9 C1              	   191: 	pop		BC						;
01:81FA EB              	   192: 	ex		DE,HL					; Place buffer pointer in HL
01:81FB 37              	   193: 	scf								; Set Carry
01:81FC 180D            	   194: 	jr		Dec2HexEnd
                        	   195: 
                        	   196: Dec2HexOutOfRange:
01:81FE CD63B0          	   197: 	call	NumberOutOfRange
01:8201 B7              	   198: 	or		A
01:8202 1807            	   199: 	jr		Dec2HexEnd
                        	   200: 	
                        	   201: Dec2HexInvalidDec:
01:8204 CDC089          	   202: 	call	PrintErrorPointer
01:8207 CD6CB0          	   203: 	call	InvalidDecimalNumber
01:820A B7              	   204: 	or		A
                        	   205: 	
                        	   206: Dec2HexEnd:
01:820B D1              	   207: 	pop		DE
01:820C F1              	   208: 	pop		AF
01:820D C9              	   209: 	ret
                        	   210: 
                        	   211: 
                        	   212: ;  _   _                 ____    ____                
                        	   213: ; | | | |   ___  __  __ |___ \  |  _ \    ___    ___ 
                        	   214: ; | |_| |  / _ \ \ \/ /   __) | | | | |  / _ \  / __|
                        	   215: ; |  _  | |  __/  >  <   / __/  | |_| | |  __/ | (__ 
                        	   216: ; |_| |_|  \___| /_/\_\ |_____| |____/   \___|  \___|
                        	   217: ;
                        	   218: ;
                        	   219: ; *********************************************************************************************************************
                        	   220: ; Convert a 16-bit a hex binary data to a decimal string
                        	   221: ;	- Input:	HL = 16-bit hex number
                        	   222: ;	- Output:	HL = Start of string pointer (DigitString variable) - Ends with null
                        	   223: ; *********************************************************************************************************************
                        	   224: ; B is the first non-zero flag, so as not to print leading zero's
                        	   225: 
                        	   226: Hex2Dec:
01:820E F5              	   227: 	push	AF
01:820F C5              	   228: 	push	BC
01:8210 D5              	   229: 	push	DE
01:8211 DDE5            	   230: 	push	IX
                        	   231: 
01:8213 0600            	   232: 	ld		B,0
01:8215 DD21B3B0        	   233: 	ld		IX,DigitString
                        	   234: Hex2Dec10000:
                        	   235: 	; CALCULATE THE 10,000's
01:8219 3EFF            	   236: 	ld		A,-1					; Start at -1
                        	   237: Hex2Dec10000Loop:
01:821B 3C              	   238: 	inc		A						; Add 1
01:821C B7              	   239: 	or		A						; Clear carry
01:821D 111027          	   240: 	ld		DE,10000
01:8220 ED52            	   241: 	sbc		HL,DE					; Substract 10,000
01:8222 30F7            	   242: 	jr		nc,Hex2Dec10000Loop		; Continue if not reached negative
01:8224 19              	   243: 	add		HL,DE					; Add 10,000 back to make it positive
01:8225 FE00            	   244: 	cp		0
01:8227 2002            	   245: 	jr		nz,Hex2Dec10000Set
01:8229 1809            	   246: 	jr		Hex2Dec1000				; If it's not set
                        	   247: Hex2Dec10000Set
01:822B CBC0            	   248: 	set		0,B
01:822D C630            	   249: 	add		$30
01:822F DD7700          	   250: 	ld		(IX),A
01:8232 DD23            	   251: 	inc		IX
                        	   252: 
                        	   253: 	; CALCULATE THE 1,000's
                        	   254: Hex2Dec1000:
01:8234 3EFF            	   255: 	ld		A,-1					; Start at -1
                        	   256: Hex2Dec1000Loop:
01:8236 3C              	   257: 	inc		A						; Add 1
01:8237 B7              	   258: 	or		A						; Clear carry
01:8238 11E803          	   259: 	ld		DE,1000
01:823B ED52            	   260: 	sbc		HL,DE					; Substract 1,000
01:823D 30F7            	   261: 	jr		nc,Hex2Dec1000Loop		; Continue if not reached negative
01:823F 19              	   262: 	add		HL,DE					; Add 1,000 back to make it positive
01:8240 FE00            	   263: 	cp		0
01:8242 2004            	   264: 	jr		nz,Hex2Dec1000Set
01:8244 CB40            	   265: 	bit		0,B						; Check the flag
01:8246 2809            	   266: 	jr		z,Hex2Dec100			; If it's not set
                        	   267: Hex2Dec1000Set
01:8248 CBC0            	   268: 	set		0,B						
01:824A C630            	   269: 	add		$30
01:824C DD7700          	   270: 	ld		(IX),A
01:824F DD23            	   271: 	inc		IX
                        	   272: 
                        	   273: 	; CALCULATE THE 100's
                        	   274: Hex2Dec100:
01:8251 3EFF            	   275: 	ld		A,-1					; Start at -1
                        	   276: Hex2Dec100Loop:
01:8253 3C              	   277: 	inc		A						; Add 1
01:8254 B7              	   278: 	or		A						; Clear carry
01:8255 116400          	   279: 	ld		DE,100
01:8258 ED52            	   280: 	sbc		HL,DE					; Substract 100
01:825A 30F7            	   281: 	jr		nc,Hex2Dec100Loop		; Continue if not reached negative
01:825C 19              	   282: 	add		HL,DE					; Add 100 back to make it positive
01:825D FE00            	   283: 	cp		0
01:825F 2004            	   284: 	jr		nz,Hex2Dec100Set
01:8261 CB40            	   285: 	bit		0,B						; Check the flag
01:8263 2809            	   286: 	jr		z,Hex2Dec10				; If it's not set
                        	   287: Hex2Dec100Set
01:8265 CBC0            	   288: 	set		0,B						
01:8267 C630            	   289: 	add		$30
01:8269 DD7700          	   290: 	ld		(IX),A
01:826C DD23            	   291: 	inc		IX
                        	   292: 
                        	   293: 
                        	   294: 	; CALCULATE THE 10's
                        	   295: Hex2Dec10:
01:826E 3EFF            	   296: 	ld		A,-1					; Start at -1
                        	   297: Hex2Dec10Loop:
01:8270 3C              	   298: 	inc		A						; Add 1
01:8271 B7              	   299: 	or		A						; Clear carry
01:8272 110A00          	   300: 	ld		DE,10
01:8275 ED52            	   301: 	sbc		HL,DE					; Substract 10
01:8277 30F7            	   302: 	jr		nc,Hex2Dec10Loop		; Continue if not reached negative
01:8279 19              	   303: 	add		HL,DE					; Add 10 back to make it positive
01:827A FE00            	   304: 	cp		0
01:827C 2004            	   305: 	jr		nz,Hex2Dec10Set
01:827E CB40            	   306: 	bit		0,B						; Check the flag
01:8280 2809            	   307: 	jr		z,Hex2Dec1				; If it's not set
                        	   308: Hex2Dec10Set
01:8282 CBC0            	   309: 	set		0,B						
01:8284 C630            	   310: 	add		$30
01:8286 DD7700          	   311: 	ld		(IX),A
01:8289 DD23            	   312: 	inc		IX
                        	   313: 
                        	   314: 	; STORE THE 1's
                        	   315: Hex2Dec1:
01:828B 7D              	   316: 	ld		A,L
01:828C C630            	   317: 	add		$30
01:828E DD7700          	   318: 	ld		(IX),A
01:8291 DD23            	   319: 	inc		IX
01:8293 3E00            	   320: 	ld		A,0
01:8295 DD7700          	   321: 	ld		(IX),A					; End string with null character
                        	   322: 	
                        	   323: Hex2DecEnd:
01:8298 21B3B0          	   324: 	ld		HL,DigitString			; Point to decimal string to output
                        	   325: 	
01:829B DDE1            	   326: 	pop		IX
01:829D D1              	   327: 	pop		DE
01:829E C1              	   328: 	pop		BC
01:829F F1              	   329: 	pop		AF
01:82A0 C9              	   330: 	ret
                        	   331: 
                        	   332: 
                        	   333: ;  _   _                                  ____                      
                        	   334: ; | | | |  _ __    _ __     ___   _ __   / ___|   __ _   ___    ___ 
                        	   335: ; | | | | | '_ \  | '_ \   / _ \ | '__| | |      / _` | / __|  / _ \
                        	   336: ; | |_| | | |_) | | |_) | |  __/ | |    | |___  | (_| | \__ \ |  __/
                        	   337: ;  \___/  | .__/  | .__/   \___| |_|     \____|  \__,_| |___/  \___|
                        	   338: ;         |_|     |_|                                               
                        	   339: ;
                        	   340: ; *********************************************************************************************************************
                        	   341: ; Converts a character to uppercase
                        	   342: ;	- INPUT:	A = Character to uppercase
                        	   343: ;	- OUTPUT:	A = Uppercased character
                        	   344: ; *********************************************************************************************************************
                        	   345: 
                        	   346: UpperCase:
01:82A1 FE61            	   347: 	cp		"a"						; Is the value less then lowercase a?
01:82A3 3806            	   348: 	jr		c,UpperCaseEnd			; If so, then end routine
01:82A5 FE7B            	   349: 	cp		"z"+1					; Is the value more then lowercase z?
01:82A7 3002            	   350: 	jr		nc,UpperCaseEnd			; If so, then end routine
01:82A9 D620            	   351: 	sub		32						; Substract the ASCII difference
                        	   352: UpperCaseEnd:
01:82AB C9              	   353: 	ret
                        	   354: 	

Source: "main.asm"
                        	   272: 	.include	"monitor.asm"		; Monitor command subroutines

Source: "monitor.asm"
                        	     1: ; Command routines in this include file:
                        	     2: ; --------------------------------------
                        	     3: ;	- ClearScreen					; {}
                        	     4: ;	- Diagnostics					; {}
                        	     5: ;	- Fill							; {SSSS EEEE BB}
                        	     6: ;	- HexDump 						; {AAAA LL}
                        	     7: ;	- IntelHex  					; {}
                        	     8: ;	- List  						; {}
                        	     9: ;	- Peek							; [AAAA]
                        	    10: ;	- Poke							; AAAA BB
                        	    11: ;	- Registers  					; {}
                        	    12: ;	- Run  							; {AAAA}
                        	    13: ;	- SetAddress					; [AAAA]
                        	    14: ;	- SetBank						; [N]
                        	    15: ;	- SysInfo 						; {}
                        	    16: ;	- Write							; AAAA BB [BB] [BB] [BB] [BB] [BB]
                        	    17: ;	- Zero							; {}
                        	    18: 
                        	    19: 
                        	    20: ;   ____   _                         ____                                      
                        	    21: ;  / ___| | |   ___    __ _   _ __  / ___|    ___   _ __    ___    ___   _ __  
                        	    22: ; | |     | |  / _ \  / _` | | '__| \___ \   / __| | '__|  / _ \  / _ \ | '_ \ 
                        	    23: ; | |___  | | |  __/ | (_| | | |     ___) | | (__  | |    |  __/ |  __/ | | | |
                        	    24: ;  \____| |_|  \___|  \__,_| |_|    |____/   \___| |_|     \___|  \___| |_| |_|
                        	    25: ;
                        	    26: 
                        	    27: ; *********************************************************************************************************************
                        	    28: ; ClearScreen: Clears the VT terminal screen
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: ClearScreen:
01:82AC E5              	    32: 	push	HL
01:82AD 21A1AB          	    33: 	ld		HL,ClearScreenSeq
01:82B0 CDB080          	    34: 	call	PrintString
01:82B3 E1              	    35: 	pop		HL
01:82B4 C9              	    36: 	ret
                        	    37: 
                        	    38: 
                        	    39: ;   ____                           ____    _                  _    
                        	    40: ;  / ___|   ___    _ __    _   _  | __ )  | |   ___     ___  | | __
                        	    41: ; | |      / _ \  | '_ \  | | | | |  _ \  | |  / _ \   / __| | |/ /
                        	    42: ; | |___  | (_) | | |_) | | |_| | | |_) | | | | (_) | | (__  |   < 
                        	    43: ;  \____|  \___/  | .__/   \__, | |____/  |_|  \___/   \___| |_|\_\
                        	    44: ;                 |_|      |___/
                        	    45: ;
                        	    46: ; *********************************************************************************************************************
                        	    47: ; Copy data from source to destination
                        	    48: ; - Input:	HL = Source address
                        	    49: ;			DE = Destination address
                        	    50: ;			BC = Number of bytes to move
                        	    51: ; *********************************************************************************************************************
                        	    52: 
                        	    53: CopyBlock:
01:82B5 F5              	    54: 	push	AF
01:82B6 C5              	    55: 	push	BC
01:82B7 D5              	    56: 	push	DE
01:82B8 E5              	    57: 	push	HL
                        	    58: 
01:82B9 2AACB0          	    59: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	    60: 	
                        	    61: CopySourceAddress:
01:82BC CDCD88          	    62: 	call	GetHexParameter			; Get the first parameter, start address
01:82BF D21583          	    63: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82C2 FE00            	    64: 	cp		0						; Is there a first parameter?
01:82C4 2847            	    65: 	jr		z,CopyNoParameter		; No, then print error message
01:82C6 ED43CCB0        	    66: 	ld		(StartAddress),BC		; Save source address
                        	    67: 
                        	    68: CopyDestinationAddress:
01:82CA CDCD88          	    69: 	call	GetHexParameter			; Get the first parameter, start address
01:82CD D21583          	    70: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82D0 FE00            	    71: 	cp		0						; Is there a first parameter?
01:82D2 2839            	    72: 	jr		z,CopyNoParameter		; No, then print error message
01:82D4 ED43CEB0        	    73: 	ld		(EndAddress),BC			; Save destination address
                        	    74: 
                        	    75: CopyNumberOfBytes:
01:82D8 CDCD88          	    76: 	call	GetHexParameter			; Get the first parameter, start address
01:82DB D21583          	    77: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82DE FE00            	    78: 	cp		0						; Is there a first parameter?
01:82E0 282B            	    79: 	jr		z,CopyNoParameter		; No, then print error message
                        	    80: 
                        	    81: 	; Check if the number of bytes is zero
01:82E2 78              	    82: 	ld		A,B
01:82E3 B1              	    83: 	or		C
01:82E4 282C            	    84: 	jr		z,CopyNothing
                        	    85: 
01:82E6 2ACCB0          	    86: 	ld		HL,(StartAddress)		; Restore HL
                        	    87: 	
                        	    88: 	; Does destination area overlap source area?
01:82E9 ED5BCCB0        	    89: 	ld		DE,(StartAddress)
01:82ED 2ACEB0          	    90: 	ld		HL,(EndAddress)
01:82F0 B7              	    91: 	or		A						; Clear carry
01:82F1 ED52            	    92: 	sbc		HL,DE
01:82F3 B7              	    93: 	or		A						; Clear carry
01:82F4 ED42            	    94: 	sbc		HL,BC
01:82F6 2ACCB0          	    95: 	ld		HL,(StartAddress)
01:82F9 ED5BCEB0        	    96: 	ld		DE,(EndAddress)
01:82FD 300A            	    97: 	jr		nc,CopyNoOverlap
                        	    98: 	
                        	    99: 	; Destination overlaps, copy from highest address to avoid destroying data
01:82FF 09              	   100: 	add		HL,BC
01:8300 2B              	   101: 	dec		HL
01:8301 EB              	   102: 	ex		DE,HL
01:8302 09              	   103: 	add		HL,BC
01:8303 2B              	   104: 	dec		HL
01:8304 EB              	   105: 	ex		DE,HL
01:8305 EDB8            	   106: 	lddr
01:8307 180C            	   107: 	jr		CopyEnd
                        	   108: 
                        	   109: CopyNoOverlap:
01:8309 EDB0            	   110: 	ldir
01:830B 1808            	   111: 	jr		CopyEnd
                        	   112: 
                        	   113: CopyNoParameter:
01:830D CD3CB0          	   114: 	call	NoParameter
01:8310 1803            	   115: 	jr		CopyEnd
                        	   116: 
                        	   117: CopyNothing:
01:8312 CD75B0          	   118: 	call	NothingToCopy
                        	   119: 
                        	   120: CopyEnd:	
01:8315 E1              	   121: 	pop		HL
01:8316 D1              	   122: 	pop		DE
01:8317 C1              	   123: 	pop		BC
01:8318 F1              	   124: 	pop		AF
01:8319 C9              	   125: 	ret
                        	   126: 
                        	   127: 
                        	   128: ;  ____    _                                         _     _              
                        	   129: ; |  _ \  (_)   __ _    __ _   _ __     ___    ___  | |_  (_)   ___   ___ 
                        	   130: ; | | | | | |  / _` |  / _` | | '_ \   / _ \  / __| | __| | |  / __| / __|
                        	   131: ; | |_| | | | | (_| | | (_| | | | | | | (_) | \__ \ | |_  | | | (__  \__ \
                        	   132: ; |____/  |_|  \__,_|  \__, | |_| |_|  \___/  |___/  \__| |_|  \___| |___/
                        	   133: ;                      |___/                                              
                        	   134: ;
                        	   135: ;
                        	   136: ; *********************************************************************************************************************
                        	   137: ; Test system RAM, except the range of this routine
                        	   138: ; *********************************************************************************************************************
                        	   139: 
                        	   140: Diagnostics:
01:831A F5              	   141: 	push	AF
01:831B C5              	   142: 	push	BC
01:831C D5              	   143: 	push	DE
01:831D E5              	   144: 	push	HL
01:831E DDE5            	   145: 	push	IX
01:8320 FDE5            	   146: 	push	IY
                        	   147: 	
                        	   148: ; TEST BANK MEMORY
                        	   149: ; ----------------
01:8322 3E00            	   150: 	ld		A,0						; Set Bank number to 0
01:8324 FD210000        	   151: 	ld		IY,0
                        	   152: DiagnosticsBankLoop:
01:8328 2127AE          	   153: 	ld		HL,TestingBankNumberMsg
01:832B CDB080          	   154: 	call	PrintString
01:832E CDA080          	   155: 	call	PrintNibble
01:8331 CD8180          	   156: 	call	PrintCRLF
01:8334 DD210000        	   157: 	ld		IX,$0000				; Set start address
01:8338 21FF7F          	   158: 	ld		HL,$7FFF				; Set end address
01:833B D330            	   159: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:833D CD6383          	   160: 	call	DiagnosticsTest
01:8340 3C              	   161: 	inc		A
01:8341 FD6F            	   162: 	ld		IYL,A					; Save the bank number for error printing
01:8343 FE0F            	   163: 	cp		$F
01:8345 20E1            	   164: 	jr		nz,DiagnosticsBankLoop
                        	   165: 
                        	   166: ; TEST HIGH MEMORY (BETWEEN START OF BIOS AND START OF DIAG CODE)
                        	   167: ; ---------------------------------------------------------------
01:8347 213AAE          	   168: 	ld		HL,TestingHighRamMsg
01:834A CDB080          	   169: 	call	PrintString
01:834D DD210080        	   170: 	ld		IX,$8000				; Set start address
01:8351 216383          	   171: 	ld		HL,DiagnosticsTest		; Set end address
01:8354 CD6383          	   172: 	call	DiagnosticsTest
                        	   173: 
                        	   174: ; TEST HIGH MEMORY (AFTER DIAG CODE TILL THE END)
                        	   175: ; -----------------------------------------------
01:8357 DD21D183        	   176: 	ld		IX,DiagnosticsEnd		; Set start address
01:835B 21FFFF          	   177: 	ld		HL,$FFFF				; Set end address
01:835E CD6383          	   178: 	call	DiagnosticsTest
                        	   179: 
01:8361 186E            	   180: 	jr		DiagnosticsEnd
                        	   181: 
                        	   182: ; ACTUAL MEMORY TEST SUBROUTINE WITHN THE SUBROUTINE
                        	   183: ; --------------------------------------------------
                        	   184: DiagnosticsTest:	
01:8363 F5              	   185: 	push	AF
                        	   186: 	
01:8364 DD2B            	   187: 	dec		IX						; Start with one less, since the increment starts at the start of the loop
                        	   188: DiagnosticsTestLoop:
01:8366 DD23            	   189: 	inc		IX						; Increment address pointer
01:8368 DD4600          	   190: 	ld		B,(IX)					; Save the original byte in B
                        	   191: 	
                        	   192: 	; Write pattern 55
01:836B 3E55            	   193: 	ld		A,$55					; Use $55 as the first pattern value
01:836D DD7700          	   194: 	ld		(IX),A					; Write it to the memory location
01:8370 4F              	   195: 	ld		C,A						; Save expected byte for error messages
01:8371 DD7E00          	   196: 	ld		A,(IX)					; Read from same memory location
01:8374 FE55            	   197: 	cp		$55						; Compare if the it's the same
01:8376 C49783          	   198: 	call	nz,DiagMemoryError
                        	   199: 
                        	   200: 	; Write pattern AA
01:8379 3EAA            	   201: 	ld		A,$AA					; Use $55 as the first pattern value
01:837B DD7700          	   202: 	ld		(IX),A					; Write it to the memory location
01:837E 4F              	   203: 	ld		C,A						; Save expected byte for error messages
01:837F DD7E00          	   204: 	ld		A,(IX)					; Read from same memory location
01:8382 FEAA            	   205: 	cp		$AA						; Compare if the it's the same
01:8384 C49783          	   206: 	call	nz,DiagMemoryError
                        	   207: 
01:8387 DD7000          	   208: 	ld		(IX),B					; Attempt to save the original value back in it's original place
                        	   209: 	
                        	   210: 	; Check for end of range
01:838A DDE5            	   211: 	push	IX
01:838C D1              	   212: 	pop		DE
01:838D B7              	   213: 	or		A						; Clear carry flag
01:838E E5              	   214: 	push	HL
01:838F ED52            	   215: 	sbc		HL,DE					; HL = HL - DE
01:8391 E1              	   216: 	pop		HL
01:8392 C26683          	   217: 	jp		nz,DiagnosticsTestLoop	; If reached the end of range, exit
                        	   218: 
01:8395 F1              	   219: 	pop		AF
01:8396 C9              	   220: 	ret
                        	   221: 
                        	   222: ; PRINT ERROR MESSAGE IF MEMORY IS BAD
                        	   223: ; ------------------------------------
                        	   224: DiagMemoryError:
01:8397 F5              	   225: 	push	AF
01:8398 E5              	   226: 	push	HL
                        	   227: 
                        	   228: 	; Print "Error at"
01:8399 21F8AD          	   229: 	ld		HL,BadMemory1Err
01:839C CDB080          	   230: 	call	PrintString
                        	   231: 	
                        	   232: 	; Print bank number it it's in low memory
01:839F F5              	   233: 	push	AF
01:83A0 FD7D            	   234: 	ld		A,IYL
01:83A2 FE0F            	   235: 	cp		$0F
01:83A4 3008            	   236: 	jr		nc,DiagMemoryAddr
01:83A6 CDA080          	   237: 	call	PrintNibble
01:83A9 3E3A            	   238: 	ld		A,":"
01:83AB CD7680          	   239: 	call	PrintChar
                        	   240: 	
                        	   241: 	; Print address of error
                        	   242: DiagMemoryAddr
01:83AE F1              	   243: 	pop		AF
01:83AF DDE5            	   244: 	push	IX
01:83B1 E1              	   245: 	pop		HL
01:83B2 CDBE80          	   246: 	call	PrintWord
                        	   247: 	
                        	   248: 	; Print "got"
01:83B5 2102AE          	   249: 	ld		HL,BadMemory2Err
01:83B8 CDB080          	   250: 	call	PrintString
                        	   251: 	
                        	   252: 	; Print the read back data
01:83BB F5              	   253: 	push	AF
01:83BC 78              	   254: 	ld		A,B
01:83BD CD6380          	   255: 	call	PrintByte
01:83C0 F1              	   256: 	pop		AF
                        	   257: 	
                        	   258: 	; Print "expected"
01:83C1 CDB080          	   259: 	call	PrintString
                        	   260: 	
                        	   261: 	; Print the pattern that was written
01:83C4 79              	   262: 	ld		A,C
01:83C5 CD6380          	   263: 	call	PrintByte
01:83C8 CD8180          	   264: 	call	PrintCRLF
                        	   265: 	
01:83CB FD2601          	   266: 	ld		IYH,1					; Indicate an error has occured
01:83CE E1              	   267: 	pop		HL
01:83CF F1              	   268: 	pop		AF
01:83D0 C9              	   269: 	ret
                        	   270: 
                        	   271: DiagnosticsEnd:
01:83D1 3E00            	   272: 	ld		A,$0
01:83D3 D330            	   273: 	out		(BankSelect),A			; Sets bank number to 0
                        	   274: 	
01:83D5 FD7C            	   275: 	ld		A,IYH
01:83D7 FE01            	   276: 	cp		1
01:83D9 2806            	   277: 	jr		z,DiagnosticsEnd2		; If memory test failed, exit, as there was warning errors
01:83DB 214DAE          	   278: 	ld		HL,MemoryTestPassedMsg	; Else print test passed
01:83DE CDB080          	   279: 	call	PrintString
                        	   280: 
                        	   281: DiagnosticsEnd2:
01:83E1 FDE1            	   282: 	pop		IY
01:83E3 DDE1            	   283: 	pop		IX
01:83E5 E1              	   284: 	pop		HL
01:83E6 D1              	   285: 	pop		DE
01:83E7 C1              	   286: 	pop		BC
01:83E8 F1              	   287: 	pop		AF
01:83E9 C9              	   288: 	ret
                        	   289: 
                        	   290: 
                        	   291: ;  _____   _   _   _   __  __                                           
                        	   292: ; |  ___| (_) | | | | |  \/  |   ___   _ __ ___     ___    _ __   _   _ 
                        	   293: ; | |_    | | | | | | | |\/| |  / _ \ | '_ ` _ \   / _ \  | '__| | | | |
                        	   294: ; |  _|   | | | | | | | |  | | |  __/ | | | | | | | (_) | | |    | |_| |
                        	   295: ; |_|     |_| |_| |_| |_|  |_|  \___| |_| |_| |_|  \___/  |_|     \__, |
                        	   296: ;                                                                 |___/ 
                        	   297: 
                        	   298: ; *********************************************************************************************************************
                        	   299: ; Fill a memory address range with a byte. Does not fill all banks, only the current one. It will exclude
                        	   300: ; shadow ROM (otherwise it will corrupt the BIOS), as well as vector pages.
                        	   301: ;		- Parameter 1 = Start address
                        	   302: ;		- Parameter 2 = End address
                        	   303: ;		- Parameter 3 = The byte to write
                        	   304: ; *********************************************************************************************************************
                        	   305: ; 	Wishlist:
                        	   306: ;		- Verify after write
                        	   307: ;		- Add: Filled xxxx bytes in decimal
                        	   308: 
                        	   309: FillMemory:
01:83EA F5              	   310: 	push	AF
01:83EB C5              	   311: 	push	BC
01:83EC D5              	   312: 	push	DE
01:83ED E5              	   313: 	push	HL
                        	   314: 	
01:83EE 2AACB0          	   315: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   316: 	
                        	   317: ; GET ALL THE PARAMETERS AND STORE THEM IN MEMORY
                        	   318: FillStartAddr:
01:83F1 CDCD88          	   319: 	call	GetHexParameter			; Get the first parameter, start address
01:83F4 D28484          	   320: 	jp		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:83F7 FE00            	   321: 	cp		0						; Is there a first parameter?
01:83F9 287D            	   322: 	jr		z,FillNoParameter		; No, then print error message
01:83FB FE0F            	   323: 	cp		HELP
01:83FD 287F            	   324: 	jr		z,FillPrintHelp
01:83FF ED43CCB0        	   325: 	ld		(StartAddress),BC		; Store start address
01:8403 ED43D0B0        	   326: 	ld		(StartAddressAlt),BC	; Store start address
                        	   327: 	
                        	   328: FillEndAddr:
01:8407 CDCD88          	   329: 	call	GetHexParameter			; Get the second parameter, end address
01:840A 3078            	   330: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:840C FE00            	   331: 	cp		0						; Is there a second parameter?
01:840E 2868            	   332: 	jr		z,FillNoParameter		; No, then print error message
01:8410 ED43CEB0        	   333: 	ld		(EndAddress),BC			; Store end address
                        	   334: 
                        	   335: FillByte:
01:8414 CDCD88          	   336: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8417 306B            	   337: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:8419 FE00            	   338: 	cp		0						; Is there a third parameter?
01:841B 285B            	   339: 	jr		z,FillNoParameter		; No, then print error message
01:841D 79              	   340: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:841E 32D4B0          	   341: 	ld		(ByteTransfer),A		; Store the byte to write
                        	   342: 	
01:8421 CDD889          	   343: 	call	RangeValidation			; Check if Fill can write to a valid range of RAM space (excluse BIOS and Vectors)
01:8424 385E            	   344: 	jr		c,FillMemoryEnd
                        	   345: 	
                        	   346: FillRange1:
                        	   347: 	; Detect amout of bytes to copy in high range
01:8426 C5              	   348: 	push	BC
01:8427 CB49            	   349: 	bit		1,C
01:8429 2823            	   350: 	jr		z,FillRange2
01:842B 2AD2B0          	   351: 	ld		HL,(EndAddressAlt)		; Load end address
01:842E ED5BD0B0        	   352: 	ld		DE,(StartAddressAlt)	; Load start
01:8432 B7              	   353: 	or		A						; Clear carry flag
01:8433 ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:8435 E5              	   355: 	push	HL						; Put result of byte count
01:8436 C1              	   356: 	pop		BC						; Into the byte count register
01:8437 2AD0B0          	   357: 	ld		HL,(StartAddressAlt)	; Set source address
01:843A 3AD4B0          	   358: 	ld		A,(ByteTransfer)		; Grab byte to write
01:843D 77              	   359: 	ld		(HL),A					; Save it at the source address
01:843E ED5BD0B0        	   360: 	ld		DE,(StartAddressAlt)	; Place destination address
01:8442 13              	   361: 	inc		DE						; Destination address +1
01:8443 EDB0            	   362: 	ldir
01:8445 ED4BD0B0        	   363: 	ld		BC,(StartAddressAlt)	; Set CurrentAddress to start of available RAM
01:8449 ED43B0B0        	   364: 	ld		(CurrentAddress),BC
01:844D 37              	   365: 	scf								; Set carry
                        	   366: 
                        	   367: FillRange2:
                        	   368: 	; Detect amout of bytes to copy in low range
01:844E C1              	   369: 	pop		BC
01:844F CB41            	   370: 	bit		0,C
01:8451 2831            	   371: 	jr		z,FillMemoryEnd
01:8453 2ACEB0          	   372: 	ld		HL,(EndAddress)			; Load end address
01:8456 ED5BCCB0        	   373: 	ld		DE,(StartAddress)		; Load start
01:845A B7              	   374: 	or		A						; Clear carry flag
01:845B ED52            	   375: 	sbc		HL,DE					; HL = HL - DE
01:845D E5              	   376: 	push	HL						; Put result of byte count
01:845E C1              	   377: 	pop		BC						; Into the byte count register
01:845F 2ACCB0          	   378: 	ld		HL,(StartAddress)		; Set source address
01:8462 3AD4B0          	   379: 	ld		A,(ByteTransfer)		; Grab byte to write
01:8465 77              	   380: 	ld		(HL),A					; Save it at the source address
01:8466 ED5BCCB0        	   381: 	ld		DE,(StartAddress)		; Place destination address
01:846A 13              	   382: 	inc		DE						; Destination address +1
01:846B EDB0            	   383: 	ldir
01:846D ED4BCCB0        	   384: 	ld		BC,(StartAddress)		; Set CurrentAddress to start of available RAM
01:8471 ED43B0B0        	   385: 	ld		(CurrentAddress),BC
01:8475 37              	   386: 	scf								; Set Carry, indicates no error to calling program
01:8476 180C            	   387: 	jr		FillMemoryEnd
                        	   388: 
                        	   389: FillNoParameter:
01:8478 CD3CB0          	   390: 	call	NoParameter
01:847B B7              	   391: 	or		A						; Clear Carry, indicates error to calling program
01:847C 1806            	   392: 	jr		FillMemoryEnd
                        	   393: 
                        	   394: FillPrintHelp:
01:847E 21FCAE          	   395: 	ld		HL,FillHelp
01:8481 CDB080          	   396: 	call	PrintString
                        	   397: 
                        	   398: FillMemoryEnd:
01:8484 E1              	   399: 	pop		HL
01:8485 D1              	   400: 	pop		DE
01:8486 C1              	   401: 	pop		BC
01:8487 F1              	   402: 	pop		AF
01:8488 C9              	   403: 	ret
                        	   404: 
                        	   405: 
                        	   406: ;  _   _                 ____                              
                        	   407: ; | | | |   ___  __  __ |  _ \   _   _   _ __ ___    _ __  
                        	   408: ; | |_| |  / _ \ \ \/ / | | | | | | | | | '_ ` _ \  | '_ \ 
                        	   409: ; |  _  | |  __/  >  <  | |_| | | |_| | | | | | | | | |_) |
                        	   410: ; |_| |_|  \___| /_/\_\ |____/   \__,_| |_| |_| |_| | .__/ 
                        	   411: ;                                                   |_|    
                        	   412: ;
                        	   413: ; *********************************************************************************************************************
                        	   414: ; Prints the content of memory to serial port A
                        	   415: ; Parameters:	[AAAA], [LL] (where AAAA is the address to start displaying, and LL is the number of lines to display)
                        	   416: ; *********************************************************************************************************************
                        	   417: ;
                        	   418: ; Registers and variables used:
                        	   419: ;	- B is the number of bytes/characters per line
                        	   420: ;	- C is the line counter per page
                        	   421: ;	- DE is the number of lines to print
                        	   422: ;	- HL is the address to display
                        	   423: 
                        	   424: ; Wish list:
                        	   425: ;	- End at $FFFF
                        	   426: ;	- When more then a page long, pause every page and wait for ENTER to continues, or ESC to quit
                        	   427: 
                        	   428: HexDump:
01:8489 F5              	   429: 	push	AF
01:848A C5              	   430: 	push	BC
01:848B D5              	   431: 	push	DE
01:848C E5              	   432: 	push	HL
                        	   433: 	
01:848D 2AACB0          	   434: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:8490 CDCD88          	   435: 	call	GetHexParameter			; Get the first parameter: the address to display
01:8493 306B            	   436: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:8495 FE0F            	   437: 	cp		HELP
01:8497 2861            	   438: 	jr		z,HexDumpPrintHelp
01:8499 FE00            	   439: 	cp		0						; Is there a parameter?
01:849B 2004            	   440: 	jr		nz,HexLinesToRead		; If There's a parameter, go check second parameter
01:849D ED4BB0B0        	   441: 	ld		BC,(CurrentAddress)		; Since it's no parameter, then place CurrentAddress as default address
                        	   442: 
                        	   443: HexLinesToRead:
01:84A1 C5              	   444: 	push	BC						; Save the first parameter's address...
01:84A2 D1              	   445: 	pop		DE						;    to be later recovered as HL
01:84A3 CDCD88          	   446: 	call	GetHexParameter			; Get the secode parameter: the number of lines to display
01:84A6 3058            	   447: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:84A8 FE00            	   448: 	cp		0						; Is there a parameter?
01:84AA 2808            	   449: 	jr		z,HexDefaultLines		; There is no parameter, so go load the default line number
01:84AC FE01            	   450: 	cp		1						; Is it a one byte parameter
01:84AE 2806            	   451: 	jr		z,HexDisplayContent		; If it is, C already contains the number of lines, so start printing content
01:84B0 0EFF            	   452: 	ld		C,$FF					; Else, if it's a 2 byte or more parameter, set maximum lines to $FF
01:84B2 1802            	   453: 	jr		HexDisplayContent		; Start printing hex dump
                        	   454: HexDefaultLines:
01:84B4 0E15            	   455: 	ld		C,VertTextRes-3			; Get number of vertical lines
                        	   456: 
                        	   457: HexDisplayContent:
01:84B6 EB              	   458: 	ex		DE,HL					; Restore address from first parameter read
                        	   459: 	
                        	   460: ; PRINT ADDRESS AT BEGINNING
                        	   461: HexNextLine:
01:84B7 E5              	   462: 	push	HL						; Save HL for later use (character portion of memory dump)
01:84B8 CDBE80          	   463: 	call	PrintWord				; Print address
01:84BB 0608            	   464: 	ld		B,8						; Setup byte counter per line
01:84BD 3E3A            	   465: 	ld		A,":"
01:84BF CD7680          	   466: 	call	PrintChar				; Print colon
01:84C2 3E20            	   467: 	ld		A," "
01:84C4 CD7680          	   468: 	call	PrintChar				; Print space
                        	   469: 
                        	   470: ; PRINT EIGHT BYTES
                        	   471: HexNextByte:
01:84C7 7E              	   472: 	ld		A,(HL)
01:84C8 CD6380          	   473: 	call	PrintByte				; Print byte contained in address HL
01:84CB 3E20            	   474: 	ld		A," "
01:84CD CD7680          	   475: 	call	PrintChar				; Print space
01:84D0 23              	   476: 	inc		HL						; Increment HL for next byte
01:84D1 05              	   477: 	dec		B						; Decrement byte counter
01:84D2 20F3            	   478: 	jr		nz,HexNextByte			; If the 8 bytes have not all been printed, then loop again
                        	   479: 
                        	   480: ; PRINT EIGHT CHARACTERS
01:84D4 CD7680          	   481: 	call	PrintChar				; Print an extra space (to space out bytes from character printout)
01:84D7 0608            	   482: 	ld		B,8						; Reset the counter to count characters instead
01:84D9 E1              	   483: 	pop		HL						; Reset HL so we can print the characters instead of the bytes at the end of the line
                        	   484: HexNextChar:
01:84DA 7E              	   485: 	ld		A,(HL)
01:84DB FE20            	   486: 	cp		$20						; Compare A with first displayable character
01:84DD 3806            	   487: 	jr		c,HexReplaceDot			; If it's lower, then replace with a period
01:84DF FE7F            	   488: 	cp		$7F						; Is it higher or equal to the DEL character?
01:84E1 3002            	   489: 	jr		nc,HexReplaceDot		; Then replace that with a period
01:84E3 1802            	   490: 	jr		HexPrintChar
                        	   491: HexReplaceDot:
01:84E5 3E2E            	   492: 	ld		A,"."					; No, then replace it with a period
                        	   493: HexPrintChar:
01:84E7 CD7680          	   494: 	call	PrintChar				; Print the character representation of the byte
01:84EA 23              	   495: 	inc		HL						; Increment HL for next character
01:84EB 05              	   496: 	dec		B						; Decrement character counter
01:84EC 20EC            	   497: 	jr		nz,HexNextChar			; If the 8 characters have not all been printed, then loop again
01:84EE CD8180          	   498: 	call	PrintCRLF				; Change line
01:84F1 0D              	   499: 	dec		C						; 
01:84F2 C2B784          	   500: 	jp		nz,HexNextLine
01:84F5 22B0B0          	   501: 	ld		(CurrentAddress),HL		; Save Current Address to where Hex left off
01:84F8 1806            	   502: 	jr		HexDumpEnd
                        	   503: 	
                        	   504: HexDumpPrintHelp:
01:84FA 2167AF          	   505: 	ld		HL,HexDumpHelp
01:84FD CDB080          	   506: 	call	PrintString
                        	   507: 	
                        	   508: HexDumpEnd:
01:8500 E1              	   509: 	pop		HL
01:8501 D1              	   510: 	pop		DE
01:8502 C1              	   511: 	pop		BC
01:8503 F1              	   512: 	pop		AF
01:8504 C9              	   513: 	ret
                        	   514: 
                        	   515: 
                        	   516: ;  ___           _            _   _   _               
                        	   517: ; |_ _|  _ __   | |_    ___  | | | | | |   ___  __  __
                        	   518: ;  | |  | '_ \  | __|  / _ \ | | | |_| |  / _ \ \ \/ /
                        	   519: ;  | |  | | | | | |_  |  __/ | | |  _  | |  __/  >  < 
                        	   520: ; |___| |_| |_|  \__|  \___| |_| |_| |_|  \___| /_/\_\
                        	   521: ;
                        	   522: 
                        	   523: ; *********************************************************************************************************************
                        	   524: ; Transfer programs via Intel Hex (i8HEX) - Press ESC to exit
                        	   525: ; - Input:	Upload an i8Hex file from a terminal program on your computer (Transfer File)
                        	   526: ; - Output:	Sets (CurrentAddress) variable to the start address declared in the IntelHex file
                        	   527: 
                        	   528: ; File Format:	SBBAAAARRDDDDDDCC termintated by (CR) and/or (LF)
                        	   529: ;				:0300300002337A1E
                        	   530: ;					S = : is the start code
                        	   531: ;					BB = it the data byte count ($20 is the typical)
                        	   532: ;					AAAA = The 16-bit beginning memory address offset of the data
                        	   533: ;					RR = Record type, 00 = Data, 01 = End of File
                        	   534: ;					DD = Data
                        	   535: ;					CC = Checksum from BB to the last DD (Two's complement)
                        	   536: ; *********************************************************************************************************************
                        	   537: ;	- B = Byte couter
                        	   538: ;	- C = Checksum
                        	   539: ;	- D = Flags (Start address, Checksum error, Last record)
                        	   540: ;	- HL = Address offset pointer
                        	   541: 
                        	   542: StartAddr	= 0						; Start address flag bit
                        	   543: ChecksumErr	= 1						; Checksum error flag bit
                        	   544: LastRec		= 7						; Last record flag bit
                        	   545: 
                        	   546: IntelHex:
01:8505 F5              	   547: 	push	AF
01:8506 C5              	   548: 	push	BC
01:8507 D5              	   549: 	push	DE
01:8508 E5              	   550: 	push	HL
01:8509 DDE5            	   551: 	push	IX
                        	   552: 	
01:850B CD3B8B          	   553: 	call	SkipSpaces
01:850E 7E              	   554: 	ld		A,(HL)					; Read a character form the CommandBuffer	
01:850F FE0F            	   555: 	cp		HELP
01:8511 CAC885          	   556: 	jp		z,IntelHexPrintHelp
                        	   557: 
01:8514 2190AE          	   558: 	ld		HL,IntelHexLoadMsg		; Print load message, or ESC to exit
01:8517 CDB080          	   559: 	call	PrintString				;
01:851A 1600            	   560: 	ld		D,0						; Clear the flags register
01:851C DD210000        	   561: 	ld		IX,0					; Clear byte counter
01:8520 DD22D5B0        	   562: 	ld		(UserCodeSize),IX		; Clear user code byte counter
                        	   563: 	
                        	   564: ; *** START CODE
                        	   565: IntelHexStartCode:
01:8524 CDC980          	   566: 	call	ReadChar				; Read a character form the console
01:8527 FE1B            	   567: 	cp		ESC						; Did the user press ESCAPE?
01:8529 CAAA85          	   568: 	jp		z,IntelHexAbort			; Yes, then exit
01:852C FE3A            	   569: 	cp		":"						; Is it the start code
01:852E 2802            	   570: 	jr		z,IntelHexByteCount		; Yes, then read byte count
01:8530 18F2            	   571: 	jr		IntelHexStartCode		; No, then read a new character until ":" is present
                        	   572: 	
                        	   573: ; *** BYTE COUNT
                        	   574: IntelHexByteCount:
01:8532 CDDD80          	   575: 	call	ReadByte				; Read the byte count
01:8535 47              	   576: 	ld		B,A						; Store byte counter in B
01:8536 4F              	   577: 	ld		C,A						; copy value of accumulator in checksum register
                        	   578: 
                        	   579: ; *** ADDRESS
                        	   580: IntelHexAddress:
01:8537 CDDD80          	   581: 	call	ReadByte				; Read the MSB characters and convert it to a byte
01:853A 67              	   582: 	ld		H,A						; Store the address's MSB
01:853B 81              	   583: 	add		C						; Add checksum
01:853C 4F              	   584: 	ld		C,A						; Store back result in checksum accumulator
01:853D CDDD80          	   585: 	call	ReadByte				; Read the LSB characters and convert it to a byte
01:8540 6F              	   586: 	ld		L,A						; Store the address's LSB
01:8541 81              	   587: 	add		C						; Add checksum
01:8542 4F              	   588: 	ld		C,A						; Store back result in checksum accumulator
01:8543 CB42            	   589: 	bit		StartAddr,D				; Check if it's the first time the address has been read...
01:8545 2005            	   590: 	jr		nz,IntelHexRecordType	;	If it's not the first line, then go get record type
01:8547 22B0B0          	   591: 	ld		(CurrentAddress),HL		; Else store the starting address
01:854A CBC2            	   592: 	set		StartAddr,D				; Set first line start address flag
                        	   593: ;	ld		E,1						; Set first pass flag
                        	   594: 
                        	   595: ; *** RECORD TYPE
                        	   596: IntelHexRecordType:
01:854C CDDD80          	   597: 	call	ReadByte				; Read the record type byte
01:854F F5              	   598: 	push	AF
01:8550 81              	   599: 	add		C						; Add checksum
01:8551 4F              	   600: 	ld		C,A						; Store back result in checksum accumulator
01:8552 F1              	   601: 	pop		AF
01:8553 FE00            	   602: 	cp		00						; Is it data?
01:8555 2808            	   603: 	jr		z,IntelHexData
01:8557 FE01            	   604: 	cp		01						; Is it the end of file record type
01:8559 2057            	   605: 	jr		nz,IntelHexUnsupported		
01:855B CBFA            	   606: 	set		LastRec,D	
01:855D 180B            	   607: 	jr		IntelHexChecksum		; Get checksum
                        	   608: 
                        	   609: ; *** DATA
                        	   610: IntelHexData:
01:855F CDDD80          	   611: 	call	ReadByte				; Get data byte
01:8562 77              	   612: 	ld		(HL),A					; Store data byte in memory
01:8563 23              	   613: 	inc		HL						; Point to the next address
01:8564 DD23            	   614: 	inc		IX						; Count the total number of bytes
01:8566 81              	   615: 	add		C						; Add checksum
01:8567 4F              	   616: 	ld		C,A						; Store back result in checksum accumulator
01:8568 10F5            	   617: 	djnz	IntelHexData			; Decrement count, and go to next data if not finished
                        	   618: 
                        	   619: ; *** CHECKSUM
                        	   620: IntelHexChecksum:
01:856A CDDD80          	   621: 	call	ReadByte				; Read the checksum for that record
01:856D ED44            	   622: 	neg								; Do a 2s compliment on A (saves instructions if I swapped C with A)
01:856F B9              	   623: 	cp		C						; Compare the transmited checksum with the calculated checksum
01:8570 2806            	   624: 	jr		z,IntelHexCheckOk		; Is it the same?
01:8572 3E78            	   625: 	ld		A,"x"					; Display an "x" if checksum do not match
01:8574 CBCA            	   626: 	set		ChecksumErr,D			; Indicate an error in checksum flag
01:8576 1802            	   627: 	jr		IntelHexPrintStatus		;
                        	   628: IntelHexCheckOk:
01:8578 3E2E            	   629: 	ld		A,"."					; Display a "." if checksum is a match
                        	   630: IntelHexPrintStatus:
01:857A CD7680          	   631: 	call	PrintChar				; Print the checksum validity character
01:857D CB7A            	   632: 	bit		LastRec,D				; Check if it's the last record
01:857F CA2485          	   633: 	jp		z,IntelHexStartCode		; No, then continue reading more lines
01:8582 CDC980          	   634: 	call	ReadChar				; Flush CR
                        	   635: 
                        	   636: IntelHexPrintEndMsg:
01:8585 CD8180          	   637: 	call	PrintCRLF
01:8588 2171AE          	   638: 	ld		HL,IntelHexFinishedMsg	; Print the end message
01:858B CDB080          	   639: 	call	PrintString
01:858E 2181AE          	   640: 	ld		HL,IntelHexSuccessMsg	; Point to "unsuccessful"
01:8591 CB4A            	   641: 	bit		ChecksumErr,D			; Cneck if there was an error that was flagged
01:8593 2002            	   642: 	jr		nz,IntelHexPrintNotOk	; If the ChecksumErr flag was set, then print unsuccessful
01:8595 23              	   643: 	inc		HL						; Push pointer to letters..
01:8596 23              	   644: 	inc		HL						;   so it becomes "successful"
                        	   645: IntelHexPrintNotOk:
01:8597 CDB080          	   646: 	call	PrintString				; Print the sucess level
01:859A E5              	   647: 	push	HL
01:859B DDE5            	   648: 	push	IX						; Copy byte counter
01:859D E1              	   649: 	pop		HL						; To HL to be printed
01:859E CD5A80          	   650: 	call	PrintDec				; Print the decimal number
01:85A1 21E8AE          	   651: 	ld		HL,DownloadedBytesMsg	; 
01:85A4 CDB080          	   652: 	call	PrintString				; Print bytes loaded text
01:85A7 E1              	   653: 	pop		HL
01:85A8 1824            	   654: 	jr		IntelHexEnd				; And end load
                        	   655: 
                        	   656: IntelHexAbort:
01:85AA 21CDAE          	   657: 	ld		HL,IntelHexAbortedMsg	; Abort message
01:85AD CDB080          	   658: 	call	PrintString				;
01:85B0 181C            	   659: 	jr		IntelHexEnd
                        	   660: 
                        	   661: IntelHexUnsupported:
01:85B2 213EAD          	   662: 	ld		HL,IntelHexUnsupportedErr	; Unsupported record type message
01:85B5 CDB080          	   663: 	call	PrintString				;
01:85B8 CD6380          	   664: 	call	PrintByte				; Print the record number
01:85BB CD8180          	   665: 	call	PrintCRLF
01:85BE 180E            	   666: 	jr		IntelHexEnd
                        	   667: 
                        	   668: IntelHexParamError:
01:85C0 2104AD          	   669: 	ld		HL,UnrecognizedParamErr
01:85C3 CDB080          	   670: 	call	PrintString
01:85C6 1806            	   671: 	jr		IntelHexEnd
                        	   672: 
                        	   673: IntelHexPrintHelp:
01:85C8 21CCAF          	   674: 	ld		HL,IntelHexHelp
01:85CB CDB080          	   675: 	call	PrintString
                        	   676: 	
                        	   677: IntelHexEnd:
01:85CE DDE1            	   678: 	pop		IX
01:85D0 E1              	   679: 	pop		HL
01:85D1 D1              	   680: 	pop		DE
01:85D2 C1              	   681: 	pop		BC
01:85D3 F1              	   682: 	pop		AF
01:85D4 C9              	   683: 	ret
                        	   684: 
                        	   685: 
                        	   686: ;  _       _         _   
                        	   687: ; | |     (_)  ___  | |_ 
                        	   688: ; | |     | | / __| | __|
                        	   689: ; | |___  | | \__ \ | |_ 
                        	   690: ; |_____| |_| |___/  \__|
                        	   691: 
                        	   692: 
                        	   693: ; *********************************************************************************************************************
                        	   694: ; Prints a list of available commands
                        	   695: ; *********************************************************************************************************************
                        	   696: 
                        	   697: ListCmd:
01:85D5 E5              	   698: 	push	HL
01:85D6 2136A9          	   699: 	ld		HL,ListOfCommands
01:85D9 CDB080          	   700: 	call	PrintString				; Print first line
01:85DC CD8E80          	   701: 	call	PrintLine				; Print a line
01:85DF CDB080          	   702: 	call	PrintString				; Print the rest
01:85E2 E1              	   703: 	pop		HL
01:85E3 C9              	   704: 	ret
                        	   705: 
                        	   706: 
                        	   707: ;  ____                  _    
                        	   708: ; |  _ \    ___    ___  | | __
                        	   709: ; | |_) |  / _ \  / _ \ | |/ /
                        	   710: ; |  __/  |  __/ |  __/ |   < 
                        	   711: ; |_|      \___|  \___| |_|\_\
                        	   712: 
                        	   713: 
                        	   714: ; *********************************************************************************************************************
                        	   715: ; Read a byte of a I/O port
                        	   716: ; *********************************************************************************************************************
                        	   717: ; To be done: Error messages
                        	   718: 
                        	   719: PeekCmd:
01:85E4 F5              	   720: 	push	AF
01:85E5 C5              	   721: 	push	BC
01:85E6 E5              	   722: 	push	HL
                        	   723: 	
01:85E7 2AACB0          	   724: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   725: 	
                        	   726: PeekAddress:
01:85EA CDCD88          	   727: 	call	GetHexParameter			; Get the IO port number parameter
01:85ED D20E86          	   728: 	jp		nc,PeekError			; Exit routine if there was an error in the parameter
01:85F0 FE00            	   729: 	cp		0						; Is there a parameter?
01:85F2 2814            	   730: 	jr		z,PeekNoParameter		; No, then print a no parameter message
                        	   731: 
                        	   732: PeekRead:
01:85F4 79              	   733: 	ld		A,C						; Put port number from command line parameter in accumulator
01:85F5 CD6380          	   734: 	call	PrintByte				; Print the port number
01:85F8 3E3A            	   735: 	ld		A,":"
01:85FA CD7680          	   736: 	call	PrintChar
01:85FD ED78            	   737: 	in		A,(C)					; Read a byte from the specified port number
01:85FF CD6380          	   738: 	call	PrintByte				; Print the read byte
01:8602 CD8180          	   739: 	call	PrintCRLF				; Change line
01:8605 C30E86          	   740: 	jp		PeekEnd					;
                        	   741: 
                        	   742: PeekNoParameter:
01:8608 CD3CB0          	   743: 	call	NoParameter
01:860B C30E86          	   744: 	jp		PeekEnd
                        	   745: 	
                        	   746: PeekError:
                        	   747: 
                        	   748: PeekEnd:
01:860E E1              	   749: 	pop		HL
01:860F C1              	   750: 	pop		BC
01:8610 F1              	   751: 	pop		AF
01:8611 C9              	   752: 	ret
                        	   753: 
                        	   754: 
                        	   755: ;  ____            _           
                        	   756: ; |  _ \    ___   | | __   ___ 
                        	   757: ; | |_) |  / _ \  | |/ /  / _ \
                        	   758: ; |  __/  | (_) | |   <  |  __/
                        	   759: ; |_|      \___/  |_|\_\  \___|
                        	   760: 
                        	   761: 
                        	   762: ; *********************************************************************************************************************
                        	   763: ; Write a byte to a specific I/O port
                        	   764: ;	- Input:	Parameters: Port number & Byte
                        	   765: ; *********************************************************************************************************************
                        	   766: ; To be done: Error message
                        	   767: 
                        	   768: PokeCmd:
01:8612 F5              	   769: 	push 	AF
01:8613 C5              	   770: 	push	BC
01:8614 E5              	   771: 	push	HL
                        	   772: 	
01:8615 2AACB0          	   773: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   774: 	
                        	   775: PokeGetPort:
01:8618 CDCD88          	   776: 	call	GetHexParameter			; Get the first parameter, port number (byte in C)
01:861B D24E86          	   777: 	jp		nc,PokeError			; Exit routine if there was an error in the parameter
01:861E FE00            	   778: 	cp		0						; Is there a first parameter?
01:8620 2826            	   779: 	jr		z,PokeNoParameter		; No, then print error message
01:8622 79              	   780: 	ld		A,C
01:8623 32B2B0          	   781: 	ld		(CurrentPort),A			; Store port number for later use (cheaper than push-pop)
                        	   782: 	
                        	   783: PokeGetByte:
01:8626 CDCD88          	   784: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8629 3023            	   785: 	jr		nc,PokeError			; Exit routine if there was an error in the parameter
01:862B FE00            	   786: 	cp		0						; Is there a third parameter?
01:862D 2819            	   787: 	jr		z,PokeNoParameter		; No, then print error message
01:862F 79              	   788: 	ld		A,C						; Save byte for later use
01:8630 47              	   789: 	ld		B,A						; ... and put it in B
                        	   790: 
                        	   791: PokeWrite:
01:8631 3AB2B0          	   792: 	ld		A,(CurrentPort)			; Read back the stored port number
01:8634 4F              	   793: 	ld		C,A						; Copy it in C for later use
01:8635 CD6380          	   794: 	call	PrintByte				; Print it
01:8638 3E3A            	   795: 	ld		A,":"
01:863A CD7680          	   796: 	call	PrintChar
01:863D ED41            	   797: 	out		(C),B					; Write byte in B, to port address in C
01:863F 78              	   798: 	ld		A,B						; Place the byte to print in the accumulator
01:8640 CD6380          	   799: 	call	PrintByte
01:8643 CD8180          	   800: 	call	PrintCRLF
01:8646 1806            	   801: 	jr		PokeEnd
                        	   802: 
                        	   803: PokeNoParameter:
01:8648 CD3CB0          	   804: 	call	NoParameter
01:864B C34E86          	   805: 	jp		PokeEnd
                        	   806: 
                        	   807: PokeError:
                        	   808: 	
                        	   809: PokeEnd
01:864E E1              	   810: 	pop		HL
01:864F C1              	   811: 	pop		BC
01:8650 F1              	   812: 	pop		AF
01:8651 C9              	   813: 	ret
                        	   814: 
                        	   815: 
                        	   816: ;  ____                   _         _                       
                        	   817: ; |  _ \    ___    __ _  (_)  ___  | |_    ___   _ __   ___ 
                        	   818: ; | |_) |  / _ \  / _` | | | / __| | __|  / _ \ | '__| / __|
                        	   819: ; |  _ <  |  __/ | (_| | | | \__ \ | |_  |  __/ | |    \__ \
                        	   820: ; |_| \_\  \___|  \__, | |_| |___/  \__|  \___| |_|    |___/
                        	   821: ;                 |___/                                     
                        	   822: 
                        	   823: ; *********************************************************************************************************************
                        	   824: ; Prints the contents of the registers on the console
                        	   825: ; *********************************************************************************************************************
                        	   826: ;
                        	   827: ; Wish list:
                        	   828: ;	- Modify individual registers
                        	   829: 
                        	   830: Registers:
01:8652 ED73C9B0        	   831: 	ld		(StackPtr),SP			; Save the stack pointer
01:8656 F5              	   832: 	push	AF
01:8657 C5              	   833: 	push	BC
01:8658 D5              	   834: 	push	DE
01:8659 E5              	   835: 	push	HL
01:865A DDE5            	   836: 	push	IX
01:865C FDE5            	   837: 	push	IY
                        	   838: 	
01:865E F5              	   839: 	push	AF						; Save the flags (to be restored in C later)
01:865F 32BEB0          	   840: 	ld		(RegA),A				; Save A
01:8662 ED43BFB0        	   841: 	ld		(RegBC),BC				; Save BC
01:8666 ED53C1B0        	   842: 	ld		(RegDE),DE				; Save DE
01:866A 22C3B0          	   843: 	ld		(RegHL),HL				; Save HL
01:866D DD22C5B0        	   844: 	ld		(RegIX),IX				; Save IX
01:8671 FD22C7B0        	   845: 	ld		(RegIY),IY				; Save IY
01:8675 C1              	   846: 	pop		BC						; Restore AF in BC to get the flags
01:8676 79              	   847: 	ld		A,C
01:8677 32CBB0          	   848: 	ld		(FlagsReg),A			; Save the flags register
                        	   849: 	
                        	   850: 	; PRINT THE ACCUMULATOR
01:867A 3E41            	   851: 	ld		A,"A"
01:867C CD7680          	   852: 	call	PrintChar
01:867F 3E3A            	   853: 	ld		A,":"
01:8681 CD7680          	   854: 	call	PrintChar
01:8684 3ABEB0          	   855: 	ld		A,(RegA)
01:8687 CD6380          	   856: 	call	PrintByte
01:868A 3E20            	   857: 	ld		A," "
01:868C CD7680          	   858: 	call	PrintChar
                        	   859: 
                        	   860: 	; PRINT BC REGISTER PAIR
01:868F 3E42            	   861: 	ld		A,"B"
01:8691 CD7680          	   862: 	call	PrintChar
01:8694 3E43            	   863: 	ld		A,"C"
01:8696 CD7680          	   864: 	call	PrintChar
01:8699 3E3A            	   865: 	ld		A,":"
01:869B CD7680          	   866: 	call	PrintChar
01:869E 2ABFB0          	   867: 	ld		HL,(RegBC)
01:86A1 CDBE80          	   868: 	call	PrintWord
01:86A4 3E20            	   869: 	ld		A," "
01:86A6 CD7680          	   870: 	call	PrintChar
                        	   871: 
                        	   872: 	; PRINT DE REGISTER PAIR
01:86A9 3E44            	   873: 	ld		A,"D"
01:86AB CD7680          	   874: 	call	PrintChar
01:86AE 3E45            	   875: 	ld		A,"E"
01:86B0 CD7680          	   876: 	call	PrintChar
01:86B3 3E3A            	   877: 	ld		A,":"
01:86B5 CD7680          	   878: 	call	PrintChar
01:86B8 2AC1B0          	   879: 	ld		HL,(RegDE)
01:86BB CDBE80          	   880: 	call	PrintWord
01:86BE 3E20            	   881: 	ld		A," "
01:86C0 CD7680          	   882: 	call	PrintChar
                        	   883: 
                        	   884: 	; PRINT HL REGISTER PAIR
01:86C3 3E48            	   885: 	ld		A,"H"
01:86C5 CD7680          	   886: 	call	PrintChar
01:86C8 3E4C            	   887: 	ld		A,"L"
01:86CA CD7680          	   888: 	call	PrintChar
01:86CD 3E3A            	   889: 	ld		A,":"
01:86CF CD7680          	   890: 	call	PrintChar
01:86D2 2AC3B0          	   891: 	ld		HL,(RegHL)
01:86D5 CDBE80          	   892: 	call	PrintWord
01:86D8 CD8180          	   893: 	call	PrintCRLF
                        	   894: 
                        	   895: 	; PRINT IX INDEX REGISTER
01:86DB 3E49            	   896: 	ld		A,"I"
01:86DD CD7680          	   897: 	call	PrintChar
01:86E0 3E58            	   898: 	ld		A,"X"
01:86E2 CD7680          	   899: 	call	PrintChar
01:86E5 3E3A            	   900: 	ld		A,":"
01:86E7 CD7680          	   901: 	call	PrintChar
01:86EA 2AC5B0          	   902: 	ld		HL,(RegIX)
01:86ED CDBE80          	   903: 	call	PrintWord
01:86F0 3E20            	   904: 	ld		A," "
01:86F2 CD7680          	   905: 	call	PrintChar
                        	   906: 
                        	   907: 	; PRINT IY INDEX REGISTER
01:86F5 3E49            	   908: 	ld		A,"I"
01:86F7 CD7680          	   909: 	call	PrintChar
01:86FA 3E59            	   910: 	ld		A,"Y"
01:86FC CD7680          	   911: 	call	PrintChar
01:86FF 3E3A            	   912: 	ld		A,":"
01:8701 CD7680          	   913: 	call	PrintChar
01:8704 2AC7B0          	   914: 	ld		HL,(RegIY)
01:8707 CDBE80          	   915: 	call	PrintWord
01:870A 3E20            	   916: 	ld		A," "
01:870C CD7680          	   917: 	call	PrintChar
                        	   918: 
                        	   919: 	; PRINT THE STACK POINTER
01:870F 3E53            	   920: 	ld		A,"S"
01:8711 CD7680          	   921: 	call	PrintChar
01:8714 3E50            	   922: 	ld		A,"P"
01:8716 CD7680          	   923: 	call	PrintChar
01:8719 3E3A            	   924: 	ld		A,":"
01:871B CD7680          	   925: 	call	PrintChar
01:871E 2AC9B0          	   926: 	ld		HL,(StackPtr)
01:8721 23              	   927: 	inc		HL						; Offset stack by 2 to compensate for...
01:8722 23              	   928: 	inc		HL						;	this routine's call
01:8723 CDBE80          	   929: 	call	PrintWord
01:8726 3E20            	   930: 	ld		A," "
01:8728 CD7680          	   931: 	call	PrintChar
                        	   932: 
                        	   933: 	; PRINT THE FLAGS
01:872B 3E46            	   934: 	ld		A,"F"
01:872D CD7680          	   935: 	call	PrintChar
01:8730 3E3A            	   936: 	ld		A,":"
01:8732 CD7680          	   937: 	call	PrintChar
01:8735 219BAB          	   938: 	ld		HL,FlagBits
                        	   939: 
                        	   940: 	; Sign
01:8738 7E              	   941: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8739 CB79            	   942: 	bit		Sign,C					; Check to the associated bit is set or not
01:873B 2803            	   943: 	jr		z,FlagSignClear			; If it's Set, then print lower case
01:873D CDA182          	   944: 	call	UpperCase				; Else, print upper case
                        	   945: FlagSignClear:
01:8740 CD7680          	   946: 	call	PrintChar				; Print the flag symbol
01:8743 23              	   947: 	inc		HL						; Point to the next symbol
                        	   948: 	
                        	   949: 	; Zero
01:8744 7E              	   950: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8745 CB71            	   951: 	bit		Zero,C					; Check to the associated bit is set or not
01:8747 2803            	   952: 	jr		z,FlagZeroClear			; If it's Set, then print lower case
01:8749 CDA182          	   953: 	call	UpperCase				; Else, print upper case
                        	   954: FlagZeroClear:
01:874C CD7680          	   955: 	call	PrintChar				; Print the flag symbol
01:874F 23              	   956: 	inc		HL						; Point to the next symbol
                        	   957: 	
                        	   958: 	; Half-Carry
01:8750 7E              	   959: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8751 CB61            	   960: 	bit		HalfCarry,C				; Check to the associated bit is set or not
01:8753 2803            	   961: 	jr		z,FlagHalfClear			; If it's Set, then print lower case
01:8755 CDA182          	   962: 	call	UpperCase				; Else, print upper case
                        	   963: FlagHalfClear:
01:8758 CD7680          	   964: 	call	PrintChar				; Print the flag symbol
01:875B 23              	   965: 	inc		HL						; Point to the next symbol
                        	   966: 	
                        	   967: 	; Overflow/Parity
01:875C 7E              	   968: 	ld		A,(HL)					; Load the lowercase flag symbol
01:875D CB51            	   969: 	bit		Overflow,C				; Check to the associated bit is set or not
01:875F 2803            	   970: 	jr		z,FlagOverClear			; If it's Set, then print lower case
01:8761 CDA182          	   971: 	call	UpperCase				; Else, print upper case
                        	   972: FlagOverClear:
01:8764 CD7680          	   973: 	call	PrintChar				; Print the flag symbol
01:8767 23              	   974: 	inc		HL						; Point to the next symbol
                        	   975: 	
                        	   976: 	; Add/Substract
01:8768 7E              	   977: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8769 CB49            	   978: 	bit		Negative,C				; Check to the associated bit is set or not
01:876B 2803            	   979: 	jr		z,FlagNegativeClear		; If it's Set, then print lower case
01:876D CDA182          	   980: 	call	UpperCase				; Else, print upper case
                        	   981: FlagNegativeClear:
01:8770 CD7680          	   982: 	call	PrintChar				; Print the flag symbol
01:8773 23              	   983: 	inc		HL						; Point to the next symbol
                        	   984: 	
                        	   985: 	; Carry
01:8774 7E              	   986: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8775 CB41            	   987: 	bit		Carry,C					; Check to the associated bit is set or not
01:8777 2803            	   988: 	jr		z,FlagCarryClear		; If it's Set, then print lower case
01:8779 CDA182          	   989: 	call	UpperCase				; Else, print upper case
                        	   990: FlagCarryClear:
01:877C CD7680          	   991: 	call	PrintChar				; Print the flag symbol
01:877F 23              	   992: 	inc		HL						; Point to the next symbol
                        	   993: 
01:8780 CD8180          	   994: 	call	PrintCRLF
                        	   995: 
01:8783 FDE1            	   996: 	pop		IY
01:8785 DDE1            	   997: 	pop		IX
01:8787 E1              	   998: 	pop		HL
01:8788 D1              	   999: 	pop		DE
01:8789 C1              	  1000: 	pop		BC
01:878A F1              	  1001: 	pop		AF
01:878B C9              	  1002: 	ret
                        	  1003: 
                        	  1004: 
                        	  1005: ;  ____                  
                        	  1006: ; |  _ \   _   _   _ __  
                        	  1007: ; | |_) | | | | | | '_ \ 
                        	  1008: ; |  _ <  | |_| | | | | |
                        	  1009: ; |_| \_\  \__,_| |_| |_|
                        	  1010: 
                        	  1011: 
                        	  1012: ; *********************************************************************************************************************
                        	  1013: ; Executes code at a specific address, clearing the registers at the beginning
                        	  1014: ; Parameter:	[AAAA], where AAAA is an optional address to execute from. Defaults to CurrentAddress
                        	  1015: ; *********************************************************************************************************************
                        	  1016: 
                        	  1017: RunCode:
01:878C 2AACB0          	  1018: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:878F CDCD88          	  1019: 	call	GetHexParameter			; Get the parameter
01:8792 300A            	  1020: 	jr		nc,RunEnd				; If there's an error in getting the parameter, then exit
01:8794 FE00            	  1021: 	cp		0						; Is there a parameter?
01:8796 2004            	  1022: 	jr		nz,RunCallBC			; There's a valid parameter, then execute user code
01:8798 ED4BB0B0        	  1023: 	ld		BC,(CurrentAddress)		; Load the CurrentAddress in BC
                        	  1024: 
                        	  1025: RunCallBC:
01:879C C5              	  1026: 	push	BC						; Put execution address in the stack, see bellow "ret" acting as a "call (BC)"
01:879D C9              	  1027: 	ret								; Above "push BC" without "pop", "ret" acts as an indirect "call (BC)"
                        	  1028: 
                        	  1029: RunEnd:
01:879E C9              	  1030: 	ret
                        	  1031: 
                        	  1032: 
                        	  1033: ;  ____           _        _          _       _                           
                        	  1034: ; / ___|    ___  | |_     / \      __| |   __| |  _ __    ___   ___   ___ 
                        	  1035: ; \___ \   / _ \ | __|   / _ \    / _` |  / _` | | '__|  / _ \ / __| / __|
                        	  1036: ;  ___) | |  __/ | |_   / ___ \  | (_| | | (_| | | |    |  __/ \__ \ \__ \
                        	  1037: ; |____/   \___|  \__| /_/   \_\  \__,_|  \__,_| |_|     \___| |___/ |___/
                        	  1038: 
                        	  1039: 
                        	  1040: ; *********************************************************************************************************************
                        	  1041: ; Set current address from the command prompt
                        	  1042: ;	- Input:	An optional address parameter, defaults to $0000
                        	  1043: ; *********************************************************************************************************************
                        	  1044: 
                        	  1045: SetAddress:
01:879F F5              	  1046: 	push	AF
01:87A0 C5              	  1047: 	push	BC
01:87A1 D5              	  1048: 	push	DE
01:87A2 E5              	  1049: 	push	HL
                        	  1050: 	
01:87A3 2AACB0          	  1051: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87A6 CDCD88          	  1052: 	call	GetHexParameter			; Get a parameter
01:87A9 3010            	  1053: 	jr		nc,SetAddressEnd		; Exit routine if there was an error in the parameter
01:87AB FE00            	  1054: 	cp		0						; Is there a parameter returned?
01:87AD 2806            	  1055: 	jr		z,SetAddressDefault		; If there is none, select default address
01:87AF ED43B0B0        	  1056: 	ld		(CurrentAddress),BC		; Save address in parameter (BC or C) in CurrentAddress global variable
01:87B3 1806            	  1057: 	jr		SetAddressEnd
                        	  1058: 
                        	  1059: SetAddressDefault:
01:87B5 210000          	  1060: 	ld		HL,0					; Default address is $0000
01:87B8 22B0B0          	  1061: 	ld		(CurrentAddress),HL		; Save it in CurrentAddress global variable
                        	  1062: 
                        	  1063: SetAddressEnd:
01:87BB E1              	  1064: 	pop		HL
01:87BC D1              	  1065: 	pop		DE
01:87BD C1              	  1066: 	pop		BC
01:87BE F1              	  1067: 	pop		AF
                        	  1068: 	
01:87BF C9              	  1069: 	ret
                        	  1070: 	
                        	  1071: 
                        	  1072: ;  ____           _     ____                    _    
                        	  1073: ; / ___|    ___  | |_  | __ )    __ _   _ __   | | __
                        	  1074: ; \___ \   / _ \ | __| |  _ \   / _` | | '_ \  | |/ /
                        	  1075: ;  ___) | |  __/ | |_  | |_) | | (_| | | | | | |   < 
                        	  1076: ; |____/   \___|  \__| |____/   \__,_| |_| |_| |_|\_\
                        	  1077: 
                        	  1078: 
                        	  1079: ; *********************************************************************************************************************
                        	  1080: ; Set current bank from the command prompt
                        	  1081: ;	- Input:	An optional byte parameter, defaults to 0
                        	  1082: ; *********************************************************************************************************************
                        	  1083: ; Wishlist:
                        	  1084: ;	- Validation, only a nibble, and only 0-E
                        	  1085: ;	- Choice of BCD?
                        	  1086: 
                        	  1087: SetBank:
01:87C0 F5              	  1088: 	push	AF
01:87C1 C5              	  1089: 	push	BC
01:87C2 D5              	  1090: 	push	DE
01:87C3 E5              	  1091: 	push	HL
                        	  1092: 	
01:87C4 2AACB0          	  1093: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87C7 CDCD88          	  1094: 	call	GetHexParameter			; Get a parameter
01:87CA 3020            	  1095: 	jr		nc,SetBankEnd			; Exit routine if there was an error in the parameter
01:87CC FE00            	  1096: 	cp		0						; Is there a parameter returned?
01:87CE 2810            	  1097: 	jr		z,SetBankDefault		; If there is none, select default bank
01:87D0 FE02            	  1098: 	cp		2
01:87D2 2815            	  1099: 	jr		z,SetBankError
                        	  1100: 	
01:87D4 79              	  1101: 	ld		A,C
01:87D5 FE0F            	  1102: 	cp		$0F
01:87D7 3010            	  1103: 	jr		nc,SetBankError
01:87D9 32AFB0          	  1104: 	ld		(CurrentBank),A			; Save nibble in parameter (C) in CurrentBank global variable
01:87DC D330            	  1105: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87DE 180C            	  1106: 	jr		SetBankEnd
                        	  1107: 
                        	  1108: SetBankDefault:
01:87E0 3E00            	  1109: 	ld		A,0						; Default bank is 0
01:87E2 32AFB0          	  1110: 	ld		(CurrentBank),A			; Save it in CurrentBank global variable
01:87E5 D330            	  1111: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87E7 1803            	  1112: 	jr		SetBankEnd
                        	  1113: 
                        	  1114: SetBankError:
01:87E9 CD48B0          	  1115: 	call	InvalidBank
                        	  1116: 	
                        	  1117: SetBankEnd:
01:87EC E1              	  1118: 	pop		HL
01:87ED D1              	  1119: 	pop		DE
01:87EE C1              	  1120: 	pop		BC
01:87EF F1              	  1121: 	pop		AF
                        	  1122: 	
01:87F0 C9              	  1123: 	ret
                        	  1124: 	
                        	  1125: 	
                        	  1126: ;  ____                  ___            __         
                        	  1127: ; / ___|   _   _   ___  |_ _|  _ __    / _|   ___  
                        	  1128: ; \___ \  | | | | / __|  | |  | '_ \  | |_   / _ \ 
                        	  1129: ;  ___) | | |_| | \__ \  | |  | | | | |  _| | (_) |
                        	  1130: ; |____/   \__, | |___/ |___| |_| |_| |_|    \___/ 
                        	  1131: ;          |___/                                   
                        	  1132: 
                        	  1133: ; *********************************************************************************************************************
                        	  1134: ; Prints information about the ZedEighty (WiP)
                        	  1135: ; *********************************************************************************************************************
                        	  1136: 
                        	  1137: SysInfo:
01:87F1 E5              	  1138: 	push	HL
01:87F2 21AEAB          	  1139: 	ld		HL,SysInfoMsg			; Point the the text message
01:87F5 CDB080          	  1140: 	call	PrintString				; Print first line
01:87F8 CD8E80          	  1141: 	call	PrintLine				; Print a line
01:87FB CDB080          	  1142: 	call	PrintString				; Print the rest
                        	  1143: 	
                        	  1144: 	; Speed in MHz
01:87FE CDB080          	  1145: 	call	PrintString
                        	  1146: 	
                        	  1147: 	; Free RAM
01:8801 E5              	  1148: 	push	HL
01:8802 21A9CB          	  1149: 	ld		HL,BytesFree			; Load the amount of bytes free
01:8805 CD5A80          	  1150: 	call	PrintDec				; Print decimal value
01:8808 E1              	  1151: 	pop		HL
01:8809 CDB080          	  1152: 	call	PrintString
                        	  1153: 	
01:880C E1              	  1154: 	pop		HL
01:880D C9              	  1155: 	ret
                        	  1156: 
                        	  1157: 
                        	  1158: ; __        __         _   _          
                        	  1159: ; \ \      / /  _ __  (_) | |_    ___ 
                        	  1160: ;  \ \ /\ / /  | '__| | | | __|  / _ \
                        	  1161: ;   \ V  V /   | |    | | | |_  |  __/
                        	  1162: ;    \_/\_/    |_|    |_|  \__|  \___|
                        	  1163: ;
                        	  1164: ; *********************************************************************************************************************
                        	  1165: ; Write up to 8 bytes into memory
                        	  1166: ; *********************************************************************************************************************
                        	  1167: 
                        	  1168: Write:
01:880E F5              	  1169: 	push 	AF
01:880F C5              	  1170: 	push	BC
01:8810 D5              	  1171: 	push	DE
01:8811 E5              	  1172: 	push	HL
                        	  1173: 	
01:8812 2AACB0          	  1174: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	  1175: 	
                        	  1176: WriteGetAddress:
01:8815 CDCD88          	  1177: 	call	GetHexParameter			; Get the first parameter, start address
01:8818 D25988          	  1178: 	jp		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:881B FE00            	  1179: 	cp		0						; Is there a first parameter?
01:881D 2837            	  1180: 	jr		z,WriteNoParameter		; No, then print error message
01:881F C5              	  1181: 	push	BC						; Store start address that's in BC
01:8820 D1              	  1182: 	pop		DE						; Into DE
                        	  1183: 
                        	  1184: WriteFirstByte:
01:8821 CDCD88          	  1185: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8824 3033            	  1186: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8826 FE00            	  1187: 	cp		0						; Is there a second parameter?
01:8828 282C            	  1188: 	jr		z,WriteNoParameter		; No, then print error message
01:882A FE02            	  1189: 	cp		2						; Is it bigger then a byte?
01:882C 301D            	  1190: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:882E 79              	  1191: 	ld		A,C						; Transfer byte in A
01:882F 12              	  1192: 	ld		(DE),A					; Save the byte
01:8830 13              	  1193: 	inc		DE						; Point to the next location
01:8831 ED53B0B0        	  1194: 	ld		(CurrentAddress),DE		; Set CurrentAddress
                        	  1195: 
                        	  1196: WriteRemainingBytes:
01:8835 CDCD88          	  1197: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8838 301F            	  1198: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:883A FE00            	  1199: 	cp		0						; Is there another parameter?
01:883C 281B            	  1200: 	jr		z,WriteEnd				; No, then exit
01:883E FE02            	  1201: 	cp		2						; Is it bigger then a byte?
01:8840 3009            	  1202: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:8842 79              	  1203: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:8843 12              	  1204: 	ld		(DE),A					; Save the byte
01:8844 13              	  1205: 	inc		DE						; Point to the next location
01:8845 ED53B0B0        	  1206: 	ld		(CurrentAddress),DE		; Set CurrentAddress
01:8849 18EA            	  1207: 	jr		WriteRemainingBytes		; See if there are other bytes
                        	  1208: 
                        	  1209: WriteTooManyDigits:
01:884B CDC388          	  1210: 	call	DecErrorPointer			; Back up pointer one
01:884E CDC089          	  1211: 	call	PrintErrorPointer		; Print's pointer to actual error in command line
01:8851 CD51B0          	  1212: 	call	TooManyDigits			; Print invalid number of digits message	
01:8854 1803            	  1213: 	jr		WriteEnd
                        	  1214: 	
                        	  1215: WriteNoParameter:
01:8856 CD3CB0          	  1216: 	call	NoParameter
                        	  1217: 	
                        	  1218: WriteEnd:
01:8859 E1              	  1219: 	pop		HL
01:885A D1              	  1220: 	pop		DE
01:885B C1              	  1221: 	pop		BC
01:885C F1              	  1222: 	pop		AF
01:885D C9              	  1223: 	ret
                        	  1224: 
                        	  1225: 
                        	  1226: ;  _____                           _      _   _   ____                      
                        	  1227: ; |__  /   ___   _ __    ___      / \    | | | | |  _ \    __ _   _ __ ___  
                        	  1228: ;   / /   / _ \ | '__|  / _ \    / _ \   | | | | | |_) |  / _` | | '_ ` _ \ 
                        	  1229: ;  / /_  |  __/ | |    | (_) |  / ___ \  | | | | |  _ <  | (_| | | | | | | |
                        	  1230: ; /____|  \___| |_|     \___/  /_/   \_\ |_| |_| |_| \_\  \__,_| |_| |_| |_|
                        	  1231: 
                        	  1232: 
                        	  1233: ; *********************************************************************************************************************
                        	  1234: ; Zero all the RAM, including all the RAM. Excludes shadow ROM (otherwise it will corrupt the BIOS), as well as
                        	  1235: ; vector pages.
                        	  1236: ; *********************************************************************************************************************
                        	  1237: 
                        	  1238: ZeroAllRam:
01:885E F5              	  1239: 	push	AF
01:885F C5              	  1240: 	push	BC
01:8860 D5              	  1241: 	push	DE
01:8861 E5              	  1242: 	push	HL
                        	  1243: 	
01:8862 3E0E            	  1244: 	ld		A,$E
                        	  1245: ZeroLowRange:
01:8864 D330            	  1246: 	out		(BankSelect),A
01:8866 210080          	  1247: 	ld		HL,StartOfCode			; Load end address
01:8869 2B              	  1248: 	dec		HL
01:886A 118000          	  1249: 	ld		DE,InterruptVectorEnd	; Load start
01:886D B7              	  1250: 	or		A						; Clear carry flag
01:886E ED52            	  1251: 	sbc		HL,DE					; HL = HL - DE
01:8870 E5              	  1252: 	push	HL						; Put result of byte count
01:8871 C1              	  1253: 	pop		BC						; Into the byte count register
01:8872 218000          	  1254: 	ld		HL,InterruptVectorEnd	; Set source address
01:8875 F5              	  1255: 	push	AF
01:8876 3E00            	  1256: 	ld		A,0						; Grab byte to write
01:8878 77              	  1257: 	ld		(HL),A					; Save it at the source address
01:8879 F1              	  1258: 	pop		AF
01:887A 118000          	  1259: 	ld		DE,InterruptVectorEnd	; Place destination address
01:887D 13              	  1260: 	inc		DE
01:887E EDB0            	  1261: 	ldir
01:8880 3D              	  1262: 	dec		A
01:8881 FEFF            	  1263: 	cp		$FF
01:8883 20DF            	  1264: 	jr		nz,ZeroLowRange
                        	  1265: 
                        	  1266: ZeroHighRange:
01:8885 2100FD          	  1267: 	ld		HL,VectorTable			; Load end address
01:8888 2B              	  1268: 	dec		HL
01:8889 11D7B0          	  1269: 	ld		DE,EndOfCode			; Load start
01:888C B7              	  1270: 	or		A						; Clear carry flag
01:888D ED52            	  1271: 	sbc		HL,DE					; HL = HL - DE
01:888F E5              	  1272: 	push	HL						; Put result of byte count
01:8890 C1              	  1273: 	pop		BC						; Into the byte count register
01:8891 21D7B0          	  1274: 	ld		HL,EndOfCode			; Set source address
01:8894 3E00            	  1275: 	ld		A,0						; Grab byte to write
01:8896 77              	  1276: 	ld		(HL),A					; Save it at the source address
01:8897 11D7B0          	  1277: 	ld		DE,EndOfCode			; Place destination address
01:889A 13              	  1278: 	inc		DE
01:889B EDB0            	  1279: 	ldir
                        	  1280: 
01:889D 37              	  1281: 	scf								; Set Carry, indicates no error to calling program
                        	  1282: 
                        	  1283: ZeroEnd:
01:889E E1              	  1284: 	pop		HL
01:889F D1              	  1285: 	pop		DE
01:88A0 C1              	  1286: 	pop		BC
01:88A1 F1              	  1287: 	pop		AF
01:88A2 C9              	  1288: 	ret
                        	  1289: 
                        	  1290: 

Source: "main.asm"
                        	   273: 	.include	"ancillary.asm"		; Anscillary subroutines for monitor commands

Source: "ancillary.asm"
                        	     1: ; Ancillary monitor routines in this include file:
                        	     2: ; ------------------------------------------------
                        	     3: ;	- CommandPrompt					; {}
                        	     4: ;	- GetHexParameter				; [(HL) -> BC,A,(HL)]
                        	     5: ;	- Parse							; (HL)
                        	     6: ;	- SkipSpaces					; [HL -> HL]
                        	     7: 
                        	     8: 
                        	     9: ;   ____                                                       _   ____                                       _   
                        	    10: ;  / ___|   ___    _ __ ___    _ __ ___     __ _   _ __     __| | |  _ \   _ __    ___    _ __ ___    _ __   | |_ 
                        	    11: ; | |      / _ \  | '_ ` _ \  | '_ ` _ \   / _` | | '_ \   / _` | | |_) | | '__|  / _ \  | '_ ` _ \  | '_ \  | __|
                        	    12: ; | |___  | (_) | | | | | | | | | | | | | | (_| | | | | | | (_| | |  __/  | |    | (_) | | | | | | | | |_) | | |_ 
                        	    13: ;  \____|  \___/  |_| |_| |_| |_| |_| |_|  \__,_| |_| |_|  \__,_| |_|     |_|     \___/  |_| |_| |_| | .__/   \__|
                        	    14: ;                                                                                                    |_|          
                        	    15: 
                        	    16: ; *********************************************************************************************************************
                        	    17: ; Prints the prompt to console
                        	    18: ; *********************************************************************************************************************
                        	    19: 
                        	    20: CommandPrompt:
01:88A3 F5              	    21: 	push	AF
01:88A4 E5              	    22: 	push	HL
01:88A5 3AAFB0          	    23: 	ld		A,(CurrentBank)			; Get Current Bank number
01:88A8 CD6380          	    24: 	call	PrintByte				; Print it
01:88AB 3E3A            	    25: 	ld		A,":"					; 
01:88AD CD7680          	    26: 	call	PrintChar				; Print colon symbol
01:88B0 2AB0B0          	    27: 	ld		HL,(CurrentAddress)
01:88B3 CDBE80          	    28: 	call	PrintWord				; Print current address poointer
01:88B6 3E3E            	    29: 	ld		A,">"					; 
01:88B8 CD7680          	    30: 	call	PrintChar				; Print prompt symbol
01:88BB 3E20            	    31: 	ld		A," "					; 
01:88BD CD7680          	    32: 	call	PrintChar				; Print a space
01:88C0 E1              	    33: 	pop		HL
01:88C1 F1              	    34: 	pop		AF
01:88C2 C9              	    35: 	ret
                        	    36: 
                        	    37: 
                        	    38: ;  ____                  _____                                ____            _           _                 
                        	    39: ; |  _ \    ___    ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	    40: ; | | | |  / _ \  / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	    41: ; | |_| | |  __/ | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	    42: ; |____/   \___|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	    43: ;
                        	    44: ;
                        	    45: ; *********************************************************************************************************************
                        	    46: ; Decrement error pointer by one
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: DecErrorPointer:
01:88C3 F5              	    50: 	push	AF
01:88C4 3AAEB0          	    51: 	ld		A,(CmdErrorPointer)
01:88C7 3D              	    52: 	dec		A
01:88C8 32AEB0          	    53: 	ld		(CmdErrorPointer),A
01:88CB F1              	    54: 	pop		AF
01:88CC C9              	    55: 	ret
                        	    56: 
                        	    57: 
                        	    58: ;   ____          _     _   _                 ____                                              _                 
                        	    59: ;  / ___|   ___  | |_  | | | |   ___  __  __ |  _ \    __ _   _ __    __ _   _ __ ___     ___  | |_    ___   _ __ 
                        	    60: ; | |  _   / _ \ | __| | |_| |  / _ \ \ \/ / | |_) |  / _` | | '__|  / _` | | '_ ` _ \   / _ \ | __|  / _ \ | '__|
                        	    61: ; | |_| | |  __/ | |_  |  _  | |  __/  >  <  |  __/  | (_| | | |    | (_| | | | | | | | |  __/ | |_  |  __/ | |   
                        	    62: ;  \____|  \___|  \__| |_| |_|  \___| /_/\_\ |_|      \__,_| |_|     \__,_| |_| |_| |_|  \___|  \__|  \___| |_|   
                        	    63: ;
                        	    64: ;
                        	    65: ; *********************************************************************************************************************
                        	    66: ; Read a hexadecimal parameter from the CommandBuffer
                        	    67: ;	- Input:	HL = Buffer pointer of command buffer, points to parameter
                        	    68: ;	- Output:	BC = contains the converted Hex number (if it's a byte B is 0, C is the converted byte) 
                        	    69: ;				A = 0 is no parameter, 1 is a byte, 2 is a word
                        	    70: ;				HL = New position of pointer
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: GetHexParameter:
01:88CD CD3B8B          	    75: 	call	SkipSpaces				; Skip any spaces if any
01:88D0 E5              	    76: 	push	HL						; Save it, restoring it after character count
01:88D1 0E00            	    77: 	ld		C,$00					; Character count set to zero
                        	    78: 	
                        	    79: GetParamCount:
01:88D3 7E              	    80: 	ld		A,(HL)					; Read a character form the CommandBuffer
01:88D4 FE00            	    81: 	cp		0						; Is it the end of the CommandBuffer?
01:88D6 280C            	    82: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88D8 FE20            	    83: 	cp		DELIMITER				; If it's the delimiter for the next parameter
01:88DA 2808            	    84: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88DC FE3F            	    85: 	cp		"?"
01:88DE 2852            	    86: 	jr		z,GetParamHelp
01:88E0 23              	    87: 	inc		HL						; Increment buffer pointer to next character in parameter
01:88E1 0C              	    88: 	inc		C						; Add one, to the count of characters
01:88E2 18EF            	    89: 	jr		GetParamCount			; Loop if delimiter has not been reached
                        	    90: 
                        	    91: GetParamFetch:
01:88E4 79              	    92: 	ld		A,C						; Load counted characters into accumulator
01:88E5 E1              	    93: 	pop		HL						; Restore pointer back to it's original position
01:88E6 010000          	    94: 	ld		BC,$0000				; Clear the results register to store a nibble, byte or nibble+byte
                        	    95: 
                        	    96: GetParamFetch0;
01:88E9 FE00            	    97: 	cp		0						; Was a parameter specified?
01:88EB 2004            	    98: 	jr		nz,GetParamFetch1		; No then check for 1 
01:88ED 3E00            	    99: 	ld		A,0						; Returns 0 to indicate no parameters
01:88EF 183F            	   100: 	jr		GetParameterEnd			; End routine
                        	   101: 	
                        	   102: GetParamFetch1:
01:88F1 FE01            	   103: 	cp		1						; Was it only one digit?
01:88F3 200C            	   104: 	jr		nz,GetParamFetch2		; No then check for 2
01:88F5 7E              	   105: 	ld		A,(HL)
01:88F6 23              	   106: 	inc		HL
01:88F7 CD6B81          	   107: 	call	Ascii2HexNibble			; Convert an ASCII char in HL to a 4-bit hex value
01:88FA 304A            	   108: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:88FC 4F              	   109: 	ld		C,A						; Save value in LSB of C
01:88FD 3E01            	   110: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:88FF 182F            	   111: 	jr		GetParameterEnd			; End routine
                        	   112: 
                        	   113: GetParamFetch2:
01:8901 FE02            	   114: 	cp		2						; Was it two digits?
01:8903 200A            	   115: 	jr		nz,GetParamFetch3		; No then check for 3
01:8905 CD8F81          	   116: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:8908 303C            	   117: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:890A 4F              	   118: 	ld		C,A						; Save value in C
01:890B 3E01            	   119: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:890D 1821            	   120: 	jr		GetParameterEnd			; End routine
                        	   121: 
                        	   122: GetParamFetch3:
01:890F FE03            	   123: 	cp		3						; Was three digits?
01:8911 2012            	   124: 	jr		nz,GetParamFetch4		; No then check for 4
01:8913 7E              	   125: 	ld		A,(HL)
01:8914 23              	   126: 	inc		HL
01:8915 CD6B81          	   127: 	call	Ascii2HexNibble			; Convert the first ASCII char in HL to a hex value
01:8918 302C            	   128: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:891A 47              	   129: 	ld		B,A						; Save result in D
01:891B CD8F81          	   130: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:891E 3026            	   131: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:8920 4F              	   132: 	ld		C,A						; Store resulting byte in C (LSB)
01:8921 3E02            	   133: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
01:8923 180B            	   134: 	jr		GetParameterEnd			; End routine
                        	   135: 
                        	   136: GetParamFetch4:
01:8925 FE04            	   137: 	cp		4						; Was four digits?
01:8927 200E            	   138: 	jr		nz,GetParamNumberError	; Print error message
01:8929 CDAE81          	   139: 	call	Ascii2HexWord			; Convert a 4-character hex digit pointed by HL to a hex value
01:892C 3018            	   140: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:892E 3E02            	   141: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
                        	   142: 
                        	   143: GetParameterEnd:
01:8930 37              	   144: 	scf								; Set carry to indicate all is ok
01:8931 C9              	   145: 	ret
                        	   146: 
                        	   147: GetParamHelp:
01:8932 F1              	   148: 	pop		AF						; Dummy pop from stack as there was a push before
01:8933 3E0F            	   149: 	ld		A,HELP
01:8935 37              	   150: 	scf
01:8936 C9              	   151: 	ret
                        	   152: 
                        	   153: GetParamNumberError:
01:8937 0604            	   154: 	ld		B,4						;
                        	   155: GetErrorPointerLoop:
01:8939 CD4E89          	   156: 	call	IncErrorPointer			;
01:893C 10FB            	   157: 	djnz	GetErrorPointerLoop		;
01:893E CDC089          	   158: 	call	PrintErrorPointer
01:8941 CD51B0          	   159: 	call	TooManyDigits			; Print invalid number of digits message	
01:8944 1806            	   160: 	jr		GetParamErrorEnd		; End Error handling
                        	   161: 
                        	   162: GetParamHexError:
01:8946 CDC089          	   163: 	call	PrintErrorPointer
01:8949 CD5AB0          	   164: 	call	InvalidHexDigit			;Print invalid hex character message
                        	   165: 
                        	   166: GetParamErrorEnd:
01:894C B7              	   167: 	or		A						; Clear carry
01:894D C9              	   168: 	ret
                        	   169: 
                        	   170: 
                        	   171: ;  ___                  _____                                ____            _           _                 
                        	   172: ; |_ _|  _ __     ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   173: ;  | |  | '_ \   / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   174: ;  | |  | | | | | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   175: ; |___| |_| |_|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   176: ;
                        	   177: ;
                        	   178: ; *********************************************************************************************************************
                        	   179: ; Increment error pointer by one
                        	   180: ; *********************************************************************************************************************
                        	   181: 
                        	   182: IncErrorPointer:
01:894E F5              	   183: 	push	AF
01:894F 3AAEB0          	   184: 	ld		A,(CmdErrorPointer)
01:8952 3C              	   185: 	inc		A
01:8953 32AEB0          	   186: 	ld		(CmdErrorPointer),A
01:8956 F1              	   187: 	pop		AF
01:8957 C9              	   188: 	ret
                        	   189: 
                        	   190: 
                        	   191: ;  ____                                     
                        	   192: ; |  _ \    __ _   _ __   ___    ___   _ __ 
                        	   193: ; | |_) |  / _` | | '__| / __|  / _ \ | '__|
                        	   194: ; |  __/  | (_| | | |    \__ \ |  __/ | |   
                        	   195: ; |_|      \__,_| |_|    |___/  \___| |_|   
                        	   196: ;
                        	   197: ;
                        	   198: ; *********************************************************************************************************************
                        	   199: ; Parse the string and compare the commands list and the command prompt, then execute if found
                        	   200: ;	- Output:	BufferPointer points to parameter, if any
                        	   201: ; *********************************************************************************************************************
                        	   202: ;	- A = Command buffer character
                        	   203: ;	- B	= Command list character
                        	   204: ;	- DE = Command list pointer
                        	   205: ;	- HL = Command buffer pointer
                        	   206: 
                        	   207: Parser:
01:8958 F5              	   208: 	push	AF
01:8959 C5              	   209: 	push	BC
01:895A D5              	   210: 	push	DE
01:895B 22BCB0          	   211: 	ld		(ParseSaveHL),HL		; Saves HL register, because it's not possible to push it due to routine call
                        	   212: 
01:895E CD338B          	   213: 	call	ResetErrorPointer		; Reset error pointer to start position
01:8961 11BCA8          	   214: 	ld		DE,CommandList			; Commands list pointer
01:8964 2184B0          	   215: 	ld		HL,CommandBuffer		; Command buffer pointer
01:8967 CD3B8B          	   216: 	call	SkipSpaces				; Removes any leading spaces in command buffer
01:896A 22ACB0          	   217: 	ld		(BufferPointer),HL		; Save the position of the first character for later
01:896D 7E              	   218: 	ld		A,(HL)					; Read first character or delimiter of the command in command buffer
01:896E FE00            	   219: 	cp		0						; Is it the end of the string already?
01:8970 2847            	   220: 	jr		z,ParseEnd				; If so, then exit parser routine
                        	   221: 
                        	   222: ParseNextChar:
01:8972 7E              	   223: 	ld		A,(HL)					; Read a character from the command buffer
01:8973 CDA182          	   224: 	call	UpperCase				; Change the case to uppercase, as the command list is in uppercase
01:8976 47              	   225: 	ld		B,A						; Put the uppercase character read from string in B
01:8977 1A              	   226: 	ld		A,(DE)					; Load a command list character in accumulator
01:8978 FEFF            	   227: 	cp		EOT						; Has the end of the command list been reached?
01:897A 2837            	   228: 	jr		z,ParseInvalid			; Teache the End Of Table, no matching commands has been found
01:897C FEC3            	   229: 	cp		JUMP					; Is it a command delimiter? (Which is actualy a jp opcode)
01:897E 281B            	   230: 	jr		z,ParseValidate			; Yes, then execute command
01:8980 B8              	   231: 	cp		B						; Is the letter from the list matching the buffer?
01:8981 2007            	   232: 	jr		nz,ParseNextCmd			; If not the same, go to next command in the list
01:8983 CD4E89          	   233: 	call	IncErrorPointer			; Increment command line error pointer
01:8986 13              	   234: 	inc		DE						; Increment command list pointer to the next character
01:8987 23              	   235: 	inc		HL						; Increment command buffer pointer to tne next character
01:8988 18E8            	   236: 	jr		ParseNextChar			; Get the next character from command list
                        	   237: 
                        	   238: ParseNextCmd:
01:898A 13              	   239: 	inc		DE						; Increment command list pointer to eventually go to next command
01:898B 1A              	   240: 	ld		A,(DE)					; Load from command list
01:898C FEC3            	   241: 	cp		JUMP					; Is it the End Of Command delimiter?
01:898E 20FA            	   242: 	jr		nz,ParseNextCmd			; No, then repeat until found
01:8990 13              	   243: 	inc		DE						; It is then bypass jump address
01:8991 13              	   244: 	inc		DE						; Point to the first character of following command
01:8992 13              	   245: 	inc		DE						;
01:8993 2AACB0          	   246: 	ld		HL,(BufferPointer)		; Restore location of first valid command buffer character
01:8996 CD338B          	   247: 	call	ResetErrorPointer		; Reset error pointer to start position
01:8999 18D7            	   248: 	jr		ParseNextChar			; Loop back to read next character in list
                        	   249: 
                        	   250: ParseValidate:
01:899B 7E              	   251: 	ld		A,(HL)					; Check for extra unwanted characters by enforcing space delimiter
01:899C FE00            	   252: 	cp		0						; Check if it's the end of the buffer
01:899E 2804            	   253: 	jr		z,ParseExecute			; It's the end of the buffer, execute command
01:89A0 FE20            	   254: 	cp		DELIMITER				; Is the space delimiter present in the command buffer?
01:89A2 200F            	   255: 	jr		nz,ParseInvalid			; No, then it's not valid
                        	   256: 
                        	   257: ParseExecute:
01:89A4 22ACB0          	   258: 	ld		(BufferPointer),HL		; Save current command buffer pointer for jump command parameters, if applicable
01:89A7 EB              	   259: 	ex		DE,HL					; Exchange DE with HL registers to be able to use HL for jumping
                        	   260: ;	jp		(HL)					; Execute command at address in DE (now HL)
                        	   261: 
01:89A8 D1              	   262: 	pop		DE
01:89A9 C1              	   263: 	pop		BC
01:89AA F1              	   264: 	pop		AF
01:89AB E5              	   265: 	push	HL						; Save call address
01:89AC 2ABCB0          	   266: 	ld		HL,(ParseSaveHL)		; Restore HL
01:89AF C9              	   267: 	ret								; Perform indirect call (HL)
01:89B0 C34680          	   268: 	jp		Main					; Go to main
                        	   269: 	
                        	   270: ParseInvalid:
01:89B3 2175AC          	   271: 	ld		HL,ParseInvalidErr
01:89B6 CDB080          	   272: 	call	PrintString
                        	   273: 
                        	   274: ParseEnd:
01:89B9 2ABCB0          	   275: 	ld		HL,(ParseSaveHL)
01:89BC D1              	   276: 	pop		DE
01:89BD C1              	   277: 	pop		BC
01:89BE F1              	   278: 	pop		AF
                        	   279: 	
01:89BF C9              	   280: 	ret
                        	   281: 
                        	   282: 
                        	   283: ;  ____           _           _     _____                                ____            _           _                 
                        	   284: ; |  _ \   _ __  (_)  _ __   | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   285: ; | |_) | | '__| | | | '_ \  | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   286: ; |  __/  | |    | | | | | | | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   287: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   288: ;
                        	   289: ;
                        	   290: ; *********************************************************************************************************************
                        	   291: ; Print error pointer character under the command line, pointing to the culprit
                        	   292: ; *********************************************************************************************************************
                        	   293: 
                        	   294: PrintErrorPointer:
01:89C0 F5              	   295: 	push	AF
01:89C1 C5              	   296: 	push	BC
                        	   297: 	
01:89C2 3AAEB0          	   298: 	ld		A,(CmdErrorPointer)		; Load error pointer as counter
01:89C5 47              	   299: 	ld		B,A
                        	   300: PrintErrorLoop:
01:89C6 3E20            	   301: 	ld		A," "
01:89C8 CD7680          	   302: 	call	PrintChar				; Print a space character
01:89CB 10F9            	   303: 	djnz	PrintErrorLoop			; Decrement B, and repeat printing space, until 0
01:89CD 3E5E            	   304: 	ld		A,ERRORPTR
01:89CF CD7680          	   305: 	call	PrintChar				; Print the error pointer character
01:89D2 CD8180          	   306: 	call	PrintCRLF				; Change line
                        	   307: 	
01:89D5 C1              	   308: 	pop		BC
01:89D6 F1              	   309: 	pop		AF
01:89D7 C9              	   310: 	ret
                        	   311: 
                        	   312: 
                        	   313: ;  ____                                  __     __          _   _       _           _     _                 
                        	   314: ; |  _ \    __ _   _ __     __ _    ___  \ \   / /   __ _  | | (_)   __| |   __ _  | |_  (_)   ___    _ __  
                        	   315: ; | |_) |  / _` | | '_ \   / _` |  / _ \  \ \ / /   / _` | | | | |  / _` |  / _` | | __| | |  / _ \  | '_ \ 
                        	   316: ; |  _ <  | (_| | | | | | | (_| | |  __/   \ V /   | (_| | | | | | | (_| | | (_| | | |_  | | | (_) | | | | |
                        	   317: ; |_| \_\  \__,_| |_| |_|  \__, |  \___|    \_/     \__,_| |_| |_|  \__,_|  \__,_|  \__| |_|  \___/  |_| |_|
                        	   318: ;                          |___/                                                                            
                        	   319: 
                        	   320: ; *********************************************************************************************************************
                        	   321: ; Validates a range of addresses that can be written to with commands such as Fill and Zero. The range returns
                        	   322: ; one or two ranges (before BIOS and after BIOS). It excludes BIOS, Interrupt vectors, jump table, and stack.
                        	   323: ; - Input:	StartAddress, EndAddress
                        	   324: ; - Output:	Updated StartAddress and EndAddress for low range, and StartAddressAlt and EndAddressAlt for high range
                        	   325: ;			C = Flags: bit0 = Low bank, bit1 = High bank
                        	   326: ; *********************************************************************************************************************
                        	   327: 
                        	   328: RangeValidation:
01:89D8 F5              	   329: 	push	AF
01:89D9 D5              	   330: 	push	DE
01:89DA E5              	   331: 	push	HL
                        	   332: 	
01:89DB 0E00            	   333: 	ld		C,0						; Clear the region flag
01:89DD 210000          	   334: 	ld		HL,0
01:89E0 22D0B0          	   335: 	ld		(StartAddressAlt),HL	; Reset alternate start address (that represents low memory)
01:89E3 22D2B0          	   336: 	ld		(EndAddressAlt),HL		; Reset alternate end address (that represents high memory)
                        	   337: 	
                        	   338: ; CHECK ORDER OF START AND END ADDRESSES, AND IF RANGE IS ZERO
                        	   339: ; ------------------------------------------------------------
                        	   340: ValCheckInverted:
01:89E6 2ACCB0          	   341: 	ld		HL,(StartAddress)		; Load start address
01:89E9 ED5BCEB0        	   342: 	ld		DE,(EndAddress)			; Load end address
01:89ED B7              	   343: 	or		A						; Clear carry flag
01:89EE ED52            	   344: 	sbc		HL,DE					; HL = HL - DE
01:89F0 CA1F8B          	   345: 	jp		z,ValRangeTooSmallError	; If the range is 0, then print invalid error and exit
01:89F3 D2258B          	   346: 	jp		nc,ValInvertedError		; If start address is higher than the end address, then print error and exit
                        	   347: 
                        	   348: ; CHECK IF THE START AND END ADDRESSES ARE IN THE VECTOR AREAS AND AJUST THEM ACCORDINGLY
                        	   349: ; ----------------------------------------------------------------------------------------
                        	   350: ValCheckLowLimit:					; VALIDATE START ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:89F6 2ACCB0          	   351: 	ld		HL,(StartAddress)		; Load start address
01:89F9 118100          	   352: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:89FC B7              	   353: 	or		A						; Clear carry flag
01:89FD ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:89FF 3006            	   355: 	jr		nc, ValCheckLowLimit2	; If it's not in the interrupt vector table, continue to next validation 
01:8A01 218000          	   356: 	ld		HL,InterruptVectorEnd			; Load 
01:8A04 22CCB0          	   357: 	ld		(StartAddress),HL
                        	   358: 
                        	   359: ValCheckLowLimit2:					; VALIDATE END ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:8A07 2ACEB0          	   360: 	ld		HL,(EndAddress)			; Load end address
01:8A0A 118100          	   361: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:8A0D B7              	   362: 	or		A						; Clear carry flag
01:8A0E ED52            	   363: 	sbc		HL,DE					; HL = HL - DE
01:8A10 DA2B8B          	   364: 	jp		c, RangeValidationError	; If it's in the interrupt vector table, print error and exit
                        	   365: 
                        	   366: ValCheckHighLimit:					; VALIDATE END ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A13 2ACEB0          	   367: 	ld		HL,(EndAddress)			; Load start address
01:8A16 1100FD          	   368: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A19 B7              	   369: 	or		A						; Clear carry flag
01:8A1A ED52            	   370: 	sbc		HL,DE					; HL = HL - DE
01:8A1C 3806            	   371: 	jr		c, ValCheckHighLimit2	; If it's not in the vector tables, continue to next validation
01:8A1E 21FFFC          	   372: 	ld		HL,VectorTable-1		; Load Start of vector table area
01:8A21 22CEB0          	   373: 	ld		(EndAddress),HL
                        	   374: 	
                        	   375: ValCheckHighLimit2:					; VALIDATE START ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A24 2ACCB0          	   376: 	ld		HL,(StartAddress)		; Load start address
01:8A27 1100FD          	   377: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A2A B7              	   378: 	or		A						; Clear carry flag
01:8A2B ED52            	   379: 	sbc		HL,DE					; HL = HL - DE
01:8A2D D22B8B          	   380: 	jp		nc,RangeValidationError	; If it's in the interrupt vector table, then change upper limit 
                        	   381: 
                        	   382: ; CHECK IF THE RANGE IS COMPLETELY IN BIOS ZONE
                        	   383: ; ---------------------------------------------
                        	   384: ValCheckBiosLow:
01:8A30 2ACCB0          	   385: 	ld		HL,(StartAddress)		; Load start address
01:8A33 110080          	   386: 	ld		DE,StartOfCode			; Load start of code to compare too
01:8A36 B7              	   387: 	or		A						; Clear carry flag
01:8A37 ED52            	   388: 	sbc		HL,DE					; HL = HL - DE
01:8A39 380E            	   389: 	jr		c,ValCheckHigh			; If start address is lower than the start of code, then check if in high RRAM
                        	   390: 
                        	   391: ValCheckBiosHi:
01:8A3B 2ACEB0          	   392: 	ld		HL,(EndAddress)			; Load end address
01:8A3E 11D7B0          	   393: 	ld		DE,EndOfCode			; Load end of code address to compare too
01:8A41 B7              	   394: 	or		A						; Clear carry flag
01:8A42 ED52            	   395: 	sbc		HL,DE					; HL = HL - DE
01:8A44 3003            	   396: 	jr		nc,ValCheckHigh			; If end address is higher than the end of code, then check if in high RAM
01:8A46 C3198B          	   397: 	jp		ValBiosRangeError		; Else print invalid range and exit
                        	   398: 
                        	   399: ; CHECK IF RANGE IS IN HIGH MEMORY
                        	   400: ; --------------------------------
                        	   401: ValCheckHigh:
                        	   402: 	; Is it in high memory?
01:8A49 2ACCB0          	   403: 	ld		HL,(StartAddress)		; Load start address
01:8A4C 110080          	   404: 	ld		DE,StartOfCode			; Load start of code address
01:8A4F B7              	   405: 	or		A						; Clear carry flag
01:8A50 ED52            	   406: 	sbc		HL,DE					; HL = HL - DE
                        	   407: 	; No, then check for low memory
01:8A52 3829            	   408: 	jr		c,ValCheckLow
                        	   409: 
                        	   410: 	; Is it in high memory, but is it within the BIOS region?
01:8A54 2ACCB0          	   411: 	ld		HL,(StartAddress)		; Load start address
01:8A57 11D7B0          	   412: 	ld		DE,EndOfCode			; Load end of code address
01:8A5A B7              	   413: 	or		A						; Clear carry flag
01:8A5B ED52            	   414: 	sbc		HL,DE					; HL = HL - DE
                        	   415: 	; Yes, then change StartAddress to upper limit of BIOS
01:8A5D 3810            	   416: 	jr		c,ValCheckHighBios
                        	   417: 	; No, then only copy start and end addresses to the Alt locations
01:8A5F 2ACCB0          	   418: 	ld		HL,(StartAddress)		;
01:8A62 22D0B0          	   419: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A65 2ACEB0          	   420: 	ld		HL,(EndAddress)			;
01:8A68 22D2B0          	   421: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A6B CBC9            	   422: 	set		1,C						; Flag high address
01:8A6D 180E            	   423: 	jr		ValCheckLow
                        	   424: 
                        	   425: ValCheckHighBios:
01:8A6F 21D7B0          	   426: 	ld		HL,EndOfCode		;
01:8A72 22D0B0          	   427: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A75 2ACEB0          	   428: 	ld		HL,(EndAddress)			;
01:8A78 22D2B0          	   429: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A7B CBC9            	   430: 	set		1,C						; Flag high address
                        	   431: 	
                        	   432: ; CHECK IF RANGE IS IN LOW MEMORY
                        	   433: ; -------------------------------
                        	   434: ValCheckLow:
                        	   435: 	; Is it in low memory only?
01:8A7D 2ACEB0          	   436: 	ld		HL,(EndAddress)			; Load start address
01:8A80 11D7B0          	   437: 	ld		DE,EndOfCode			; Load start of code address
01:8A83 B7              	   438: 	or		A						; Clear carry flag
01:8A84 ED52            	   439: 	sbc		HL,DE					; HL = HL - DE
                        	   440: 	; No, then it overlaps BIOS
01:8A86 3018            	   441: 	jr		nc,ValBiosOverlap
                        	   442: 
                        	   443: 	; Is it in low memory, but is it within the BIOS region?
01:8A88 2ACEB0          	   444: 	ld		HL,(EndAddress)			; Load start address
01:8A8B 110080          	   445: 	ld		DE,StartOfCode			; Load end of code address
01:8A8E B7              	   446: 	or		A						; Clear carry flag
01:8A8F ED52            	   447: 	sbc		HL,DE					; HL = HL - DE
                        	   448: 	; Yes, then change EndAddress to lower limit of BIOS
01:8A91 3004            	   449: 	jr		nc,ValCheckLowBios
                        	   450: 	; No, then only flag low memory
01:8A93 CBC1            	   451: 	set		0,C						; Flag low address
01:8A95 1809            	   452: 	jr		ValBiosOverlap
                        	   453: 
                        	   454: ValCheckLowBios:
01:8A97 210080          	   455: 	ld		HL,StartOfCode			;
01:8A9A 2B              	   456: 	dec		HL
01:8A9B 22CEB0          	   457: 	ld		(EndAddress),HL			; Set start address at the end of code, in case it overlapped
01:8A9E CBC1            	   458: 	set		0,C						; Flag low address
                        	   459: 
                        	   460: ; CHECK IF RANGE OVERLAPS BIOS AREA
                        	   461: ; ---------------------------------
                        	   462: ValBiosOverlap:
01:8AA0 79              	   463: 	ld		A,C
01:8AA1 FE00            	   464: 	cp		0
01:8AA3 2017            	   465: 	jr		nz,ValCheckIfZeroDataLow
                        	   466: 	; Move EndAddress to the Alternate one
01:8AA5 2ACEB0          	   467: 	ld		HL,(EndAddress)
01:8AA8 22D2B0          	   468: 	ld		(EndAddressAlt),HL
                        	   469: 	; Change low memory EndAddress to beginning of BIOS -1
01:8AAB 210080          	   470: 	ld		HL,StartOfCode		
01:8AAE 2B              	   471: 	dec		HL
01:8AAF 22CEB0          	   472: 	ld		(EndAddress),HL
                        	   473: 	; Change high memory StartAddressAlt to end of BIOS
01:8AB2 21D7B0          	   474: 	ld		HL,EndOfCode
01:8AB5 22D0B0          	   475: 	ld		(StartAddressAlt),HL
01:8AB8 CBC1            	   476: 	set		0,C						; Flag low address
01:8ABA CBC9            	   477: 	set		1,C						; Flag high address
                        	   478: 
                        	   479: ; CHECK IF RANGE(S) ARE ZERO, WITH REASSIGNMENT, IT'S POSSIBLE
                        	   480: ; ------------------------------------------------------------
                        	   481: ValCheckIfZeroDataLow:
01:8ABC CB41            	   482: 	bit		0,C
01:8ABE 280C            	   483: 	jr		z,ValCheckIfZeroDataHigh
01:8AC0 2ACCB0          	   484: 	ld		HL,(StartAddress)		; Load start address
01:8AC3 ED5BCEB0        	   485: 	ld		DE,(EndAddress)			; Load end address
01:8AC7 B7              	   486: 	or		A						; Clear carry flag
01:8AC8 ED52            	   487: 	sbc		HL,DE					; HL = HL - DE
01:8ACA 2853            	   488: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   489: 
                        	   490: ValCheckIfZeroDataHigh:
01:8ACC CB49            	   491: 	bit		1,C
01:8ACE 280C            	   492: 	jr		z,ValPrintRange
01:8AD0 2AD0B0          	   493: 	ld		HL,(StartAddressAlt)	; Load alternate start address
01:8AD3 ED5BD2B0        	   494: 	ld		DE,(EndAddressAlt)		; Load alternate end address
01:8AD7 B7              	   495: 	or		A						; Clear carry flag
01:8AD8 ED52            	   496: 	sbc		HL,DE					; HL = HL - DE
01:8ADA 2843            	   497: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   498: 
                        	   499: 	; PRINTS ADDRESS RANGE
                        	   500: ValPrintRange:
01:8ADC CD0FB0          	   501: 	call	Range
                        	   502: 
                        	   503: ValPrintRange1:
01:8ADF CB41            	   504: 	bit		0,C
01:8AE1 2816            	   505: 	jr		z,ValPrintRange2
01:8AE3 3E20            	   506: 	ld		A," "
01:8AE5 CD7680          	   507: 	call	PrintChar
01:8AE8 2ACCB0          	   508: 	ld		HL,(StartAddress)
01:8AEB CDBE80          	   509: 	call	PrintWord
01:8AEE 3E2D            	   510: 	ld		A,"-"
01:8AF0 CD7680          	   511: 	call	PrintChar
01:8AF3 2ACEB0          	   512: 	ld		HL,(EndAddress)
01:8AF6 CDBE80          	   513: 	call	PrintWord
                        	   514: 	
                        	   515: ValPrintRange2:
01:8AF9 CB49            	   516: 	bit		1,C
01:8AFB 2816            	   517: 	jr		z,ValPrintRangeEnd
01:8AFD 3E20            	   518: 	ld		A," "
01:8AFF CD7680          	   519: 	call	PrintChar
01:8B02 2AD0B0          	   520: 	ld		HL,(StartAddressAlt)
01:8B05 CDBE80          	   521: 	call	PrintWord
01:8B08 3E2D            	   522: 	ld		A,"-"
01:8B0A CD7680          	   523: 	call	PrintChar
01:8B0D 2AD2B0          	   524: 	ld		HL,(EndAddressAlt)
01:8B10 CDBE80          	   525: 	call	PrintWord	
                        	   526: 
                        	   527: ValPrintRangeEnd:
01:8B13 CD8180          	   528: 	call	PrintCRLF
01:8B16 37              	   529: 	scf								; Set carry
01:8B17 1816            	   530: 	jr		RangeValidationEnd
                        	   531: 
                        	   532: ValBiosRangeError:
01:8B19 CD2AB0          	   533: 	call	BiosRange
01:8B1C B7              	   534: 	or		A
01:8B1D 1810            	   535: 	jr		RangeValidationEnd
                        	   536: 
                        	   537: ValRangeTooSmallError:
01:8B1F CD21B0          	   538: 	call	RangeTooSmall
01:8B22 B7              	   539: 	or		A
01:8B23 180A            	   540: 	jr		RangeValidationEnd
                        	   541: 
                        	   542: ValInvertedError:
01:8B25 CD33B0          	   543: 	call	RangeInverted
01:8B28 B7              	   544: 	or		A
01:8B29 1804            	   545: 	jr		RangeValidationEnd
                        	   546: 	
                        	   547: RangeValidationError:
01:8B2B CD18B0          	   548: 	call	InvalidVectorRange
01:8B2E B7              	   549: 	or		A						; Clear Carry
                        	   550: 
                        	   551: RangeValidationEnd:
01:8B2F E1              	   552: 	pop		HL
01:8B30 D1              	   553: 	pop		DE
01:8B31 F1              	   554: 	pop		AF
                        	   555: 
01:8B32 C9              	   556: 	ret
                        	   557: 
                        	   558: 
                        	   559: ;  ____                        _     _____                                ____            _           _                
                        	   560: ; |  _ \    ___   ___    ___  | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __
                        	   561: ; | |_) |  / _ \ / __|  / _ \ | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__
                        	   562: ; |  _ <  |  __/ \__ \ |  __/ | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |  
                        	   563: ; |_| \_\  \___| |___/  \___|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|  
                        	   564: ;
                        	   565: ;
                        	   566: ; *********************************************************************************************************************
                        	   567: ; Increment error pointer by one
                        	   568: ; *********************************************************************************************************************
                        	   569: 
                        	   570: ResetErrorPointer:
01:8B33 F5              	   571: 	push	AF
01:8B34 3E09            	   572: 	ld		A,ErrorPtrOffset
01:8B36 32AEB0          	   573: 	ld		(CmdErrorPointer),A
01:8B39 F1              	   574: 	pop		AF
01:8B3A C9              	   575: 	ret
                        	   576: 
                        	   577: 
                        	   578: ;  ____    _      _           ____                                      
                        	   579: ; / ___|  | | __ (_)  _ __   / ___|   _ __     __ _    ___    ___   ___ 
                        	   580: ; \___ \  | |/ / | | | '_ \  \___ \  | '_ \   / _` |  / __|  / _ \ / __|
                        	   581: ;  ___) | |   <  | | | |_) |  ___) | | |_) | | (_| | | (__  |  __/ \__ \
                        	   582: ; |____/  |_|\_\ |_| | .__/  |____/  | .__/   \__,_|  \___|  \___| |___/
                        	   583: ;                    |_|             |_|                                
                        	   584: ;
                        	   585: ; *********************************************************************************************************************
                        	   586: ; Removes leading spaces for parsing commands
                        	   587: ;	- Input:	HL pointing to command string
                        	   588: ;	- Output:	HL points to the next delimiterless position
                        	   589: ; *********************************************************************************************************************
                        	   590: 
                        	   591: SkipSpaces:
01:8B3B F5              	   592: 	push	AF
                        	   593: SkipSpacesLoop:
01:8B3C 7E              	   594: 	ld		A,(HL)					; Read the contents of HL, where the 
01:8B3D FE20            	   595: 	cp		" "						; Is it a space?
01:8B3F 2006            	   596: 	jr		nz,SkipSpacesEnd		; It's not a space, so end routine
01:8B41 23              	   597: 	inc		HL						; It's a space, so move to next character
01:8B42 CD4E89          	   598: 	call	IncErrorPointer			; Increment command line error pointer
01:8B45 18F5            	   599: 	jr		SkipSpacesLoop			; Check for other spaces, just in case
                        	   600: SkipSpacesEnd:
01:8B47 F1              	   601: 	pop		AF
01:8B48 C9              	   602: 	ret
                        	   603: 
                        	   604: 

Source: "main.asm"
                        	   274: 	.include	"basic.asm"			; Nascom Microsoft Basic (from Grant Searle)

Source: "basic.asm"
                        	     1: ;==================================================================================
                        	     2: ; The updates to the original BASIC within this file are copyright Grant Searle
                        	     3: ;
                        	     4: ; You have permission to use this for NON COMMERCIAL USE ONLY
                        	     5: ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        	     6: ;
                        	     7: ; http://searle.hostei.com/grant/index.html
                        	     8: ;
                        	     9: ; eMail: home.micros01@btinternet.com
                        	    10: ;
                        	    11: ; If the above don't work, please perform an Internet search to see if I have
                        	    12: ; updated the web page hosting service.
                        	    13: ;
                        	    14: ;==================================================================================
                        	    15: 
                        	    16: ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        	    17: ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        	    18: ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        	    19: ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        	    20: ; the original ROM code (checksum A934H). PA
                        	    21: ;
                        	    22: ;==================================================================================
                        	    23: 
                        	    24: ; BASIC ERROR CODE VALUES
                        	    25: 
                        	    26: NF		.EQU	00H				; NEXT without FOR
                        	    27: SN		.EQU	02H				; Syntax error
                        	    28: RG		.EQU	04H				; RETURN without GOSUB
                        	    29: OD		.EQU	06H				; Out of DATA
                        	    30: FC		.EQU	08H				; Function call error
                        	    31: OV		.EQU	0AH				; Overflow
                        	    32: OM		.EQU	0CH				; Out of memory
                        	    33: UL		.EQU	0EH				; Undefined line number
                        	    34: BS		.EQU	10H				; Bad subscript
                        	    35: DD		.EQU	12H				; Re-DIMensioned array
                        	    36: DZ		.EQU	14H				; Division by zero (/0)
                        	    37: ID		.EQU	16H				; Illegal direct
                        	    38: TM		.EQU	18H				; Type miss-match
                        	    39: OS		.EQU	1AH				; Out of string space
                        	    40: LS		.EQU	1CH				; String too long
                        	    41: ST		.EQU	1EH				; String formula too complex
                        	    42: CN		.EQU	20H				; Can't CONTinue
                        	    43: UF		.EQU	22H				; UnDEFined FN function
                        	    44: MO		.EQU	24H				; Missing operand
                        	    45: HX		.EQU	26H				; HEX error
                        	    46: BN		.EQU	28H				; BIN error
                        	    47: 
                        	    48: 
                        	    49: ; BASIC WORK SPACE LOCATIONS
                        	    50: 
                        	    51: ;WRKSPC	.EQU	2045H			  ; BASIC Work space
                        	    52: WRKSPC	.EQU	$1000			  ; BASIC Work space
                        	    53: USR		.EQU	WRKSPC+3H			; "USR (x)" jump
                        	    54: OUTSUB	.EQU	WRKSPC+6H			; "OUT p,n"
                        	    55: OTPORT	.EQU	WRKSPC+7H			; Port (p)
                        	    56: DIVSUP	.EQU	WRKSPC+9H			; Division support routine
                        	    57: DIV1	.EQU	WRKSPC+0AH			 ; <- Values
                        	    58: DIV2	.EQU	WRKSPC+0EH			 ; <-	to
                        	    59: DIV3	.EQU	WRKSPC+12H			 ; <-	be
                        	    60: DIV4	.EQU	WRKSPC+15H			 ; <-inserted
                        	    61: SEED	.EQU	WRKSPC+17H			 ; Random number seed
                        	    62: LSTRND	.EQU	WRKSPC+3AH			 ; Last random number
                        	    63: INPSUB	.EQU	WRKSPC+3EH			 ; #INP (x)" Routine
                        	    64: INPORT	.EQU	WRKSPC+3FH			 ; PORT (x)
                        	    65: NULLS	.EQU	WRKSPC+41H			 ; Number of nulls
                        	    66: LWIDTH	.EQU	WRKSPC+42H			 ; Terminal width
                        	    67: COMMAN	.EQU	WRKSPC+43H			 ; Width for commas
                        	    68: NULFLG	.EQU	WRKSPC+44H			 ; Null after input byte flag
                        	    69: CTLOFG	.EQU	WRKSPC+45H			 ; Control "O" flag
                        	    70: LINESC	.EQU	WRKSPC+46H			 ; Lines counter
                        	    71: LINESN	.EQU	WRKSPC+48H			 ; Lines number
                        	    72: CHKSUM	.EQU	WRKSPC+4AH			 ; Array load/save check sum
                        	    73: NMIFLG	.EQU	WRKSPC+4CH			 ; Flag for NMI break routine
                        	    74: BRKFLG	.EQU	WRKSPC+4DH			 ; Break flag
                        	    75: RINPUT	.EQU	WRKSPC+4EH			 ; Input reflection
                        	    76: POINT	.EQU	WRKSPC+51H			 ; "POINT" reflection (unused)
                        	    77: PSET	.EQU	WRKSPC+54H			 ; "SET"   reflection
                        	    78: RESET	.EQU	WRKSPC+57H			 ; "RESET" reflection
                        	    79: STRSPC	.EQU	WRKSPC+5AH			 ; Bottom of string space
                        	    80: LINEAT	.EQU	WRKSPC+5CH			 ; Current line number
                        	    81: BASTXT	.EQU	WRKSPC+5EH			 ; Pointer to start of program
                        	    82: BUFFER	.EQU	WRKSPC+61H			 ; Input buffer
                        	    83: STACK	.EQU	WRKSPC+66H			 ; Initial stack
                        	    84: CURPOS	.EQU	WRKSPC+0ABH			 ; Character position on line
                        	    85: LCRFLG	.EQU	WRKSPC+0ACH			 ; Locate/Create flag
                        	    86: TYPE	.EQU	WRKSPC+0ADH			 ; Data type flag
                        	    87: DATFLG	.EQU	WRKSPC+0AEH			 ; Literal statement flag
                        	    88: LSTRAM	.EQU	WRKSPC+0AFH			 ; Last available RAM
                        	    89: TMSTPT	.EQU	WRKSPC+0B1H			 ; Temporary string pointer
                        	    90: TMSTPL	.EQU	WRKSPC+0B3H			 ; Temporary string pool
                        	    91: TMPSTR	.EQU	WRKSPC+0BFH			 ; Temporary string
                        	    92: STRBOT	.EQU	WRKSPC+0C3H			 ; Bottom of string space
                        	    93: CUROPR	.EQU	WRKSPC+0C5H			 ; Current operator in EVAL
                        	    94: LOOPST	.EQU	WRKSPC+0C7H			 ; First statement of loop
                        	    95: DATLIN	.EQU	WRKSPC+0C9H			 ; Line of current DATA item
                        	    96: FORFLG	.EQU	WRKSPC+0CBH			 ; "FOR" loop flag
                        	    97: LSTBIN	.EQU	WRKSPC+0CCH			 ; Last byte entered
                        	    98: READFG	.EQU	WRKSPC+0CDH			 ; Read/Input flag
                        	    99: BRKLIN	.EQU	WRKSPC+0CEH			 ; Line of break
                        	   100: NXTOPR	.EQU	WRKSPC+0D0H			 ; Next operator in EVAL
                        	   101: ERRLIN	.EQU	WRKSPC+0D2H			 ; Line of error
                        	   102: CONTAD	.EQU	WRKSPC+0D4H			 ; Where to CONTinue
                        	   103: PROGND	.EQU	WRKSPC+0D6H			 ; End of program
                        	   104: VAREND	.EQU	WRKSPC+0D8H			 ; End of variables
                        	   105: ARREND	.EQU	WRKSPC+0DAH			 ; End of arrays
                        	   106: NXTDAT	.EQU	WRKSPC+0DCH			 ; Next data item
                        	   107: FNRGNM	.EQU	WRKSPC+0DEH			 ; Name of FN argument
                        	   108: FNARG	.EQU	WRKSPC+0E0H			 ; FN argument value
                        	   109: FPREG	.EQU	WRKSPC+0E4H			 ; Floating point register
                        	   110: FPEXP	.EQU	FPREG+3			; Floating point exponent
                        	   111: SGNRES	.EQU	WRKSPC+0E8H		; Sign of result
                        	   112: PBUFF	.EQU	WRKSPC+0E9H		; Number print buffer
                        	   113: MULVAL	.EQU	WRKSPC+0F6H		; Multiplier
                        	   114: PROGST	.EQU	WRKSPC+0F9H		; Start of program text area
                        	   115: STLOOK	.EQU	WRKSPC+15DH		; Start of memory test
                        	   116: 
                        	   117: 
                        	   118: ;TEMPSTACK	.EQU	$20ED ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   119: TEMPSTACK	.EQU	$7FFF ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   120: 
                        	   121: 
                        	   122: ;  ____       _      ____    ___    ____ 
                        	   123: ; | __ )     / \    / ___|  |_ _|  / ___|
                        	   124: ; |  _ \    / _ \   \___ \   | |  | |    
                        	   125: ; | |_) |  / ___ \   ___) |  | |  | |___ 
                        	   126: ; |____/  /_/   \_\ |____/  |___|  \____|
                        	   127: ;
                        	   128: ;
                        	   129: ; *********************************************************************************************************************
                        	   130: 
                        	   131: BASIC:
01:8B49 CDAC82          	   132: 	call	ClearScreen				; Clear screen
01:8B4C 21728B          	   133: 	ld		HL,SignOnMsg			; Sign-on message
01:8B4F CDB080          	   134: 	call	PrintString				; Output string
                        	   135: 
                        	   136: ColdOrWarm:
01:8B52 CDC980          	   137: 	call	ReadChar				; Read a character
01:8B55 CDA182          	   138: 	call	Uppercase				; Convert to uppercase
                        	   139: 
                        	   140: CheckIfCold:
01:8B58 FE43            	   141: 	cp		"C"						; Is it C for Coldstart?
01:8B5A 2009            	   142: 	jr		nz,CheckIfWarm			; No, then check if it's Warmstart
01:8B5C CD7680          	   143: 	call	PrintChar				; Print the C
01:8B5F CD8180          	   144: 	call	PrintCRLF				; Print carriage return and linefeed
01:8B62 C3CE8B          	   145: 	jp		COLD					; Start BASIC COLD
                        	   146: 
                        	   147: CheckIfWarm:
01:8B65 FE57            	   148: 	cp		"W"						
01:8B67 20E9            	   149: 	jr		nz,ColdOrWarm
01:8B69 CD7680          	   150: 	call	PrintChar
01:8B6C CD8180          	   151: 	call	PrintCRLF
01:8B6F C36C8C          	   152: 	jp		WARM					; Start BASIC WARM
                        	   153: 			  
                        	   154: SignOnMsg:
01:8B72 5570646174657320	   155: 	db		"Updates to BASIC by Grant Searle",CR,LF
01:8B7A 746F204241534943
01:8B82 206279204772616E
01:8B8A 7420536561726C65
01:8B92 0D
01:8B93 0A
01:8B94 4164617074656420	   156: 	db		"Adapted by Frederic Segard",CR,LF
01:8B9C 6279204672656465
01:8BA4 7269632053656761
01:8BAC 7264
01:8BAE 0D
01:8BAF 0A
01:8BB0 436F6C64206F7220	   157: 	db		"Cold or warm start (C or W)? ",0
01:8BB8 7761726D20737461
01:8BC0 7274202843206F72
01:8BC8 2057293F20
01:8BCD 00
                        	   158: 
                        	   159: ; COLD START SEQUENCE
                        	   160: COLD:
01:8BCE DD210000        	   161: 	LD		IX,0					; Flag cold start
01:8BD2 C3D98B          	   162: 	jp		CSTART					; Jump to initialise
                        	   163: 
01:8BD5 8794            	   164: 	dw		DEINT					; Get integer -32768 to 32767
01:8BD7 F69B            	   165: 	dw		ABPASS					; Return integer in AB
                        	   166: 
                        	   167: CSTART:
01:8BD9 210010          	   168: 	ld		HL,WRKSPC				; Start of workspace RAM
01:8BDC F9              	   169: 	ld		SP,HL					; Set up a temporary stack
01:8BDD C319A8          	   170: 	jp		INITST					; Go to initialise
                        	   171: 
                        	   172: INIT:
01:8BE0 11AB8E          	   173: 	ld		DE,INITAB				; Initialise workspace
01:8BE3 0663            	   174: 	ld		B,INITBE-INITAB+3		; Bytes to copy
01:8BE5 210010          	   175: 	ld		HL,WRKSPC				; Into workspace RAM
                        	   176: COPYY:
01:8BE8 1A              	   177: 	ld		A,(DE)					; Get source
01:8BE9 77              	   178: 	ld		(HL),A					; To destination
01:8BEA 23              	   179: 	inc		HL						; Next destination
01:8BEB 13              	   180: 	inc		DE						; Next source
01:8BEC 05              	   181: 	dec		B						; Count bytes
01:8BED C2E88B          	   182: 	jp		NZ,COPYY				; More to move
01:8BF0 F9              	   183: 	ld		SP,HL					; Temporary stack
01:8BF1 CDAC90          	   184: 	call	CLREG					; Clear registers and stack
01:8BF4 CD8180          	   185: 	call	PrintCRLF				; Output CRLF
01:8BF7 32AA10          	   186: 	ld		(BUFFER+72+1),A 		; Mark end of buffer
01:8BFA 32F910          	   187: 	ld		(PROGST),A				; Initialise program area
                        	   188: MSIZE:
01:8BFD 21BA8C          	   189: 	ld		HL,MEMMSG				; Point to message
01:8C00 CD149D          	   190: 	call	PRS						; Output "Memory size"
01:8C03 CDC990          	   191: 	call	PROMPT					; Get input with '?'
01:8C06 CDD293          	   192: 	call	GETCHR					; Get next character
01:8C09 B7              	   193: 	or		A						; Set flags
01:8C0A C2228C          	   194: 	jp		NZ,TSTMEM				; If number - Test if RAM there
01:8C0D 215D11          	   195: 	ld		HL,STLOOK				; Point to start of RAM
                        	   196: MLOOP:
01:8C10 23              	   197: 	inc		HL						; Next byte
01:8C11 7C              	   198: 	ld		A,H						; Above address FFFF ?
01:8C12 B5              	   199: 	or		L
01:8C13 CA348C          	   200: 	jp		Z,SETTOP				; Yes - 64K RAM
01:8C16 7E              	   201: 	ld		A,(HL)					; Get contents
01:8C17 47              	   202: 	ld		B,A						; Save it
01:8C18 2F              	   203: 	cpl								; Flip all bits
01:8C19 77              	   204: 	ld		(HL),A					; Put it back
01:8C1A BE              	   205: 	cp		(HL)					; RAM there if same
01:8C1B 70              	   206: 	ld		(HL),B					; Restore old contents
01:8C1C CA108C          	   207: 	jp		Z,MLOOP					; If RAM - test next byte
01:8C1F C3348C          	   208: 	jp		SETTOP					; Top of RAM found
                        	   209: 
                        	   210: TSTMEM:
01:8C22 CDA194          	   211: 	call	ATOH					; Get high memory into DE
01:8C25 B7              	   212: 	or		A						; Set flags on last byte
01:8C26 C27A8F          	   213: 	jp		NZ,SNERR				; ?SN Error if bad character
01:8C29 EB              	   214: 	ex		DE,HL					; Address into HL
01:8C2A 2B              	   215: 	dec		HL						; Back one byte
01:8C2B 3ED9            	   216: 	ld		A,11011001B				; Test byte
01:8C2D 46              	   217: 	ld		B,(HL)					; Get old contents
01:8C2E 77              	   218: 	ld		(HL),A					; Load test byte
01:8C2F BE              	   219: 	cp		(HL)					; RAM there if same
01:8C30 70              	   220: 	ld		(HL),B					; Restore old contents
01:8C31 C2FD8B          	   221: 	jp		NZ,MSIZE				; Ask again if no RAM
                        	   222: 
                        	   223: SETTOP:
01:8C34 2B              	   224: 	dec		HL						; Back one byte
01:8C35 115C11          	   225: 	ld		DE,STLOOK-1				; See if enough RAM
01:8C38 CD4292          	   226: 	call	CPDEHL					; Compare DE with HL
01:8C3B DAFD8B          	   227: 	jp		C,MSIZE					; Ask again if not enough RAM
01:8C3E 11CEFF          	   228: 	ld		DE,0-50					; 50 Bytes string space
01:8C41 22AF10          	   229: 	ld		(LSTRAM),HL				; Save last available RAM
01:8C44 19              	   230: 	add		HL,DE					; Allocate string space
01:8C45 225A10          	   231: 	ld		(STRSPC),HL				; Save string space
01:8C48 CD8790          	   232: 	call	CLRPTR					; Clear program area
01:8C4B 2A5A10          	   233: 	ld		HL,(STRSPC)				; Get end of memory
01:8C4E 11EFFF          	   234: 	ld		DE,0-17					; Offset for free bytes
01:8C51 19              	   235: 	add		HL,DE					; Adjust HL
01:8C52 11F910          	   236: 	ld		DE,PROGST				; Start of program text
01:8C55 7D              	   237: 	ld		A,L						; Get LSB
01:8C56 93              	   238: 	sub		E						; Adjust it
01:8C57 6F              	   239: 	ld		L,A						; Re-save
01:8C58 7C              	   240: 	ld		A,H						; Get MSB
01:8C59 9A              	   241: 	sbc		A,D						; Adjust it
01:8C5A 67              	   242: 	ld		H,A						; Re-save
01:8C5B E5              	   243: 	push	HL						; Save bytes free
01:8C5C 21848C          	   244: 	ld		HL,SIGNON				; Sign-on message
01:8C5F CD149D          	   245: 	call	PRS						; Output string
01:8C62 E1              	   246: 	pop		HL						; Get bytes free back
01:8C63 CDB7A3          	   247: 	call	PRNTHL					; Output amount of free memory
01:8C66 21758C          	   248: 	ld		HL,BFREE				; " Bytes free" message
01:8C69 CD149D          	   249: 	call	PRS						; Output string
                        	   250: 
                        	   251: WARM:								; WARM START
01:8C6C 316610          	   252: 	ld		SP,STACK				; Temporary stack
                        	   253: BRKRET:
01:8C6F CDAC90          	   254: 	call	CLREG					; Clear registers and stack
01:8C72 C3C58F          	   255: 	jp		PRNTOK					; Go to get command line
                        	   256: 
                        	   257: BFREE:	
01:8C75 2042797465732066	   258: 	db		" Bytes free",CR,LF,0,0
01:8C7D 726565
01:8C80 0D
01:8C81 0A
01:8C82 00
01:8C83 00
                        	   259: 
                        	   260: SIGNON: 
01:8C84 5A38302042415349	   261: 	db		"Z80 BASIC Ver 4.7b",CR,LF
01:8C8C 432056657220342E
01:8C94 3762
01:8C96 0D
01:8C97 0A
01:8C98 436F707972696768	   262: 	db		"Copyright (C) 1978 by Microsoft",CR,LF,0
01:8CA0 7420284329203139
01:8CA8 3738206279204D69
01:8CB0 63726F736F6674
01:8CB7 0D
01:8CB8 0A
01:8CB9 00
                        	   263: 
                        	   264: MEMMSG:
01:8CBA 4D656D6F72792074	   265: 	db		"Memory top",0
01:8CC2 6F70
01:8CC4 00
                        	   266: 
                        	   267: 
                        	   268: ; FUNCTION ADDRESS TABLE
                        	   269: 
                        	   270: FNCTAB:
01:8CC5 2CA2            	   271: 	dw		SGN
01:8CC7 F0A2            	   272: 	dw		INT
01:8CC9 42A2            	   273: 	dw		ABS
01:8CCB 0310            	   274: 	dw		USR
01:8CCD D49B            	   275: 	dw		FRE
01:8CCF 599F            	   276: 	dw		INP
01:8CD1 029C            	   277: 	dw		POS
01:8CD3 B6A4            	   278: 	dw		SQR
01:8CD5 95A5            	   279: 	dw		RND
01:8CD7 D1A0            	   280: 	dw		LOG
01:8CD9 04A5            	   281: 	dw		EXPP
01:8CDB 0AA6            	   282: 	dw		COS
01:8CDD 10A6            	   283: 	dw		SIN
01:8CDF 71A6            	   284: 	dw		TAN
01:8CE1 86A6            	   285: 	dw		ATN
01:8CE3 AD9F            	   286: 	dw		PEEK
01:8CE5 F1A6            	   287: 	dw		DEEK
01:8CE7 5110            	   288: 	dw		POINT
01:8CE9 869E            	   289: 	dw		LEN
01:8CEB 9E9C            	   290: 	dw		STRR
01:8CED 209F            	   291: 	dw		VAL
01:8CEF 959E            	   292: 	dw		ASCC
01:8CF1 A69E            	   293: 	dw		CHR
01:8CF3 13A7            	   294: 	dw		HEX
01:8CF5 AAA7            	   295: 	dw		BIN
01:8CF7 B69E            	   296: 	dw		LEFT
01:8CF9 E69E            	   297: 	dw		RIGHT
01:8CFB F09E            	   298: 	dw		MID
                        	   299: 
                        	   300: 
                        	   301: ; RESERVED WORD LIST
                        	   302: 
                        	   303: WORDS:
01:8CFD C5              	   304: 	db		'E'+80H,"ND"
01:8CFE 4E44
01:8D00 C6              	   305: 	db		'F'+80H,"OR"
01:8D01 4F52
01:8D03 CE              	   306: 	db		'N'+80H,"EXT"
01:8D04 455854
01:8D07 C4              	   307: 	db		'D'+80H,"ATA"
01:8D08 415441
01:8D0B C9              	   308: 	db		'I'+80H,"NPUT"
01:8D0C 4E505554
01:8D10 C4              	   309: 	db		'D'+80H,"IM"
01:8D11 494D
01:8D13 D2              	   310: 	db		'R'+80H,"EAD"
01:8D14 454144
01:8D17 CC              	   311: 	db		'L'+80H,"ET"
01:8D18 4554
01:8D1A C7              	   312: 	db		'G'+80H,"OTO"
01:8D1B 4F544F
01:8D1E D2              	   313: 	db		'R'+80H,"UN"
01:8D1F 554E
01:8D21 C9              	   314: 	db		'I'+80H,"F"
01:8D22 46
01:8D23 D2              	   315: 	db		'R'+80H,"ESTORE"
01:8D24 4553544F5245
01:8D2A C7              	   316: 	db		'G'+80H,"OSUB"
01:8D2B 4F535542
01:8D2F D2              	   317: 	db		'R'+80H,"ETURN"
01:8D30 455455524E
01:8D35 D2              	   318: 	db		'R'+80H,"EM"
01:8D36 454D
01:8D38 D3              	   319: 	db		'S'+80H,"TOP"
01:8D39 544F50
01:8D3C CF              	   320: 	db		'O'+80H,"UT"
01:8D3D 5554
01:8D3F CF              	   321: 	db		'O'+80H,"N"
01:8D40 4E
01:8D41 CE              	   322: 	db		'N'+80H,"ULL"
01:8D42 554C4C
01:8D45 D7              	   323: 	db		'W'+80H,"AIT"
01:8D46 414954
01:8D49 C4              	   324: 	db		'D'+80H,"EF"
01:8D4A 4546
01:8D4C D0              	   325: 	db		'P'+80H,"OKE"
01:8D4D 4F4B45
01:8D50 C4              	   326: 	db		'D'+80H,"OKE"
01:8D51 4F4B45
01:8D54 D3              	   327: 	db		'S'+80H,"CREEN"
01:8D55 435245454E
01:8D5A CC              	   328: 	db		'L'+80H,"INES"
01:8D5B 494E4553
01:8D5F C3              	   329: 	db		'C'+80H,"LS"
01:8D60 4C53
01:8D62 D7              	   330: 	db		'W'+80H,"IDTH"
01:8D63 49445448
01:8D67 CD              	   331: 	db		'M'+80H,"ONITOR"
01:8D68 4F4E49544F52
01:8D6E D3              	   332: 	db		'S'+80H,"ET"
01:8D6F 4554
01:8D71 D2              	   333: 	db		'R'+80H,"ESET"
01:8D72 45534554
01:8D76 D0              	   334: 	db		'P'+80H,"RINT"
01:8D77 52494E54
01:8D7B C3              	   335: 	db		'C'+80H,"ONT"
01:8D7C 4F4E54
01:8D7F CC              	   336: 	db		'L'+80H,"IST"
01:8D80 495354
01:8D83 C3              	   337: 	db		'C'+80H,"LEAR"
01:8D84 4C454152
01:8D88 C3              	   338: 	db		'C'+80H,"LOAD"
01:8D89 4C4F4144
01:8D8D C3              	   339: 	db		'C'+80H,"SAVE"
01:8D8E 53415645
01:8D92 CE              	   340: 	db		'N'+80H,"EW"
01:8D93 4557
01:8D95 C5              	   341: 	db		'E'+80H,"XIT"			; Exit BASIC
01:8D96 584954
                        	   342: 	
01:8D99 D4              	   343: 	db		'T'+80H,"AB("
01:8D9A 414228
01:8D9D D4              	   344: 	db		'T'+80H,"O"
01:8D9E 4F
01:8D9F C6              	   345: 	db		'F'+80H,"N"
01:8DA0 4E
01:8DA1 D3              	   346: 	db		'S'+80H,"PC("
01:8DA2 504328
01:8DA5 D4              	   347: 	db		'T'+80H,"HEN"
01:8DA6 48454E
01:8DA9 CE              	   348: 	db		'N'+80H,"OT"
01:8DAA 4F54
01:8DAC D3              	   349: 	db		'S'+80H,"TEP"
01:8DAD 544550
                        	   350: 
01:8DB0 AB              	   351: 	db		'+'+80H
01:8DB1 AD              	   352: 	db		'-'+80H
01:8DB2 AA              	   353: 	db		'*'+80H
01:8DB3 AF              	   354: 	db		'/'+80H
01:8DB4 DE              	   355: 	db		'^'+80H
01:8DB5 C1              	   356: 	db		'A'+80H,"ND"
01:8DB6 4E44
01:8DB8 CF              	   357: 	db		'O'+80H,"R"
01:8DB9 52
01:8DBA BE              	   358: 	db		'>'+80H
01:8DBB BD              	   359: 	db		'='+80H
01:8DBC BC              	   360: 	db		'<'+80H
                        	   361: 
01:8DBD D3              	   362: 	db		'S'+80H,"GN"
01:8DBE 474E
01:8DC0 C9              	   363: 	db		'I'+80H,"NT"
01:8DC1 4E54
01:8DC3 C1              	   364: 	db		'A'+80H,"BS"
01:8DC4 4253
01:8DC6 D5              	   365: 	db		'U'+80H,"SR"
01:8DC7 5352
01:8DC9 C6              	   366: 	db		'F'+80H,"RE"
01:8DCA 5245
01:8DCC C9              	   367: 	db		'I'+80H,"NP"
01:8DCD 4E50
01:8DCF D0              	   368: 	db		'P'+80H,"OS"
01:8DD0 4F53
01:8DD2 D3              	   369: 	db		'S'+80H,"QR"
01:8DD3 5152
01:8DD5 D2              	   370: 	db		'R'+80H,"ND"
01:8DD6 4E44
01:8DD8 CC              	   371: 	db		'L'+80H,"OG"
01:8DD9 4F47
01:8DDB C5              	   372: 	db		'E'+80H,"XP"
01:8DDC 5850
01:8DDE C3              	   373: 	db		'C'+80H,"OS"
01:8DDF 4F53
01:8DE1 D3              	   374: 	db		'S'+80H,"IN"
01:8DE2 494E
01:8DE4 D4              	   375: 	db		'T'+80H,"AN"
01:8DE5 414E
01:8DE7 C1              	   376: 	db		'A'+80H,"TN"
01:8DE8 544E
01:8DEA D0              	   377: 	db		'P'+80H,"EEK"
01:8DEB 45454B
01:8DEE C4              	   378: 	db		'D'+80H,"EEK"
01:8DEF 45454B
01:8DF2 D0              	   379: 	db		'P'+80H,"OINT"
01:8DF3 4F494E54
01:8DF7 CC              	   380: 	db		'L'+80H,"EN"
01:8DF8 454E
01:8DFA D3              	   381: 	db		'S'+80H,"TR$"
01:8DFB 545224
01:8DFE D6              	   382: 	db		'V'+80H,"AL"
01:8DFF 414C
01:8E01 C1              	   383: 	db		'A'+80H,"SC"
01:8E02 5343
01:8E04 C3              	   384: 	db		'C'+80H,"HR$"
01:8E05 485224
01:8E08 C8              	   385: 	db		'H'+80H,"EX$"
01:8E09 455824
01:8E0C C2              	   386: 	db		'B'+80H,"IN$"
01:8E0D 494E24
01:8E10 CC              	   387: 	db		'L'+80H,"EFT$"
01:8E11 45465424
01:8E15 D2              	   388: 	db		'R'+80H,"IGHT$"
01:8E16 4947485424
01:8E1B CD              	   389: 	db		'M'+80H,"ID$"
01:8E1C 494424
                        	   390: 
01:8E1F 80              	   391: 	db		80H				; End of list marker
                        	   392: 
                        	   393: ; KEYWORD ADDRESS TABLE
                        	   394: 
                        	   395: WORDTB:
01:8E20 1F94            	   396: 	dw		PEND
01:8E22 1993            	   397: 	dw		FOR
01:8E24 F097            	   398: 	dw		NEXT
01:8E26 6C95            	   399: 	dw		DATAA
01:8E28 F796            	   400: 	dw		INPUT
01:8E2A 2C9A            	   401: 	dw		DIM
01:8E2C 2697            	   402: 	dw		READ
01:8E2E 8395            	   403: 	dw		LET
01:8E30 2995            	   404: 	dw		GOTO
01:8E32 0C95            	   405: 	dw		RUN
01:8E34 FB95            	   406: 	dw		IFF
01:8E36 E293            	   407: 	dw		RESTOR
01:8E38 1895            	   408: 	dw		GOSUB
01:8E3A 4795            	   409: 	dw		RETURN
01:8E3C 6E95            	   410: 	dw		REM
01:8E3E 1D94            	   411: 	dw		STOPP
01:8E40 659F            	   412: 	dw		POUT
01:8E42 DD95            	   413: 	dw		ON
01:8E44 5E94            	   414: 	dw		NULLL
01:8E46 6B9F            	   415: 	dw		WAIT
01:8E48 0A9C            	   416: 	dw		DEF
01:8E4A B49F            	   417: 	dw		POKE
01:8E4C FCA6            	   418: 	dw		DOKE
01:8E4E 6E95            	   419: 	dw		REM
01:8E50 E2A6            	   420: 	dw		LINES
01:8E52 D7A6            	   421: 	dw		CLS
01:8E54 DAA6            	   422: 	dw		WIDTH
01:8E56 16A8            	   423: 	dw		MONITR
01:8E58 5410            	   424: 	dw		PSET
01:8E5A 5710            	   425: 	dw		RESET
01:8E5C 1F96            	   426: 	dw		PRINTT
01:8E5E 4B94            	   427: 	dw		CONT
01:8E60 8E92            	   428: 	dw		LISTT
01:8E62 C694            	   429: 	dw		CLEAR
01:8E64 6E95            	   430: 	dw		REM
01:8E66 6E95            	   431: 	dw		REM
01:8E68 8690            	   432: 	dw		NEW
01:8E6A 30A8            	   433: 	dw		EXIT					; Exit BASIC
                        	   434: 
                        	   435: ; RESERVED WORD TOKEN VALUES
                        	   436: 
                        	   437: ZEND	.EQU	080H			; END
                        	   438: ZFOR	.EQU	081H			; FOR
                        	   439: ZDATA	.EQU	083H			; DATA
                        	   440: ZGOTO	.EQU	088H			; GOTO
                        	   441: ZGOSUB	.EQU	08CH			; GOSUB
                        	   442: ZREM	.EQU	08EH			; REM
                        	   443: ZPRINT	.EQU	09EH			; PRINT
                        	   444: ZNEW	.EQU	0A4H			; NEW
                        	   445: 
                        	   446: ZTAB	.EQU	0A5H			; TAB
                        	   447: ZTO		.EQU	0A6H			; TO
                        	   448: ZFN		.EQU	0A7H			; FN
                        	   449: ZSPC	.EQU	0A8H			; SPC
                        	   450: ZTHEN	.EQU	0A9H			; THEN
                        	   451: ZNOT	.EQU	0AAH			; NOT
                        	   452: ZSTEP	.EQU	0ABH			; STEP
                        	   453: 
                        	   454: ZPLUS	.EQU	0ACH			; +
                        	   455: ZMINUS	.EQU	0ADH			; -
                        	   456: ZTIMES	.EQU	0AEH			; *
                        	   457: ZDIV	.EQU	0AFH			; /
                        	   458: ZOR		.EQU	0B2H			; OR
                        	   459: ZGTR	.EQU	0B3H			; >
                        	   460: ZEQUAL	.EQU	0B4H			; M
                        	   461: ZLTH	.EQU	0B5H			; <
                        	   462: ZSGN	.EQU	0B6H			; SGN
                        	   463: ZPOINT	.EQU	0C7H			; POINT
                        	   464: ZLEFT	.EQU	0CDH +2			; LEFT$
                        	   465: 
                        	   466: ; ARITHMETIC PRECEDENCE TABLE
                        	   467: 
01:8E6C 79              	   468: PRITAB: db		79H				; Precedence value
01:8E6D 9EA3            	   469: 		dw		PADD			; FPREG = <last> + FPREG
                        	   470: 
01:8E6F 79              	   471: 		db		79H				; Precedence value
01:8E70 D29F            	   472: 		dw		PSUB			; FPREG = <last> - FPREG
                        	   473: 
01:8E72 7C              	   474: 		db		7CH				; Precedence value
01:8E73 10A1            	   475: 		dw		MULTT			; PPREG = <last> * FPREG
                        	   476: 
01:8E75 7C              	   477: 		db		7CH				; Precedence value
01:8E76 71A1            	   478: 		dw		DIV				; FPREG = <last> / FPREG
                        	   479: 
01:8E78 7F              	   480: 		db		7FH				; Precedence value
01:8E79 BFA4            	   481: 		dw		POWER			; FPREG = <last> ^ FPREG
                        	   482: 
01:8E7B 50              	   483: 		db		50H				; Precedence value
01:8E7C 8599            	   484: 		dw		PAND			; FPREG = <last> AND FPREG
                        	   485: 
01:8E7E 46              	   486: 		db		46H				; Precedence value
01:8E7F 8499            	   487: 		dw		POR				; FPREG = <last> OR FPREG
                        	   488: 
                        	   489: ; BASIC ERROR CODE LIST
                        	   490: 
01:8E81 4E46            	   491: ERRORS: db		"NF"			; NEXT without FOR
01:8E83 534E            	   492: 		db		"SN"			; Syntax error
01:8E85 5247            	   493: 		db		"RG"			; RETURN without GOSUB
01:8E87 4F44            	   494: 		db		"OD"			; Out of DATA
01:8E89 4643            	   495: 		db		"FC"			; Illegal function call
01:8E8B 4F56            	   496: 		db		"OV"			; Overflow error
01:8E8D 4F4D            	   497: 		db		"OM"			; Out of memory
01:8E8F 554C            	   498: 		db		"UL"			; Undefined line
01:8E91 4253            	   499: 		db		"BS"			; Bad subscript
01:8E93 4444            	   500: 		db		"DD"			; Re-DIMensioned array
01:8E95 2F30            	   501: 		db		"/0"			; Division by zero
01:8E97 4944            	   502: 		db		"ID"			; Illegal direct
01:8E99 544D            	   503: 		db		"TM"			; Type mis-match
01:8E9B 4F53            	   504: 		db		"OS"			; Out of string space
01:8E9D 4C53            	   505: 		db		"LS"			; String too long
01:8E9F 5354            	   506: 		db		"ST"			; String formula too complex
01:8EA1 434E            	   507: 		db		"CN"			; Can't CONTinue
01:8EA3 5546            	   508: 		db		"UF"			; Undefined FN function
01:8EA5 4D4F            	   509: 		db		"MO"			; Missing operand
01:8EA7 4858            	   510: 		db		"HX"			; HEX error
01:8EA9 424E            	   511: 		db		"BN"			; BIN error
                        	   512: 
                        	   513: ; INITIALISATION TABLE -------------------------------------------------------
                        	   514: 
01:8EAB C36C8C          	   515: INITAB: JP		WARM			; Warm start jump
01:8EAE C39C94          	   516: 		JP		FCERR			; "USR (X)" jump (Set to Error)
01:8EB1 D300            	   517: 		OUT		(0),A			; "OUT p,n" skeleton
01:8EB3 C9              	   518: 		RET
01:8EB4 D600            	   519: 		SUB		0				; Division support routine
01:8EB6 6F              	   520: 		LD		L,A
01:8EB7 7C              	   521: 		LD		A,H
01:8EB8 DE00            	   522: 		SBC		A,0
01:8EBA 67              	   523: 		LD		H,A
01:8EBB 78              	   524: 		LD		A,B
01:8EBC DE00            	   525: 		SBC		A,0
01:8EBE 47              	   526: 		LD		B,A
01:8EBF 3E00            	   527: 		LD		A,0
01:8EC1 C9              	   528: 		RET
01:8EC2 00              	   529: 		db		0,0,0					; Random number seed table used by RND
01:8EC3 00
01:8EC4 00
01:8EC5 35              	   530: 		db		035H,04AH,0CAH,099H		;-2.65145E+07
01:8EC6 4A
01:8EC7 CA
01:8EC8 99
01:8EC9 39              	   531: 		db		039H,01CH,076H,098H		; 1.61291E+07
01:8ECA 1C
01:8ECB 76
01:8ECC 98
01:8ECD 22              	   532: 		db		022H,095H,0B3H,098H		;-1.17691E+07
01:8ECE 95
01:8ECF B3
01:8ED0 98
01:8ED1 0A              	   533: 		db		00AH,0DDH,047H,098H		; 1.30983E+07
01:8ED2 DD
01:8ED3 47
01:8ED4 98
01:8ED5 53              	   534: 		db		053H,0D1H,099H,099H		;-2-01612E+07
01:8ED6 D1
01:8ED7 99
01:8ED8 99
01:8ED9 0A              	   535: 		db		00AH,01AH,09FH,098H		;-1.04269E+07
01:8EDA 1A
01:8EDB 9F
01:8EDC 98
01:8EDD 65              	   536: 		db		065H,0BCH,0CDH,098H		;-1.34831E+07
01:8EDE BC
01:8EDF CD
01:8EE0 98
01:8EE1 D6              	   537: 		db		0D6H,077H,03EH,098H		; 1.24825E+07
01:8EE2 77
01:8EE3 3E
01:8EE4 98
01:8EE5 52              	   538: 		db		052H,0C7H,04FH,080H		; Last random number
01:8EE6 C7
01:8EE7 4F
01:8EE8 80
01:8EE9 DB00            	   539: 		IN		A,(0)			; INP (x) skeleton
01:8EEB C9              	   540: 		RET
01:8EEC 01              	   541: 		db		1				; POS (x) number (1)
01:8EED FF              	   542: 		db		255				; Terminal width (255 = no auto CRLF)
01:8EEE 1C              	   543: 		db		28				; Width for commas (3 columns)
01:8EEF 00              	   544: 		db		0				; No nulls after input bytes
01:8EF0 00              	   545: 		db		0				; Output enabled (^O off)
01:8EF1 1400            	   546: 		dw		20				; Initial lines counter
01:8EF3 1400            	   547: 		dw		20				; Initial lines number
01:8EF5 0000            	   548: 		dw		0				; Array load/save check sum
01:8EF7 00              	   549: 		db		0				; Break not by NMI
01:8EF8 00              	   550: 		db		0				; Break flag
01:8EF9 C3BF91          	   551: 		JP		TTYLIN			; Input reflection (set to TTY)
01:8EFC C30000          	   552: 		JP		$0000			; POINT reflection unused
01:8EFF C30000          	   553: 		JP		$0000			; SET reflection
01:8F02 C30000          	   554: 		JP		$0000			; RESET reflection
01:8F05 5D11            	   555: 		dw		STLOOK			; Temp string space
01:8F07 FEFF            	   556: 		dw		-2				; Current line number (cold)
01:8F09 FA10            	   557: 		dw		PROGST+1		; Start of program text
                        	   558: INITBE:							
                        	   559: 
                        	   560: ; END OF INITIALISATION TABLE ---------------------------------------------------
                        	   561: 
01:8F0B 204572726F72    	   562: ERRMSG: db	" Error",0
01:8F11 00
01:8F12 20696E20        	   563: INMSG:	db	" in ",0
01:8F16 00
                        	   564: ZERBYT	.EQU	$-1				; A zero byte
01:8F17 4F6B            	   565: OKMSG:	db	"Ok",CR,LF,0,0
01:8F19 0D
01:8F1A 0A
01:8F1B 00
01:8F1C 00
01:8F1D 427265616B      	   566: BRKMSG: db	"Break",0
01:8F22 00
                        	   567: 
01:8F23 210400          	   568: BAKSTK: LD		HL,4			; Look for "FOR" block with
01:8F26 39              	   569: 		ADD		HL,SP			; same index as specified
01:8F27 7E              	   570: LOKFOR: LD		A,(HL)			; Get block ID
01:8F28 23              	   571: 		INC		HL				; Point to index address
01:8F29 FE81            	   572: 		CP		ZFOR			; Is it a "FOR" token
01:8F2B C0              	   573: 		RET		NZ				; No - exit
01:8F2C 4E              	   574: 		LD		C,(HL)			; BC = Address of "FOR" index
01:8F2D 23              	   575: 		INC		HL
01:8F2E 46              	   576: 		LD		B,(HL)
01:8F2F 23              	   577: 		INC		HL				; Point to sign of STEP
01:8F30 E5              	   578: 		PUSH	HL				; Save pointer to sign
01:8F31 69              	   579: 		LD		L,C				; HL = address of "FOR" index
01:8F32 60              	   580: 		LD		H,B
01:8F33 7A              	   581: 		LD		A,D				; See if an index was specified
01:8F34 B3              	   582: 		OR		E				; DE = 0 if no index specified
01:8F35 EB              	   583: 		EX		DE,HL			; Specified index into HL
01:8F36 CA3D8F          	   584: 		JP		Z,INDFND		; Skip if no index given
01:8F39 EB              	   585: 		EX		DE,HL			; Index back into DE
01:8F3A CD4292          	   586: 		CALL	CPDEHL			; Compare index with one given
01:8F3D 010D00          	   587: INDFND: LD		BC,16-3			; Offset to next block
01:8F40 E1              	   588: 		POP		HL				; Restore pointer to sign
01:8F41 C8              	   589: 		RET		Z				; Return if block found
01:8F42 09              	   590: 		ADD		HL,BC			; Point to next block
01:8F43 C3278F          	   591: 		JP		LOKFOR			; Keep on looking
                        	   592: 
01:8F46 CD608F          	   593: MOVUP:	CALL	ENFMEM			; See if enough memory
01:8F49 C5              	   594: MOVSTR: PUSH	BC				; Save end of source
01:8F4A E3              	   595: 		EX		(SP),HL			; Swap source and dest" end
01:8F4B C1              	   596: 		POP		BC				; Get end of destination
01:8F4C CD4292          	   597: MOVLP:	CALL	CPDEHL			; See if list moved
01:8F4F 7E              	   598: 		LD		A,(HL)			; Get byte
01:8F50 02              	   599: 		LD		(BC),A			; Move it
01:8F51 C8              	   600: 		RET		Z				; Exit if all done
01:8F52 0B              	   601: 		DEC		BC				; Next byte to move to
01:8F53 2B              	   602: 		DEC		HL				; Next byte to move
01:8F54 C34C8F          	   603: 		JP		MOVLP			; Loop until all bytes moved
                        	   604: 
01:8F57 E5              	   605: CHKSTK: PUSH	HL				; Save code string address
01:8F58 2ADA10          	   606: 		LD		HL,(ARREND)		; Lowest free memory
01:8F5B 0600            	   607: 		LD		B,0				; BC = Number of levels to test
01:8F5D 09              	   608: 		ADD		HL,BC			; 2 Bytes for each level
01:8F5E 09              	   609: 		ADD		HL,BC
01:8F5F 3E              	   610: 		db	3EH				; Skip "PUSH HL"
01:8F60 E5              	   611: ENFMEM: PUSH	HL				; Save code string address
01:8F61 3ED0            	   612: 		LD		A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
01:8F63 95              	   613: 		SUB		L
01:8F64 6F              	   614: 		LD		L,A
01:8F65 3EFF            	   615: 		LD		A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
01:8F67 9C              	   616: 		SBC		A,H
01:8F68 DA6F8F          	   617: 		JP		C,OMERR			; Not enough - ?OM Error
01:8F6B 67              	   618: 		LD		H,A
01:8F6C 39              	   619: 		ADD		HL,SP			; Test if stack is overflowed
01:8F6D E1              	   620: 		POP		HL				; Restore code string address
01:8F6E D8              	   621: 		RET		C				; Return if enough mmory
01:8F6F 1E0C            	   622: OMERR:	LD		E,OM			; ?OM Error
01:8F71 C38E8F          	   623: 		JP		ERROR
                        	   624: 
01:8F74 2AC910          	   625: DATSNR: LD		HL,(DATLIN)		; Get line of current DATA item
01:8F77 225C10          	   626: 		LD		(LINEAT),HL		; Save as current line
01:8F7A 1E02            	   627: SNERR:	LD		E,SN			; ?SN Error
01:8F7C 01              	   628: 		db		01H				; Skip "LD E,DZ"
01:8F7D 1E14            	   629: DZERR:	LD		E,DZ			; ?/0 Error
01:8F7F 01              	   630: 		db		01H				; Skip "LD E,NF"
01:8F80 1E00            	   631: NFERR:	LD		E,NF			; ?NF Error
01:8F82 01              	   632: 		db		01H				; Skip "LD E,DD"
01:8F83 1E12            	   633: DDERR:	LD		E,DD			; ?DD Error
01:8F85 01              	   634: 		db		01H				; Skip "LD E,UF"
01:8F86 1E22            	   635: UFERR:	LD		E,UF			; ?UF Error
01:8F88 01              	   636: 		db		01H				; Skip "LD E,OV
01:8F89 1E0A            	   637: OVERR:	LD		E,OV			; ?OV Error
01:8F8B 01              	   638: 		db		01H				; Skip "LD E,TM"
01:8F8C 1E18            	   639: TMERR:	LD		E,TM			; ?TM Error
                        	   640: 
01:8F8E CDAC90          	   641: ERROR:	CALL	CLREG			; Clear registers and stack
01:8F91 324510          	   642: 		LD		(CTLOFG),A		; Enable output (A is 0)
01:8F94 CD7096          	   643: 		CALL	STTLIN			; Start new line
01:8F97 21818E          	   644: 		LD		HL,ERRORS		; Point to error codes
01:8F9A 57              	   645: 		LD		D,A				; D = 0 (A is 0)
01:8F9B 3E3F            	   646: 		LD		A,'?'
01:8F9D CD5392          	   647: 		CALL	OUTC			; Output '?'
01:8FA0 19              	   648: 		ADD		HL,DE			; Offset to correct error code
01:8FA1 7E              	   649: 		LD		A,(HL)			; First character
01:8FA2 CD5392          	   650: 		CALL	OUTC			; Output it
01:8FA5 CDD293          	   651: 		CALL	GETCHR			; Get next character
01:8FA8 CD5392          	   652: 		CALL	OUTC			; Output it
01:8FAB 210B8F          	   653: 		LD		HL,ERRMSG		; "Error" message
01:8FAE CD149D          	   654: ERRIN:	CALL	PRS				; Output message
01:8FB1 2A5C10          	   655: 		LD		HL,(LINEAT)		; Get line of error
01:8FB4 11FEFF          	   656: 		LD		DE,-2			; Cold start error if -2
01:8FB7 CD4292          	   657: 		CALL	CPDEHL			; See if cold start error
01:8FBA CAD98B          	   658: 		JP		Z,CSTART		; Cold start error - Restart
01:8FBD 7C              	   659: 		LD		A,H				; Was it a direct error?
01:8FBE A5              	   660: 		AND		L				; Line = -1 if direct error
01:8FBF 3C              	   661: 		INC		A
01:8FC0 C4AFA3          	   662: 		CALL	NZ,LINEIN		; No - output line of error
01:8FC3 3E              	   663: 		db		3EH				; Skip "POP BC"
01:8FC4 C1              	   664: POPNOK: POP		BC				; Drop address in input buffer
                        	   665: 
01:8FC5 AF              	   666: PRNTOK: XOR		A				; Output "Ok" and get command
01:8FC6 324510          	   667: 		LD		(CTLOFG),A		; Enable output
01:8FC9 CD7096          	   668: 		CALL	STTLIN			; Start new line
01:8FCC 21178F          	   669: 		LD		HL,OKMSG		; "Ok" message
01:8FCF CD149D          	   670: 		CALL	PRS				; Output "Ok"
01:8FD2 21FFFF          	   671: GETCMD: LD		HL,-1			; Flag direct mode
01:8FD5 225C10          	   672: 		LD		(LINEAT),HL		; Save as current line
01:8FD8 CDBF91          	   673: 		CALL	GETLIN			; Get an input line
01:8FDB DAD28F          	   674: 		JP		C,GETCMD		; Get line again if break
01:8FDE CDD293          	   675: 		CALL	GETCHR			; Get first character
01:8FE1 3C              	   676: 		INC		A				; Test if end of line
01:8FE2 3D              	   677: 		DEC		A				; Without affecting Carry
01:8FE3 CAD28F          	   678: 		JP		Z,GETCMD		; Nothing entered - Get another
01:8FE6 F5              	   679: 		PUSH	AF				; Save Carry status
01:8FE7 CDA194          	   680: 		CALL	ATOH			; Get line number into DE
01:8FEA D5              	   681: 		PUSH	DE				; Save line number
01:8FEB CDD690          	   682: 		CALL	CRUNCH			; Tokenise rest of line
01:8FEE 47              	   683: 		LD		B,A				; Length of tokenised line
01:8FEF D1              	   684: 		POP		DE				; Restore line number
01:8FF0 F1              	   685: 		POP		AF				; Restore Carry
01:8FF1 D2B293          	   686: 		JP		NC,EXCUTE		; No line number - Direct mode
01:8FF4 D5              	   687: 		PUSH	DE				; Save line number
01:8FF5 C5              	   688: 		PUSH	BC				; Save length of tokenised line
01:8FF6 AF              	   689: 		XOR		A
01:8FF7 32CC10          	   690: 		LD		(LSTBIN),A		; Clear last byte input
01:8FFA CDD293          	   691: 		CALL	GETCHR			; Get next character
01:8FFD B7              	   692: 		OR		A				; Set flags
01:8FFE F5              	   693: 		PUSH	AF				; And save them
01:8FFF CD6690          	   694: 		CALL	SRCHLN			; Search for line number in DE
01:9002 DA0B90          	   695: 		JP		C,LINFND		; Jump if line found
01:9005 F1              	   696: 		POP		AF				; Get status
01:9006 F5              	   697: 		PUSH	AF				; And re-save
01:9007 CA4295          	   698: 		JP		Z,ULERR			; Nothing after number - Error
01:900A B7              	   699: 		OR		A				; Clear Carry
01:900B C5              	   700: LINFND: PUSH	BC				; Save address of line in prog
01:900C D22290          	   701: 		JP		NC,INEWLN		; Line not found - Insert new
01:900F EB              	   702: 		EX		DE,HL			; Next line address in DE
01:9010 2AD610          	   703: 		LD		HL,(PROGND)		; End of program
01:9013 1A              	   704: SFTPRG: LD		A,(DE)			; Shift rest of program down
01:9014 02              	   705: 		LD		(BC),A
01:9015 03              	   706: 		INC		BC				; Next destination
01:9016 13              	   707: 		INC		DE				; Next source
01:9017 CD4292          	   708: 		CALL	CPDEHL			; All done?
01:901A C21390          	   709: 		JP		NZ,SFTPRG		; More to do
01:901D 60              	   710: 		LD		H,B				; HL - New end of program
01:901E 69              	   711: 		LD		L,C
01:901F 22D610          	   712: 		LD		(PROGND),HL		; Update end of program
                        	   713: 
01:9022 D1              	   714: INEWLN: POP		DE				; Get address of line,
01:9023 F1              	   715: 		POP		AF				; Get status
01:9024 CA4990          	   716: 		JP		Z,SETPTR		; No text - Set up pointers
01:9027 2AD610          	   717: 		LD		HL,(PROGND)		; Get end of program
01:902A E3              	   718: 		EX		(SP),HL			; Get length of input line
01:902B C1              	   719: 		POP		BC				; End of program to BC
01:902C 09              	   720: 		ADD		HL,BC			; Find new end
01:902D E5              	   721: 		PUSH	HL				; Save new end
01:902E CD468F          	   722: 		CALL	MOVUP			; Make space for line
01:9031 E1              	   723: 		POP		HL				; Restore new end
01:9032 22D610          	   724: 		LD		(PROGND),HL		; Update end of program pointer
01:9035 EB              	   725: 		EX		DE,HL			; Get line to move up in HL
01:9036 74              	   726: 		LD		(HL),H			; Save MSB
01:9037 D1              	   727: 		POP		DE				; Get new line number
01:9038 23              	   728: 		INC		HL				; Skip pointer
01:9039 23              	   729: 		INC		HL
01:903A 73              	   730: 		LD		(HL),E			; Save LSB of line number
01:903B 23              	   731: 		INC		HL
01:903C 72              	   732: 		LD		(HL),D			; Save MSB of line number
01:903D 23              	   733: 		INC		HL				; To first byte in line
01:903E 116110          	   734: 		LD		DE,BUFFER		; Copy buffer to program
01:9041 1A              	   735: MOVBUF: LD		A,(DE)			; Get source
01:9042 77              	   736: 		LD		(HL),A			; Save destinations
01:9043 23              	   737: 		INC		HL				; Next source
01:9044 13              	   738: 		INC		DE				; Next destination
01:9045 B7              	   739: 		OR		A				; Done?
01:9046 C24190          	   740: 		JP		NZ,MOVBUF		; No - Repeat
01:9049 CD9290          	   741: SETPTR: CALL	RUNFST			; Set line pointers
01:904C 23              	   742: 		INC		HL				; To LSB of pointer
01:904D EB              	   743: 		EX		DE,HL			; Address to DE
01:904E 62              	   744: PTRLP:	LD		H,D				; Address to HL
01:904F 6B              	   745: 		LD		L,E
01:9050 7E              	   746: 		LD		A,(HL)			; Get LSB of pointer
01:9051 23              	   747: 		INC		HL				; To MSB of pointer
01:9052 B6              	   748: 		OR		(HL)			; Compare with MSB pointer
01:9053 CAD28F          	   749: 		JP		Z,GETCMD		; Get command line if end
01:9056 23              	   750: 		INC		HL				; To LSB of line number
01:9057 23              	   751: 		INC		HL				; Skip line number
01:9058 23              	   752: 		INC		HL				; Point to first byte in line
01:9059 AF              	   753: 		XOR		A				; Looking for 00 byte
01:905A BE              	   754: FNDEND: CP		(HL)			; Found end of line?
01:905B 23              	   755: 		INC		HL				; Move to next byte
01:905C C25A90          	   756: 		JP		NZ,FNDEND		; No - Keep looking
01:905F EB              	   757: 		EX		DE,HL			; Next line address to HL
01:9060 73              	   758: 		LD		(HL),E			; Save LSB of pointer
01:9061 23              	   759: 		INC		HL
01:9062 72              	   760: 		LD		(HL),D			; Save MSB of pointer
01:9063 C34E90          	   761: 		JP		PTRLP			; Do next line
                        	   762: 
01:9066 2A5E10          	   763: SRCHLN: LD		HL,(BASTXT)		; Start of program text
01:9069 44              	   764: SRCHLP: LD		B,H				; BC = Address to look at
01:906A 4D              	   765: 		LD		C,L
01:906B 7E              	   766: 		LD		A,(HL)			; Get address of next line
01:906C 23              	   767: 		INC		HL
01:906D B6              	   768: 		OR		(HL)			; End of program found?
01:906E 2B              	   769: 		DEC		HL
01:906F C8              	   770: 		RET		Z				; Yes - Line not found
01:9070 23              	   771: 		INC		HL
01:9071 23              	   772: 		INC		HL
01:9072 7E              	   773: 		LD		A,(HL)			; Get LSB of line number
01:9073 23              	   774: 		INC		HL
01:9074 66              	   775: 		LD		H,(HL)			; Get MSB of line number
01:9075 6F              	   776: 		LD		L,A
01:9076 CD4292          	   777: 		CALL	CPDEHL			; Compare with line in DE
01:9079 60              	   778: 		LD		H,B				; HL = Start of this line
01:907A 69              	   779: 		LD		L,C
01:907B 7E              	   780: 		LD		A,(HL)			; Get LSB of next line address
01:907C 23              	   781: 		INC		HL
01:907D 66              	   782: 		LD		H,(HL)			; Get MSB of next line address
01:907E 6F              	   783: 		LD		L,A				; Next line to HL
01:907F 3F              	   784: 		CCF
01:9080 C8              	   785: 		RET		Z				; Lines found - Exit
01:9081 3F              	   786: 		CCF
01:9082 D0              	   787: 		RET		NC				; Line not found,at line after
01:9083 C36990          	   788: 		JP		SRCHLP			; Keep looking
                        	   789: 
01:9086 C0              	   790: NEW:	RET		NZ				; Return if any more on line
01:9087 2A5E10          	   791: CLRPTR: LD		HL,(BASTXT)		; Point to start of program
01:908A AF              	   792: 		XOR		A				; Set program area to empty
01:908B 77              	   793: 		LD		(HL),A			; Save LSB = 00
01:908C 23              	   794: 		INC		HL
01:908D 77              	   795: 		LD		(HL),A			; Save MSB = 00
01:908E 23              	   796: 		INC		HL
01:908F 22D610          	   797: 		LD		(PROGND),HL		; Set program end
                        	   798: 
01:9092 2A5E10          	   799: RUNFST: LD		HL,(BASTXT)		; Clear all variables
01:9095 2B              	   800: 		DEC		HL
                        	   801: 
01:9096 22CE10          	   802: INTVAR: LD		(BRKLIN),HL		; Initialise RUN variables
01:9099 2AAF10          	   803: 		LD		HL,(LSTRAM)		; Get end of RAM
01:909C 22C310          	   804: 		LD		(STRBOT),HL		; Clear string space
01:909F AF              	   805: 		XOR		A
01:90A0 CDE293          	   806: 		CALL	RESTOR			; Reset DATA pointers
01:90A3 2AD610          	   807: 		LD		HL,(PROGND)		; Get end of program
01:90A6 22D810          	   808: 		LD		(VAREND),HL		; Clear variables
01:90A9 22DA10          	   809: 		LD		(ARREND),HL		; Clear arrays
                        	   810: 
01:90AC C1              	   811: CLREG:	POP		BC				; Save return address
01:90AD 2A5A10          	   812: 		LD		HL,(STRSPC)		; Get end of working RAN
01:90B0 F9              	   813: 		LD		SP,HL			; Set stack
01:90B1 21B310          	   814: 		LD		HL,TMSTPL		; Temporary string pool
01:90B4 22B110          	   815: 		LD		(TMSTPT),HL		; Reset temporary string ptr
01:90B7 AF              	   816: 		XOR		A				; A = 00
01:90B8 6F              	   817: 		LD		L,A				; HL = 0000
01:90B9 67              	   818: 		LD		H,A
01:90BA 22D410          	   819: 		LD		(CONTAD),HL		; No CONTinue
01:90BD 32CB10          	   820: 		LD		(FORFLG),A		; Clear FOR flag
01:90C0 22DE10          	   821: 		LD		(FNRGNM),HL		; Clear FN argument
01:90C3 E5              	   822: 		PUSH	HL				; HL = 0000
01:90C4 C5              	   823: 		PUSH	BC				; Put back return
01:90C5 2ACE10          	   824: DOAGN:	LD		HL,(BRKLIN)		; Get address of code to RUN
01:90C8 C9              	   825: 		RET						; Return to execution driver
                        	   826: 
01:90C9 3E3F            	   827: PROMPT: LD		A,'?'			; '?'
01:90CB CD5392          	   828: 		CALL	OUTC			; Output character
01:90CE 3E20            	   829: 		LD		A,' '			; Space
01:90D0 CD5392          	   830: 		CALL	OUTC			; Output character
01:90D3 C34E10          	   831: 		JP		RINPUT			; Get input line
                        	   832: 
01:90D6 AF              	   833: CRUNCH: XOR		A				; Tokenise line @ HL to BUFFER
01:90D7 32AE10          	   834: 		LD		(DATFLG),A		; Reset literal flag
01:90DA 0E05            	   835: 		LD		C,2+3			; 2 byte number and 3 nulls
01:90DC 116110          	   836: 		LD		DE,BUFFER		; Start of input buffer
01:90DF 7E              	   837: CRNCLP: LD		A,(HL)			; Get byte
01:90E0 FE20            	   838: 		CP		' '				; Is it a space?
01:90E2 CA5E91          	   839: 		JP		Z,MOVDIR		; Yes - Copy direct
01:90E5 47              	   840: 		LD		B,A				; Save character
01:90E6 FE22            	   841: 		CP		'"'				; Is it a quote?"
01:90E8 CA7E91          	   842: 		JP		Z,CPYLIT		; Yes - Copy literal string
01:90EB B7              	   843: 		OR		A				; Is it end of buffer?
01:90EC CA8591          	   844: 		JP		Z,ENDBUF		; Yes - End buffer
01:90EF 3AAE10          	   845: 		LD		A,(DATFLG)		; Get data type
01:90F2 B7              	   846: 		OR		A				; Literal?
01:90F3 7E              	   847: 		LD		A,(HL)			; Get byte to copy
01:90F4 C25E91          	   848: 		JP		NZ,MOVDIR		; Literal - Copy direct
01:90F7 FE3F            	   849: 		CP		'?'				; Is it '?' short for PRINT
01:90F9 3E9E            	   850: 		LD		A,ZPRINT		; "PRINT" token
01:90FB CA5E91          	   851: 		JP		Z,MOVDIR		; Yes - replace it
01:90FE 7E              	   852: 		LD		A,(HL)			; Get byte again
01:90FF FE30            	   853: 		CP		'0'				; Is it less than '0'
01:9101 DA0991          	   854: 		JP		C,FNDWRD		; Yes - Look for reserved words
01:9104 FE3C            	   855: 		CP		60; ";"+1			; Is it "0123456789:;" ?
01:9106 DA5E91          	   856: 		JP		C,MOVDIR		; Yes - copy it direct
01:9109 D5              	   857: FNDWRD: PUSH	DE				; Look for reserved words
01:910A 11FC8C          	   858: 		LD		DE,WORDS-1		; Point to table
01:910D C5              	   859: 		PUSH	BC				; Save count
01:910E 015A91          	   860: 		LD		BC,RETNAD		; Where to return to
01:9111 C5              	   861: 		PUSH	BC				; Save return address
01:9112 067F            	   862: 		LD		B,ZEND-1		; First token value -1
01:9114 7E              	   863: 		LD		A,(HL)			; Get byte
01:9115 FE61            	   864: 		CP		'a'				; Less than 'a' ?
01:9117 DA2291          	   865: 		JP		C,SEARCH		; Yes - search for words
01:911A FE7B            	   866: 		CP		'z'+1			; Greater than 'z' ?
01:911C D22291          	   867: 		JP		NC,SEARCH		; Yes - search for words
01:911F E65F            	   868: 		AND		01011111B		; Force upper case
01:9121 77              	   869: 		LD		(HL),A			; Replace byte
01:9122 4E              	   870: SEARCH: LD		C,(HL)			; Search for a word
01:9123 EB              	   871: 		EX		DE,HL
01:9124 23              	   872: GETNXT: INC		HL				; Get next reserved word
01:9125 B6              	   873: 		OR		(HL)			; Start of word?
01:9126 F22491          	   874: 		JP		P,GETNXT		; No - move on
01:9129 04              	   875: 		INC		B				; Increment token value
01:912A 7E              	   876: 		LD		A, (HL)			; Get byte from table
01:912B E67F            	   877: 		AND		01111111B		; Strip bit 7
01:912D C8              	   878: 		RET		Z				; Return if end of list
01:912E B9              	   879: 		CP		C				; Same character as in buffer?
01:912F C22491          	   880: 		JP		NZ,GETNXT		; No - get next word
01:9132 EB              	   881: 		EX		DE,HL
01:9133 E5              	   882: 		PUSH	HL				; Save start of word
                        	   883: 
01:9134 13              	   884: NXTBYT: INC		DE				; Look through rest of word
01:9135 1A              	   885: 		LD		A,(DE)			; Get byte from table
01:9136 B7              	   886: 		OR		A				; End of word ?
01:9137 FA5691          	   887: 		JP		M,MATCH			; Yes - Match found
01:913A 4F              	   888: 		LD		C,A				; Save it
01:913B 78              	   889: 		LD		A,B				; Get token value
01:913C FE88            	   890: 		CP		ZGOTO			; Is it "GOTO" token ?
01:913E C24591          	   891: 		JP		NZ,NOSPC		; No - Don't allow spaces
01:9141 CDD293          	   892: 		CALL	GETCHR			; Get next character
01:9144 2B              	   893: 		DEC		HL				; Cancel increment from GETCHR
01:9145 23              	   894: NOSPC:	INC		HL				; Next byte
01:9146 7E              	   895: 		LD		A,(HL)			; Get byte
01:9147 FE61            	   896: 		CP		'a'				; Less than 'a' ?
01:9149 DA4E91          	   897: 		JP		C,NOCHNG		; Yes - don't change
01:914C E65F            	   898: 		AND		01011111B		; Make upper case
01:914E B9              	   899: NOCHNG: CP		C				; Same as in buffer ?
01:914F CA3491          	   900: 		JP		Z,NXTBYT		; Yes - keep testing
01:9152 E1              	   901: 		POP		HL				; Get back start of word
01:9153 C32291          	   902: 		JP		SEARCH			; Look at next word
                        	   903: 
01:9156 48              	   904: MATCH:	LD		C,B				; Word found - Save token value
01:9157 F1              	   905: 		POP		AF				; Throw away return
01:9158 EB              	   906: 		EX		DE,HL
01:9159 C9              	   907: 		RET						; Return to "RETNAD"
01:915A EB              	   908: RETNAD: EX		DE,HL			; Get address in string
01:915B 79              	   909: 		LD		A,C				; Get token value
01:915C C1              	   910: 		POP		BC				; Restore buffer length
01:915D D1              	   911: 		POP		DE				; Get destination address
01:915E 23              	   912: MOVDIR: INC		HL				; Next source in buffer
01:915F 12              	   913: 		LD		(DE),A			; Put byte in buffer
01:9160 13              	   914: 		INC		DE				; Move up buffer
01:9161 0C              	   915: 		INC		C				; Increment length of buffer
01:9162 D63A            	   916: 		SUB		':'				; End of statement?
01:9164 CA6C91          	   917: 		JP		Z,SETLIT		; Jump if multi-statement line
01:9167 FE49            	   918: 		CP		ZDATA-3AH		; Is it DATA statement ?
01:9169 C26F91          	   919: 		JP		NZ,TSTREM		; No - see if REM
01:916C 32AE10          	   920: SETLIT: LD		(DATFLG),A		; Set literal flag
01:916F D654            	   921: TSTREM: SUB		ZREM-3AH		; Is it REM?
01:9171 C2DF90          	   922: 		JP		NZ,CRNCLP		; No - Leave flag
01:9174 47              	   923: 		LD		B,A				; Copy rest of buffer
01:9175 7E              	   924: NXTCHR: LD		A,(HL)			; Get byte
01:9176 B7              	   925: 		OR		A				; End of line ?
01:9177 CA8591          	   926: 		JP		Z,ENDBUF		; Yes - Terminate buffer
01:917A B8              	   927: 		CP		B				; End of statement ?
01:917B CA5E91          	   928: 		JP		Z,MOVDIR		; Yes - Get next one
01:917E 23              	   929: CPYLIT: INC		HL				; Move up source string
01:917F 12              	   930: 		LD		(DE),A			; Save in destination
01:9180 0C              	   931: 		INC		C				; Increment length
01:9181 13              	   932: 		INC		DE				; Move up destination
01:9182 C37591          	   933: 		JP		NXTCHR			; Repeat
                        	   934: 
01:9185 216010          	   935: ENDBUF: LD		HL,BUFFER-1		; Point to start of buffer
01:9188 12              	   936: 		LD		(DE),A			; Mark end of buffer (A = 00)
01:9189 13              	   937: 		INC		DE
01:918A 12              	   938: 		LD		(DE),A			; A = 00
01:918B 13              	   939: 		INC		DE
01:918C 12              	   940: 		LD		(DE),A			; A = 00
01:918D C9              	   941: 		RET
                        	   942: 
01:918E 3A4410          	   943: DODEL:	LD		A,(NULFLG)		; Get null flag status
01:9191 B7              	   944: 		OR		A				; Is it zero?
01:9192 3E00            	   945: 		LD		A,0				; Zero A - Leave flags
01:9194 324410          	   946: 		LD		(NULFLG),A		; Zero null flag
01:9197 C2A291          	   947: 		JP		NZ,ECHDEL		; Set - Echo it
01:919A 05              	   948: 		DEC		B				; Decrement length
01:919B CABF91          	   949: 		JP		Z,GETLIN		; Get line again if empty
01:919E CD5392          	   950: 		CALL	OUTC			; Output null character
01:91A1 3E              	   951: 		db	3EH				; Skip "DEC B"
01:91A2 05              	   952: ECHDEL: DEC		B				; Count bytes in buffer
01:91A3 2B              	   953: 		DEC		HL				; Back space buffer
01:91A4 CAB691          	   954: 		JP		Z,OTKLN			; No buffer - Try again
01:91A7 7E              	   955: 		LD		A,(HL)			; Get deleted byte
01:91A8 CD5392          	   956: 		CALL	OUTC			; Echo it
01:91AB C3C891          	   957: 		JP		MORINP			; Get more input
                        	   958: 
01:91AE 05              	   959: DELCHR: DEC		B				; Count bytes in buffer
01:91AF 2B              	   960: 		DEC		HL				; Back space buffer
01:91B0 CD5392          	   961: 		CALL	OUTC			; Output character in A
01:91B3 C2C891          	   962: 		JP		NZ,MORINP		; Not end - Get more
01:91B6 CD5392          	   963: OTKLN:	CALL	OUTC			; Output character in A
01:91B9 CD8180          	   964: KILIN:	CALL	PrintCRLF		; Output CRLF
01:91BC C3BF91          	   965: 		JP		TTYLIN			; Get line again
                        	   966: 
                        	   967: GETLIN:
01:91BF 216110          	   968: TTYLIN: LD		HL,BUFFER		; Get a line by character
01:91C2 0601            	   969: 		LD		B,1				; Set buffer as empty
01:91C4 AF              	   970: 		XOR		A
01:91C5 324410          	   971: 		LD		(NULFLG),A		; Clear null flag
01:91C8 CD7D92          	   972: MORINP: CALL	CLOTST			; Get character and test ^O
01:91CB 4F              	   973: 		LD		C,A				; Save character in C
01:91CC FE7F            	   974: 		CP		DEL				; Delete character?
01:91CE CA8E91          	   975: 		JP		Z,DODEL			; Yes - Process it
01:91D1 3A4410          	   976: 		LD		A,(NULFLG)		; Get null flag
01:91D4 B7              	   977: 		OR		A				; Test null flag status
01:91D5 CAE191          	   978: 		JP		Z,PROCES		; Reset - Process character
01:91D8 3E00            	   979: 		LD		A,0				; Set a null
01:91DA CD5392          	   980: 		CALL	OUTC			; Output null
01:91DD AF              	   981: 		XOR		A				; Clear A
01:91DE 324410          	   982: 		LD		(NULFLG),A		; Reset null flag
01:91E1 79              	   983: PROCES: LD		A,C				; Get character
01:91E2 FE07            	   984: 		CP		CTRLG			; Bell?
01:91E4 CA2592          	   985: 		JP		Z,PUTCTL		; Yes - Save it
01:91E7 FE03            	   986: 		CP		CTRLC			; Is it control "C"?
01:91E9 CC8180          	   987: 		CALL	Z,PrintCRLF		; Yes - Output CRLF
01:91EC 37              	   988: 		SCF						; Flag break
01:91ED C8              	   989: 		RET		Z				; Return if control "C"
01:91EE FE0D            	   990: 		CP		CR				; Is it enter?
01:91F0 CA7896          	   991: 		JP		Z,ENDINP		; Yes - Terminate input
01:91F3 FE15            	   992: 		CP		CTRLU			; Is it control "U"?
01:91F5 CAB991          	   993: 		JP		Z,KILIN			; Yes - Get another line
01:91F8 FE40            	   994: 		CP		'@'				; Is it "kill line"?
01:91FA CAB691          	   995: 		JP		Z,OTKLN			; Yes - Kill line
01:91FD FE5F            	   996: 		CP		'_'				; Is it delete?
01:91FF CAAE91          	   997: 		JP		Z,DELCHR		; Yes - Delete character
01:9202 FE08            	   998: 		CP		BKSP			; Is it backspace?
01:9204 CAAE91          	   999: 		JP		Z,DELCHR		; Yes - Delete character
01:9207 FE12            	  1000: 		CP		CTRLR			; Is it control "R"?
01:9209 C22092          	  1001: 		JP		NZ,PUTBUF		; No - Put in buffer
01:920C C5              	  1002: 		PUSH	BC				; Save buffer length
01:920D D5              	  1003: 		PUSH	DE				; Save DE
01:920E E5              	  1004: 		PUSH	HL				; Save buffer address
01:920F 3600            	  1005: 		LD		(HL),0			; Mark end of buffer
01:9211 CD2AA8          	  1006: 		CALL	OUTNCR			; Output and do CRLF
01:9214 216110          	  1007: 		LD		HL,BUFFER		; Point to buffer start
01:9217 CD149D          	  1008: 		CALL	PRS				; Output buffer
01:921A E1              	  1009: 		POP		HL				; Restore buffer address
01:921B D1              	  1010: 		POP		DE				; Restore DE
01:921C C1              	  1011: 		POP		BC				; Restore buffer length
01:921D C3C891          	  1012: 		JP		MORINP			; Get another character
                        	  1013: 
01:9220 FE20            	  1014: PUTBUF: CP		' '				; Is it a control code?
01:9222 DAC891          	  1015: 		JP		C,MORINP		; Yes - Ignore
01:9225 78              	  1016: PUTCTL: LD		A,B				; Get number of bytes in buffer
01:9226 FE49            	  1017: 		CP		72+1			; Test for line overflow
01:9228 3E07            	  1018: 		LD		A,CTRLG			; Set a bell
01:922A D23A92          	  1019: 		JP		NC,OUTNBS		; Ring bell if buffer full
01:922D 79              	  1020: 		LD		A,C				; Get character
01:922E 71              	  1021: 		LD		(HL),C			; Save in buffer
01:922F 32CC10          	  1022: 		LD		(LSTBIN),A		; Save last input byte
01:9232 23              	  1023: 		INC		HL				; Move up buffer
01:9233 04              	  1024: 		INC		B				; Increment length
01:9234 CD5392          	  1025: OUTIT:	CALL	OUTC			; Output the character entered
01:9237 C3C891          	  1026: 		JP		MORINP			; Get another character
                        	  1027: 
01:923A CD5392          	  1028: OUTNBS: CALL	OUTC			; Output bell and back over it
01:923D 3E08            	  1029: 		LD		A,BKSP			; Set back space
01:923F C33492          	  1030: 		JP		OUTIT			; Output it and get more
                        	  1031: 
01:9242 7C              	  1032: CPDEHL: LD		A,H				; Get H
01:9243 92              	  1033: 		SUB		D				; Compare with D
01:9244 C0              	  1034: 		RET		NZ				; Different - Exit
01:9245 7D              	  1035: 		LD		A,L				; Get L
01:9246 93              	  1036: 		SUB		E				; Compare with E
01:9247 C9              	  1037: 		RET						; Return status
                        	  1038: 
01:9248 7E              	  1039: CHKSYN: LD		A,(HL)			; Check syntax of character
01:9249 E3              	  1040: 		EX		(SP),HL			; Address of test byte
01:924A BE              	  1041: 		CP		(HL)			; Same as in code string?
01:924B 23              	  1042: 		INC		HL				; Return address
01:924C E3              	  1043: 		EX		(SP),HL			; Put it back
01:924D CAD293          	  1044: 		JP		Z,GETCHR		; Yes - Get next character
01:9250 C37A8F          	  1045: 		JP		SNERR			; Different - ?SN Error
                        	  1046: 
01:9253 F5              	  1047: OUTC:	PUSH	AF				; Save character
01:9254 3A4510          	  1048: 		LD		A,(CTLOFG)		; Get control "O" flag
01:9257 B7              	  1049: 		OR		A				; Is it set?
01:9258 C2499D          	  1050: 		JP		NZ,POPAF		; Yes - don't output
01:925B F1              	  1051: 		POP		AF				; Restore character
01:925C C5              	  1052: 		PUSH	BC				; Save buffer length
01:925D F5              	  1053: 		PUSH	AF				; Save character
01:925E FE20            	  1054: 		CP		' '				; Is it a control code?
01:9260 DA7792          	  1055: 		JP		C,DINPOS		; Yes - Don't INC POS(X)
01:9263 3A4210          	  1056: 		LD		A,(LWIDTH)		; Get line width
01:9266 47              	  1057: 		LD		B,A				; To B
01:9267 3AAB10          	  1058: 		LD		A,(CURPOS)		; Get cursor position
01:926A 04              	  1059: 		INC		B				; Width 255?
01:926B CA7392          	  1060: 		JP		Z,INCLEN		; Yes - No width limit
01:926E 05              	  1061: 		DEC		B				; Restore width
01:926F B8              	  1062: 		CP		B				; At end of line?
01:9270 CC8180          	  1063: 		CALL	Z,PrintCRLF		; Yes - output CRLF
01:9273 3C              	  1064: INCLEN: INC		A				; Move on one character
01:9274 32AB10          	  1065: 		LD		(CURPOS),A		; Save new position
01:9277 F1              	  1066: DINPOS: POP		AF				; Restore character
01:9278 C1              	  1067: 		POP		BC				; Restore buffer length
01:9279 CD13A8          	  1068: 		CALL	MONOUT			; Send it
01:927C C9              	  1069: 		RET
                        	  1070: 
01:927D CDD3A6          	  1071: CLOTST: CALL	GETINP			; Get input character
01:9280 E67F            	  1072: 		AND		01111111B		; Strip bit 7
01:9282 FE0F            	  1073: 		CP		CTRLO			; Is it control "O"?
01:9284 C0              	  1074: 		RET		NZ				; No don't flip flag
01:9285 3A4510          	  1075: 		LD		A,(CTLOFG)		; Get flag
01:9288 2F              	  1076: 		CPL						; Flip it
01:9289 324510          	  1077: 		LD		(CTLOFG),A		; Put it back
01:928C AF              	  1078: 		XOR		A				; Null character
01:928D C9              	  1079: 		RET
                        	  1080: 
01:928E CDA194          	  1081: LISTT:	CALL	ATOH			; ASCII number to DE
01:9291 C0              	  1082: 		RET		NZ				; Return if anything extra
01:9292 C1              	  1083: 		POP		BC				; Rubbish - Not needed
01:9293 CD6690          	  1084: 		CALL	SRCHLN			; Search for line number in DE
01:9296 C5              	  1085: 		PUSH	BC				; Save address of line
01:9297 CDE492          	  1086: 		CALL	SETLIN			; Set up lines counter
01:929A E1              	  1087: LISTLP: POP		HL				; Restore address of line
01:929B 4E              	  1088: 		LD		C,(HL)			; Get LSB of next line
01:929C 23              	  1089: 		INC		HL
01:929D 46              	  1090: 		LD		B,(HL)			; Get MSB of next line
01:929E 23              	  1091: 		INC		HL
01:929F 78              	  1092: 		LD		A,B				; BC = 0 (End of program)?
01:92A0 B1              	  1093: 		OR		C
01:92A1 CAC58F          	  1094: 		JP		Z,PRNTOK		; Yes - Go to command mode
01:92A4 CDED92          	  1095: 		CALL	COUNT			; Count lines
01:92A7 CDFD93          	  1096: 		CALL	TSTBRK			; Test for break key
01:92AA C5              	  1097: 		PUSH	BC				; Save address of next line
01:92AB CD8180          	  1098: 		CALL	PrintCRLF		; Output CRLF
01:92AE 5E              	  1099: 		LD		E,(HL)			; Get LSB of line number
01:92AF 23              	  1100: 		INC		HL
01:92B0 56              	  1101: 		LD		D,(HL)			; Get MSB of line number
01:92B1 23              	  1102: 		INC		HL
01:92B2 E5              	  1103: 		PUSH	HL				; Save address of line start
01:92B3 EB              	  1104: 		EX		DE,HL			; Line number to HL
01:92B4 CDB7A3          	  1105: 		CALL	PRNTHL			; Output line number in decimal
01:92B7 3E20            	  1106: 		LD		A,' '			; Space after line number
01:92B9 E1              	  1107: 		POP		HL				; Restore start of line address
01:92BA CD5392          	  1108: LSTLP2: CALL	OUTC			; Output character in A
01:92BD 7E              	  1109: LSTLP3: LD		A,(HL)			; Get next byte in line
01:92BE B7              	  1110: 		OR		A				; End of line?
01:92BF 23              	  1111: 		INC		HL				; To next byte in line
01:92C0 CA9A92          	  1112: 		JP		Z,LISTLP		; Yes - get next line
01:92C3 F2BA92          	  1113: 		JP		P,LSTLP2		; No token - output it
01:92C6 D67F            	  1114: 		SUB		ZEND-1			; Find and output word
01:92C8 4F              	  1115: 		LD		C,A				; Token offset+1 to C
01:92C9 11FD8C          	  1116: 		LD		DE,WORDS		; Reserved word list
01:92CC 1A              	  1117: FNDTOK: LD		A,(DE)			; Get character in list
01:92CD 13              	  1118: 		INC		DE				; Move on to next
01:92CE B7              	  1119: 		OR		A				; Is it start of word?
01:92CF F2CC92          	  1120: 		JP		P,FNDTOK		; No - Keep looking for word
01:92D2 0D              	  1121: 		DEC		C				; Count words
01:92D3 C2CC92          	  1122: 		JP		NZ,FNDTOK		; Not there - keep looking
01:92D6 E67F            	  1123: OUTWRD: AND		01111111B		; Strip bit 7
01:92D8 CD5392          	  1124: 		CALL	OUTC			; Output first character
01:92DB 1A              	  1125: 		LD		A,(DE)			; Get next character
01:92DC 13              	  1126: 		INC		DE				; Move on to next
01:92DD B7              	  1127: 		OR		A				; Is it end of word?
01:92DE F2D692          	  1128: 		JP		P,OUTWRD		; No - output the rest
01:92E1 C3BD92          	  1129: 		JP		LSTLP3			; Next byte in line
                        	  1130: 
01:92E4 E5              	  1131: SETLIN: PUSH	HL				; Set up LINES counter
01:92E5 2A4810          	  1132: 		LD		HL,(LINESN)		; Get LINES number
01:92E8 224610          	  1133: 		LD		(LINESC),HL		; Save in LINES counter
01:92EB E1              	  1134: 		POP		HL
01:92EC C9              	  1135: 		RET
                        	  1136: 
01:92ED E5              	  1137: COUNT:	PUSH	HL				; Save code string address
01:92EE D5              	  1138: 		PUSH	DE
01:92EF 2A4610          	  1139: 		LD		HL,(LINESC)		; Get LINES counter
01:92F2 11FFFF          	  1140: 		LD		DE,-1
01:92F5 ED5A            	  1141: 		ADC		HL,DE			; Decrement
01:92F7 224610          	  1142: 		LD		(LINESC),HL		; Put it back
01:92FA D1              	  1143: 		POP		DE
01:92FB E1              	  1144: 		POP		HL				; Restore code string address
01:92FC F0              	  1145: 		RET		P				; Return if more lines to go
01:92FD E5              	  1146: 		PUSH	HL				; Save code string address
01:92FE 2A4810          	  1147: 		LD		HL,(LINESN)		; Get LINES number
01:9301 224610          	  1148: 		LD		(LINESC),HL		; Reset LINES counter
01:9304 CDD3A6          	  1149: 		CALL	GETINP			; Get input character
01:9307 FE03            	  1150: 		CP		CTRLC			; Is it control "C"?
01:9309 CA1093          	  1151: 		JP		Z,RSLNBK		; Yes - Reset LINES and break
01:930C E1              	  1152: 		POP		HL				; Restore code string address
01:930D C3ED92          	  1153: 		JP		COUNT			; Keep on counting
                        	  1154: 
01:9310 2A4810          	  1155: RSLNBK: LD		HL,(LINESN)		; Get LINES number
01:9313 224610          	  1156: 		LD		(LINESC),HL		; Reset LINES counter
01:9316 C36F8C          	  1157: 		JP		BRKRET			; Go and output "Break"
                        	  1158: 
01:9319 3E64            	  1159: FOR:	LD		A,64H			; Flag "FOR" assignment
01:931B 32CB10          	  1160: 		LD		(FORFLG),A		; Save "FOR" flag
01:931E CD8395          	  1161: 		CALL	LET				; Set up initial index
01:9321 C1              	  1162: 		POP		BC				; Drop RETurn address
01:9322 E5              	  1163: 		PUSH	HL				; Save code string address
01:9323 CD6C95          	  1164: 		CALL	DATAA			; Get next statement address
01:9326 22C710          	  1165: 		LD		(LOOPST),HL		; Save it for start of loop
01:9329 210200          	  1166: 		LD		HL,2			; Offset for "FOR" block
01:932C 39              	  1167: 		ADD		HL,SP			; Point to it
01:932D CD278F          	  1168: FORSLP: CALL	LOKFOR			; Look for existing "FOR" block
01:9330 D1              	  1169: 		POP		DE				; Get code string address
01:9331 C24993          	  1170: 		JP		NZ,FORFND		; No nesting found
01:9334 09              	  1171: 		ADD		HL,BC			; Move into "FOR" block
01:9335 D5              	  1172: 		PUSH	DE				; Save code string address
01:9336 2B              	  1173: 		DEC		HL
01:9337 56              	  1174: 		LD		D,(HL)			; Get MSB of loop statement
01:9338 2B              	  1175: 		DEC		HL
01:9339 5E              	  1176: 		LD		E,(HL)			; Get LSB of loop statement
01:933A 23              	  1177: 		INC		HL
01:933B 23              	  1178: 		INC		HL
01:933C E5              	  1179: 		PUSH	HL				; Save block address
01:933D 2AC710          	  1180: 		LD		HL,(LOOPST)		; Get address of loop statement
01:9340 CD4292          	  1181: 		CALL	CPDEHL			; Compare the FOR loops
01:9343 E1              	  1182: 		POP		HL				; Restore block address
01:9344 C22D93          	  1183: 		JP		NZ,FORSLP		; Different FORs - Find another
01:9347 D1              	  1184: 		POP		DE				; Restore code string address
01:9348 F9              	  1185: 		LD		SP,HL			; Remove all nested loops
                        	  1186: 
01:9349 EB              	  1187: FORFND: EX		DE,HL			; Code string address to HL
01:934A 0E08            	  1188: 		LD		C,8
01:934C CD578F          	  1189: 		CALL	CHKSTK			; Check for 8 levels of stack
01:934F E5              	  1190: 		PUSH	HL				; Save code string address
01:9350 2AC710          	  1191: 		LD		HL,(LOOPST)		; Get first statement of loop
01:9353 E3              	  1192: 		EX		(SP),HL			; Save and restore code string
01:9354 E5              	  1193: 		PUSH	HL				; Re-save code string address
01:9355 2A5C10          	  1194: 		LD		HL,(LINEAT)		; Get current line number
01:9358 E3              	  1195: 		EX		(SP),HL			; Save and restore code string
01:9359 CD3E98          	  1196: 		CALL	TSTNUM			; Make sure it's a number
01:935C CD4892          	  1197: 		CALL	CHKSYN			; Make sure "TO" is next
01:935F A6              	  1198: 		db	ZTO			 ; "TO" token
01:9360 CD3B98          	  1199: 		CALL	GETNUM			; Get "TO" expression value
01:9363 E5              	  1200: 		PUSH	HL				; Save code string address
01:9364 CD69A2          	  1201: 		CALL	BCDEFP			; Move "TO" value to BCDE
01:9367 E1              	  1202: 		POP		HL				; Restore code string address
01:9368 C5              	  1203: 		PUSH	BC				; Save "TO" value in block
01:9369 D5              	  1204: 		PUSH	DE
01:936A 010081          	  1205: 		LD		BC,8100H		; BCDE - 1 (default STEP)
01:936D 51              	  1206: 		LD		D,C				; C=0
01:936E 5A              	  1207: 		LD		E,D				; D=0
01:936F 7E              	  1208: 		LD		A,(HL)			; Get next byte in code string
01:9370 FEAB            	  1209: 		CP		ZSTEP			; See if "STEP" is stated
01:9372 3E01            	  1210: 		LD		A,1				; Sign of step = 1
01:9374 C28593          	  1211: 		JP		NZ,SAVSTP		; No STEP given - Default to 1
01:9377 CDD293          	  1212: 		CALL	GETCHR			; Jump over "STEP" token
01:937A CD3B98          	  1213: 		CALL	GETNUM			; Get step value
01:937D E5              	  1214: 		PUSH	HL				; Save code string address
01:937E CD69A2          	  1215: 		CALL	BCDEFP			; Move STEP to BCDE
01:9381 CD1DA2          	  1216: 		CALL	TSTSGN			; Test sign of FPREG
01:9384 E1              	  1217: 		POP		HL				; Restore code string address
01:9385 C5              	  1218: SAVSTP: PUSH	BC				; Save the STEP value in block
01:9386 D5              	  1219: 		PUSH	DE
01:9387 F5              	  1220: 		PUSH	AF				; Save sign of STEP
01:9388 33              	  1221: 		INC		SP				; Don't save flags
01:9389 E5              	  1222: 		PUSH	HL				; Save code string address
01:938A 2ACE10          	  1223: 		LD		HL,(BRKLIN)		; Get address of index variable
01:938D E3              	  1224: 		EX		(SP),HL			; Save and restore code string
01:938E 0681            	  1225: PUTFID: LD		B,ZFOR			; "FOR" block marker
01:9390 C5              	  1226: 		PUSH	BC				; Save it
01:9391 33              	  1227: 		INC		SP				; Don't save C
                        	  1228: 
01:9392 CDFD93          	  1229: RUNCNT: CALL	TSTBRK			; Execution driver - Test break
01:9395 22CE10          	  1230: 		LD		(BRKLIN),HL		; Save code address for break
01:9398 7E              	  1231: 		LD		A,(HL)			; Get next byte in code string
01:9399 FE3A            	  1232: 		CP		':'				; Multi statement line?
01:939B CAB293          	  1233: 		JP		Z,EXCUTE		; Yes - Execute it
01:939E B7              	  1234: 		OR		A				; End of line?
01:939F C27A8F          	  1235: 		JP		NZ,SNERR		; No - Syntax error
01:93A2 23              	  1236: 		INC		HL				; Point to address of next line
01:93A3 7E              	  1237: 		LD		A,(HL)			; Get LSB of line pointer
01:93A4 23              	  1238: 		INC		HL
01:93A5 B6              	  1239: 		OR		(HL)			; Is it zero (End of prog)?
01:93A6 CA2794          	  1240: 		JP		Z,ENDPRG		; Yes - Terminate execution
01:93A9 23              	  1241: 		INC		HL				; Point to line number
01:93AA 5E              	  1242: 		LD		E,(HL)			; Get LSB of line number
01:93AB 23              	  1243: 		INC		HL
01:93AC 56              	  1244: 		LD		D,(HL)			; Get MSB of line number
01:93AD EB              	  1245: 		EX		DE,HL			; Line number to HL
01:93AE 225C10          	  1246: 		LD		(LINEAT),HL		; Save as current line number
01:93B1 EB              	  1247: 		EX		DE,HL			; Line number back to DE
01:93B2 CDD293          	  1248: EXCUTE: CALL	GETCHR			; Get key word
01:93B5 119293          	  1249: 		LD		DE,RUNCNT		; Where to RETurn to
01:93B8 D5              	  1250: 		PUSH	DE				; Save for RETurn
01:93B9 C8              	  1251: IFJMP:	RET		Z				; Go to RUNCNT if end of STMT
01:93BA D680            	  1252: ONJMP:	SUB		ZEND			; Is it a token?
01:93BC DA8395          	  1253: 		JP		C,LET			; No - try to assign it
01:93BF FE25            	  1254: 		CP		ZNEW+1-ZEND		; END to NEW ?
01:93C1 D27A8F          	  1255: 		JP		NC,SNERR		; Not a key word - ?SN Error
01:93C4 07              	  1256: 		RLCA					; Double it
01:93C5 4F              	  1257: 		LD		C,A				; BC = Offset into table
01:93C6 0600            	  1258: 		LD		B,0
01:93C8 EB              	  1259: 		EX		DE,HL			; Save code string address
01:93C9 21208E          	  1260: 		LD		HL,WORDTB		; Keyword address table
01:93CC 09              	  1261: 		ADD		HL,BC			; Point to routine address
01:93CD 4E              	  1262: 		LD		C,(HL)			; Get LSB of routine address
01:93CE 23              	  1263: 		INC		HL
01:93CF 46              	  1264: 		LD		B,(HL)			; Get MSB of routine address
01:93D0 C5              	  1265: 		PUSH	BC				; Save routine address
01:93D1 EB              	  1266: 		EX		DE,HL			; Restore code string address
                        	  1267: 
01:93D2 23              	  1268: GETCHR: INC		HL				; Point to next character
01:93D3 7E              	  1269: 		LD		A,(HL)			; Get next code string byte
01:93D4 FE3A            	  1270: 		CP		':'				; Z if ':'
01:93D6 D0              	  1271: 		RET		NC				; NC if > "9"
01:93D7 FE20            	  1272: 		CP		' '
01:93D9 CAD293          	  1273: 		JP		Z,GETCHR		; Skip over spaces
01:93DC FE30            	  1274: 		CP		'0'
01:93DE 3F              	  1275: 		CCF						; NC if < '0'
01:93DF 3C              	  1276: 		INC		A				; Test for zero - Leave carry
01:93E0 3D              	  1277: 		DEC		A				; Z if Null
01:93E1 C9              	  1278: 		RET
                        	  1279: 
01:93E2 EB              	  1280: RESTOR: EX		DE,HL			; Save code string address
01:93E3 2A5E10          	  1281: 		LD		HL,(BASTXT)		; Point to start of program
01:93E6 CAF793          	  1282: 		JP		Z,RESTNL		; Just RESTORE - reset pointer
01:93E9 EB              	  1283: 		EX		DE,HL			; Restore code string address
01:93EA CDA194          	  1284: 		CALL	ATOH			; Get line number to DE
01:93ED E5              	  1285: 		PUSH	HL				; Save code string address
01:93EE CD6690          	  1286: 		CALL	SRCHLN			; Search for line number in DE
01:93F1 60              	  1287: 		LD		H,B				; HL = Address of line
01:93F2 69              	  1288: 		LD		L,C
01:93F3 D1              	  1289: 		POP		DE				; Restore code string address
01:93F4 D24295          	  1290: 		JP		NC,ULERR		; ?UL Error if not found
01:93F7 2B              	  1291: RESTNL: DEC		HL				; Byte before DATA statement
01:93F8 22DC10          	  1292: UPDATA: LD		(NXTDAT),HL		; Update DATA pointer
01:93FB EB              	  1293: 		EX		DE,HL			; Restore code string address
01:93FC C9              	  1294: 		RET
                        	  1295: 
                        	  1296: 
                        	  1297: TSTBRK: 
01:93FD CDD280          	  1298: 	call	ReadCharNoWait			; Check for presence of character
01:9400 C8              	  1299: 	ret		z						; Return if nothing is in SIO buffer
                        	  1300: 	
                        	  1301: ;		call	CKINCHAR				; Check input status
                        	  1302: ;		RET		Z				; No key, go back
                        	  1303: ;		call	RXA				; Get the key into A
01:9401 FE1B            	  1304: 		CP		ESC				; Escape key?
01:9403 2813            	  1305: 		JR		Z,BRK			; Yes, break
01:9405 FE03            	  1306: 		CP		CTRLC			; <Ctrl-C>
01:9407 280F            	  1307: 		JR		Z,BRK			; Yes, break
01:9409 FE13            	  1308: 		CP		CTRLS			; Stop scrolling?
01:940B C0              	  1309: 		RET		NZ				; Other key, ignore
                        	  1310: 
                        	  1311: 
01:940C CDC980          	  1312: STALL:	call	ReadChar				; Wait for key
01:940F FE11            	  1313: 		CP		CTRLQ			; Resume scrolling?
01:9411 C8              	  1314: 		RET		 Z				; Release the chokehold
01:9412 FE03            	  1315: 		CP		CTRLC			; Second break?
01:9414 2807            	  1316: 		JR		Z,STOPP			; Break during hold exits prog
01:9416 18F4            	  1317: 		JR		STALL			; Loop until <Ctrl-Q> or <brk>
                        	  1318: 
01:9418 3EFF            	  1319: BRK		LD		A,$FF			; Set BRKFLG
01:941A 324D10          	  1320: 		LD		(BRKFLG),A		; Store it
                        	  1321: 
                        	  1322: 
01:941D C0              	  1323: STOPP:	RET		NZ				; Exit if anything else
01:941E F6              	  1324: 		db	0F6H			; Flag "STOP"
01:941F C0              	  1325: PEND:	RET		NZ				; Exit if anything else
01:9420 22CE10          	  1326: 		LD		(BRKLIN),HL		; Save point of break
01:9423 21              	  1327: 		db	21H				; Skip "OR 11111111B"
01:9424 F6FF            	  1328: INPBRK: OR		11111111B		; Flag "Break" wanted
01:9426 C1              	  1329: 		POP		BC				; Return not needed and more
01:9427 2A5C10          	  1330: ENDPRG: LD		HL,(LINEAT)		; Get current line number
01:942A F5              	  1331: 		PUSH	AF				; Save STOP / END status
01:942B 7D              	  1332: 		LD		A,L				; Is it direct break?
01:942C A4              	  1333: 		AND		H
01:942D 3C              	  1334: 		INC		A				; Line is -1 if direct break
01:942E CA3A94          	  1335: 		JP		Z,NOLIN			; Yes - No line number
01:9431 22D210          	  1336: 		LD		(ERRLIN),HL		; Save line of break
01:9434 2ACE10          	  1337: 		LD		HL,(BRKLIN)		; Get point of break
01:9437 22D410          	  1338: 		LD		(CONTAD),HL		; Save point to CONTinue
01:943A AF              	  1339: NOLIN:	XOR		A
01:943B 324510          	  1340: 		LD		(CTLOFG),A		; Enable output
01:943E CD7096          	  1341: 		CALL	STTLIN			; Start a new line
01:9441 F1              	  1342: 		POP		AF				; Restore STOP / END status
01:9442 211D8F          	  1343: 		LD		HL,BRKMSG		; "Break" message
01:9445 C2AE8F          	  1344: 		JP		NZ,ERRIN		; "in line" wanted?
01:9448 C3C58F          	  1345: 		JP		PRNTOK			; Go to command mode
                        	  1346: 
01:944B 2AD410          	  1347: CONT:	LD		HL,(CONTAD)		; Get CONTinue address
01:944E 7C              	  1348: 		LD		A,H				; Is it zero?
01:944F B5              	  1349: 		OR		L
01:9450 1E20            	  1350: 		LD		E,CN			; ?CN Error
01:9452 CA8E8F          	  1351: 		JP		Z,ERROR			; Yes - output "?CN Error"
01:9455 EB              	  1352: 		EX		DE,HL			; Save code string address
01:9456 2AD210          	  1353: 		LD		HL,(ERRLIN)		; Get line of last break
01:9459 225C10          	  1354: 		LD		(LINEAT),HL		; Set up current line number
01:945C EB              	  1355: 		EX		DE,HL			; Restore code string address
01:945D C9              	  1356: 		RET						; CONTinue where left off
                        	  1357: 
01:945E CD9C9F          	  1358: NULLL:	CALL	GETINT			; Get integer 0-255
01:9461 C0              	  1359: 		RET		NZ				; Return if bad value
01:9462 324110          	  1360: 		LD		(NULLS),A		; Set nulls number
01:9465 C9              	  1361: 		RET
                        	  1362: 
                        	  1363: 
01:9466 E5              	  1364: ACCSUM: PUSH	HL				; Save address in array
01:9467 2A4A10          	  1365: 		LD		HL,(CHKSUM)		; Get check sum
01:946A 0600            	  1366: 		LD		B,0				; BC - Value of byte
01:946C 4F              	  1367: 		LD		C,A
01:946D 09              	  1368: 		ADD		HL,BC			; Add byte to check sum
01:946E 224A10          	  1369: 		LD		(CHKSUM),HL		; Re-save check sum
01:9471 E1              	  1370: 		POP		HL				; Restore address in array
01:9472 C9              	  1371: 		RET
                        	  1372: 
01:9473 7E              	  1373: CHKLTR: LD		A,(HL)			; Get byte
01:9474 FE41            	  1374: 		CP		'A'				; < 'a' ?
01:9476 D8              	  1375: 		RET		C				; Carry set if not letter
01:9477 FE5B            	  1376: 		CP		'Z'+1			; > 'z' ?
01:9479 3F              	  1377: 		CCF
01:947A C9              	  1378: 		RET						; Carry set if not letter
                        	  1379: 
01:947B CDD293          	  1380: FPSINT: CALL	GETCHR			; Get next character
01:947E CD3B98          	  1381: POSINT: CALL	GETNUM			; Get integer 0 to 32767
01:9481 CD1DA2          	  1382: DEPINT: CALL	TSTSGN			; Test sign of FPREG
01:9484 FA9C94          	  1383: 		JP		M,FCERR			; Negative - ?FC Error
01:9487 3AE710          	  1384: DEINT:	LD		A,(FPEXP)		; Get integer value to DE
01:948A FE90            	  1385: 		CP		80H+16			; Exponent in range (16 bits)?
01:948C DAC5A2          	  1386: 		JP		C,FPINT			; Yes - convert it
01:948F 018090          	  1387: 		LD		BC,9080H		; BCDE = -32768
01:9492 110000          	  1388: 		LD		DE,0000
01:9495 E5              	  1389: 		PUSH	HL				; Save code string address
01:9496 CD98A2          	  1390: 		CALL	CMPNUM			; Compare FPREG with BCDE
01:9499 E1              	  1391: 		POP		HL				; Restore code string address
01:949A 51              	  1392: 		LD		D,C				; MSB to D
01:949B C8              	  1393: 		RET		Z				; Return if in range
01:949C 1E08            	  1394: FCERR:	LD		E,FC			; ?FC Error
01:949E C38E8F          	  1395: 		JP		ERROR			; Output error-
                        	  1396: 
01:94A1 2B              	  1397: ATOH:	DEC		HL				; ASCII number to DE binary
01:94A2 110000          	  1398: GETLN:	LD		DE,0			; Get number to DE
01:94A5 CDD293          	  1399: GTLNLP: CALL	GETCHR			; Get next character
01:94A8 D0              	  1400: 		RET		NC				; Exit if not a digit
01:94A9 E5              	  1401: 		PUSH	HL				; Save code string address
01:94AA F5              	  1402: 		PUSH	AF				; Save digit
01:94AB 219819          	  1403: 		LD		HL,65529/10		; Largest number 65529
01:94AE CD4292          	  1404: 		CALL	CPDEHL			; Number in range?
01:94B1 DA7A8F          	  1405: 		JP		C,SNERR			; No - ?SN Error
01:94B4 62              	  1406: 		LD		H,D				; HL = Number
01:94B5 6B              	  1407: 		LD		L,E
01:94B6 19              	  1408: 		ADD		HL,DE			; Times 2
01:94B7 29              	  1409: 		ADD		HL,HL			; Times 4
01:94B8 19              	  1410: 		ADD		HL,DE			; Times 5
01:94B9 29              	  1411: 		ADD		HL,HL			; Times 10
01:94BA F1              	  1412: 		POP		AF				; Restore digit
01:94BB D630            	  1413: 		SUB		'0'				; Make it 0 to 9
01:94BD 5F              	  1414: 		LD		E,A				; DE = Value of digit
01:94BE 1600            	  1415: 		LD		D,0
01:94C0 19              	  1416: 		ADD		HL,DE			; Add to number
01:94C1 EB              	  1417: 		EX		DE,HL			; Number to DE
01:94C2 E1              	  1418: 		POP		HL				; Restore code string address
01:94C3 C3A594          	  1419: 		JP		GTLNLP			; Go to next character
                        	  1420: 
01:94C6 CA9690          	  1421: CLEAR:	JP		Z,INTVAR		; Just "CLEAR" Keep parameters
01:94C9 CD7E94          	  1422: 		CALL	POSINT			; Get integer 0 to 32767 to DE
01:94CC 2B              	  1423: 		DEC		HL				; Cancel increment
01:94CD CDD293          	  1424: 		CALL	GETCHR			; Get next character
01:94D0 E5              	  1425: 		PUSH	HL				; Save code string address
01:94D1 2AAF10          	  1426: 		LD		HL,(LSTRAM)		; Get end of RAM
01:94D4 CAE994          	  1427: 		JP		Z,STORED		; No value given - Use stored
01:94D7 E1              	  1428: 		POP		HL				; Restore code string address
01:94D8 CD4892          	  1429: 		CALL	CHKSYN			; Check for comma
01:94DB 2C              	  1430: 		db	   ','
01:94DC D5              	  1431: 		PUSH	DE				; Save number
01:94DD CD7E94          	  1432: 		CALL	POSINT			; Get integer 0 to 32767
01:94E0 2B              	  1433: 		DEC		HL				; Cancel increment
01:94E1 CDD293          	  1434: 		CALL	GETCHR			; Get next character
01:94E4 C27A8F          	  1435: 		JP		NZ,SNERR		; ?SN Error if more on line
01:94E7 E3              	  1436: 		EX		(SP),HL			; Save code string address
01:94E8 EB              	  1437: 		EX		DE,HL			; Number to DE
01:94E9 7D              	  1438: STORED: LD		A,L				; Get LSB of new RAM top
01:94EA 93              	  1439: 		SUB		E				; Subtract LSB of string space
01:94EB 5F              	  1440: 		LD		E,A				; Save LSB
01:94EC 7C              	  1441: 		LD		A,H				; Get MSB of new RAM top
01:94ED 9A              	  1442: 		SBC		A,D				; Subtract MSB of string space
01:94EE 57              	  1443: 		LD		D,A				; Save MSB
01:94EF DA6F8F          	  1444: 		JP		C,OMERR			; ?OM Error if not enough mem
01:94F2 E5              	  1445: 		PUSH	HL				; Save RAM top
01:94F3 2AD610          	  1446: 		LD		HL,(PROGND)		; Get program end
01:94F6 012800          	  1447: 		LD		BC,40			; 40 Bytes minimum working RAM
01:94F9 09              	  1448: 		ADD		HL,BC			; Get lowest address
01:94FA CD4292          	  1449: 		CALL	CPDEHL			; Enough memory?
01:94FD D26F8F          	  1450: 		JP		NC,OMERR		; No - ?OM Error
01:9500 EB              	  1451: 		EX		DE,HL			; RAM top to HL
01:9501 225A10          	  1452: 		LD		(STRSPC),HL		; Set new string space
01:9504 E1              	  1453: 		POP		HL				; End of memory to use
01:9505 22AF10          	  1454: 		LD		(LSTRAM),HL		; Set new top of RAM
01:9508 E1              	  1455: 		POP		HL				; Restore code string address
01:9509 C39690          	  1456: 		JP		INTVAR			; Initialise variables
                        	  1457: 
01:950C CA9290          	  1458: RUN:	JP		Z,RUNFST		; RUN from start if just RUN
01:950F CD9690          	  1459: 		CALL	INTVAR			; Initialise variables
01:9512 019293          	  1460: 		LD		BC,RUNCNT		; Execution driver loop
01:9515 C32895          	  1461: 		JP		RUNLIN			; RUN from line number
                        	  1462: 
01:9518 0E03            	  1463: GOSUB:	LD		C,3				; 3 Levels of stack needed
01:951A CD578F          	  1464: 		CALL	CHKSTK			; Check for 3 levels of stack
01:951D C1              	  1465: 		POP		BC				; Get return address
01:951E E5              	  1466: 		PUSH	HL				; Save code string for RETURN
01:951F E5              	  1467: 		PUSH	HL				; And for GOSUB routine
01:9520 2A5C10          	  1468: 		LD		HL,(LINEAT)		; Get current line
01:9523 E3              	  1469: 		EX		(SP),HL			; Into stack - Code string out
01:9524 3E8C            	  1470: 		LD		A,ZGOSUB		; "GOSUB" token
01:9526 F5              	  1471: 		PUSH	AF				; Save token
01:9527 33              	  1472: 		INC		SP				; Don't save flags
                        	  1473: 
01:9528 C5              	  1474: RUNLIN: PUSH	BC				; Save return address
01:9529 CDA194          	  1475: GOTO:	CALL	ATOH			; ASCII number to DE binary
01:952C CD6E95          	  1476: 		CALL	REM				; Get end of line
01:952F E5              	  1477: 		PUSH	HL				; Save end of line
01:9530 2A5C10          	  1478: 		LD		HL,(LINEAT)		; Get current line
01:9533 CD4292          	  1479: 		CALL	CPDEHL			; Line after current?
01:9536 E1              	  1480: 		POP		HL				; Restore end of line
01:9537 23              	  1481: 		INC		HL				; Start of next line
01:9538 DC6990          	  1482: 		CALL	C,SRCHLP		; Line is after current line
01:953B D46690          	  1483: 		CALL	NC,SRCHLN		; Line is before current line
01:953E 60              	  1484: 		LD		H,B				; Set up code string address
01:953F 69              	  1485: 		LD		L,C
01:9540 2B              	  1486: 		DEC		HL				; Incremented after
01:9541 D8              	  1487: 		RET		C				; Line found
01:9542 1E0E            	  1488: ULERR:	LD		E,UL			; ?UL Error
01:9544 C38E8F          	  1489: 		JP		ERROR			; Output error message
                        	  1490: 
01:9547 C0              	  1491: RETURN: RET		NZ				; Return if not just RETURN
01:9548 16FF            	  1492: 		LD		D,-1			; Flag "GOSUB" search
01:954A CD238F          	  1493: 		CALL	BAKSTK			; Look "GOSUB" block
01:954D F9              	  1494: 		LD		SP,HL			; Kill all FORs in subroutine
01:954E FE8C            	  1495: 		CP		ZGOSUB			; Test for "GOSUB" token
01:9550 1E04            	  1496: 		LD		E,RG			; ?RG Error
01:9552 C28E8F          	  1497: 		JP		NZ,ERROR		; Error if no "GOSUB" found
01:9555 E1              	  1498: 		POP		HL				; Get RETURN line number
01:9556 225C10          	  1499: 		LD		(LINEAT),HL		; Save as current
01:9559 23              	  1500: 		INC		HL				; Was it from direct statement?
01:955A 7C              	  1501: 		LD		A,H
01:955B B5              	  1502: 		OR		L				; Return to line
01:955C C26695          	  1503: 		JP		NZ,RETLIN		; No - Return to line
01:955F 3ACC10          	  1504: 		LD		A,(LSTBIN)		; Any INPUT in subroutine?
01:9562 B7              	  1505: 		OR		A				; If so buffer is corrupted
01:9563 C2C48F          	  1506: 		JP		NZ,POPNOK		; Yes - Go to command mode
01:9566 219293          	  1507: RETLIN: LD		HL,RUNCNT		; Execution driver loop
01:9569 E3              	  1508: 		EX		(SP),HL			; Into stack - Code string out
01:956A 3E              	  1509: 		db	   3EH			   ; Skip "POP HL"
01:956B E1              	  1510: NXTDTA: POP		HL				; Restore code string address
                        	  1511: 
01:956C 01              	  1512: DATAA:	db	   01H,3AH		   ; ':' End of statement
01:956D 3A
01:956E 0E00            	  1513: REM:	LD		C,0				; 00  End of statement
01:9570 0600            	  1514: 		LD		B,0
01:9572 79              	  1515: NXTSTL: LD		A,C				; Statement and byte
01:9573 48              	  1516: 		LD		C,B
01:9574 47              	  1517: 		LD		B,A				; Statement end byte
01:9575 7E              	  1518: NXTSTT: LD		A,(HL)			; Get byte
01:9576 B7              	  1519: 		OR		A				; End of line?
01:9577 C8              	  1520: 		RET		Z				; Yes - Exit
01:9578 B8              	  1521: 		CP		B				; End of statement?
01:9579 C8              	  1522: 		RET		Z				; Yes - Exit
01:957A 23              	  1523: 		INC		HL				; Next byte
01:957B FE22            	  1524: 		CP		'"'				; Literal string?
01:957D CA7295          	  1525: 		JP		Z,NXTSTL		; Yes - Look for another '"'
01:9580 C37595          	  1526: 		JP		NXTSTT			; Keep looking
                        	  1527: 
01:9583 CD319A          	  1528: LET:	CALL	GETVAR			; Get variable name
01:9586 CD4892          	  1529: 		CALL	CHKSYN			; Make sure "=" follows
01:9589 B4              	  1530: 		db	   ZEQUAL		   ; "=" token
01:958A D5              	  1531: 		PUSH	DE				; Save address of variable
01:958B 3AAD10          	  1532: 		LD		A,(TYPE)		; Get data type
01:958E F5              	  1533: 		PUSH	AF				; Save type
01:958F CD4D98          	  1534: 		CALL	EVAL			; Evaluate expression
01:9592 F1              	  1535: 		POP		AF				; Restore type
01:9593 E3              	  1536: 		EX		(SP),HL			; Save code - Get var addr
01:9594 22CE10          	  1537: 		LD		(BRKLIN),HL		; Save address of variable
01:9597 1F              	  1538: 		RRA						; Adjust type
01:9598 CD4098          	  1539: 		CALL	CHKTYP			; Check types are the same
01:959B CAD695          	  1540: 		JP		Z,LETNUM		; Numeric - Move value
01:959E E5              	  1541: LETSTR: PUSH	HL				; Save address of string var
01:959F 2AE410          	  1542: 		LD		HL,(FPREG)		; Pointer to string entry
01:95A2 E5              	  1543: 		PUSH	HL				; Save it on stack
01:95A3 23              	  1544: 		INC		HL				; Skip over length
01:95A4 23              	  1545: 		INC		HL
01:95A5 5E              	  1546: 		LD		E,(HL)			; LSB of string address
01:95A6 23              	  1547: 		INC		HL
01:95A7 56              	  1548: 		LD		D,(HL)			; MSB of string address
01:95A8 2A5E10          	  1549: 		LD		HL,(BASTXT)		; Point to start of program
01:95AB CD4292          	  1550: 		CALL	CPDEHL			; Is string before program?
01:95AE D2C595          	  1551: 		JP		NC,CRESTR		; Yes - Create string entry
01:95B1 2A5A10          	  1552: 		LD		HL,(STRSPC)		; Point to string space
01:95B4 CD4292          	  1553: 		CALL	CPDEHL			; Is string literal in program?
01:95B7 D1              	  1554: 		POP		DE				; Restore address of string
01:95B8 D2CD95          	  1555: 		JP		NC,MVSTPT		; Yes - Set up pointer
01:95BB 21BF10          	  1556: 		LD		HL,TMPSTR		; Temporary string pool
01:95BE CD4292          	  1557: 		CALL	CPDEHL			; Is string in temporary pool?
01:95C1 D2CD95          	  1558: 		JP		NC,MVSTPT		; No - Set up pointer
01:95C4 3E              	  1559: 		db	3EH				; Skip "POP DE"
01:95C5 D1              	  1560: CRESTR: POP		DE				; Restore address of string
01:95C6 CD759E          	  1561: 		CALL	BAKTMP			; Back to last tmp-str entry
01:95C9 EB              	  1562: 		EX		DE,HL			; Address of string entry
01:95CA CDAE9C          	  1563: 		CALL	SAVSTR			; Save string in string area
01:95CD CD759E          	  1564: MVSTPT: CALL	BAKTMP			; Back to last tmp-str entry
01:95D0 E1              	  1565: 		POP		HL				; Get string pointer
01:95D1 CD78A2          	  1566: 		CALL	DETHL4			; Move string pointer to var
01:95D4 E1              	  1567: 		POP		HL				; Restore code string address
01:95D5 C9              	  1568: 		RET
                        	  1569: 
01:95D6 E5              	  1570: LETNUM: PUSH	HL				; Save address of variable
01:95D7 CD75A2          	  1571: 		CALL	FPTHL			; Move value to variable
01:95DA D1              	  1572: 		POP		DE				; Restore address of variable
01:95DB E1              	  1573: 		POP		HL				; Restore code string address
01:95DC C9              	  1574: 		RET
                        	  1575: 
01:95DD CD9C9F          	  1576: ON:		CALL	GETINT			; Get integer 0-255
01:95E0 7E              	  1577: 		LD		A,(HL)			; Get "GOTO" or "GOSUB" token
01:95E1 47              	  1578: 		LD		B,A				; Save in B
01:95E2 FE8C            	  1579: 		CP		ZGOSUB			; "GOSUB" token?
01:95E4 CAEC95          	  1580: 		JP		Z,ONGO			; Yes - Find line number
01:95E7 CD4892          	  1581: 		CALL	CHKSYN			; Make sure it's "GOTO"
01:95EA 88              	  1582: 		db	ZGOTO			; "GOTO" token
01:95EB 2B              	  1583: 		DEC		HL				; Cancel increment
01:95EC 4B              	  1584: ONGO:	LD		C,E				; Integer of branch value
01:95ED 0D              	  1585: ONGOLP: DEC		C				; Count branches
01:95EE 78              	  1586: 		LD		A,B				; Get "GOTO" or "GOSUB" token
01:95EF CABA93          	  1587: 		JP		Z,ONJMP			; Go to that line if right one
01:95F2 CDA294          	  1588: 		CALL	GETLN			; Get line number to DE
01:95F5 FE2C            	  1589: 		CP		','				; Another line number?
01:95F7 C0              	  1590: 		RET		NZ				; No - Drop through
01:95F8 C3ED95          	  1591: 		JP		ONGOLP			; Yes - loop
                        	  1592: 
01:95FB CD4D98          	  1593: IFF:		CALL	EVAL			; Evaluate expression
01:95FE 7E              	  1594: 		LD		A,(HL)			; Get token
01:95FF FE88            	  1595: 		CP		ZGOTO			; "GOTO" token?
01:9601 CA0996          	  1596: 		JP		Z,IFGO			; Yes - Get line
01:9604 CD4892          	  1597: 		CALL	CHKSYN			; Make sure it's "THEN"
01:9607 A9              	  1598: 		db	   ZTHEN		   ; "THEN" token
01:9608 2B              	  1599: 		DEC		HL				; Cancel increment
01:9609 CD3E98          	  1600: IFGO:	CALL	TSTNUM			; Make sure it's numeric
01:960C CD1DA2          	  1601: 		CALL	TSTSGN			; Test state of expression
01:960F CA6E95          	  1602: 		JP		Z,REM			; False - Drop through
01:9612 CDD293          	  1603: 		CALL	GETCHR			; Get next character
01:9615 DA2995          	  1604: 		JP		C,GOTO			; Number - GOTO that line
01:9618 C3B993          	  1605: 		JP		IFJMP			; Otherwise do statement
                        	  1606: 
01:961B 2B              	  1607: MRPRNT: DEC		HL				; DEC 'cos GETCHR INCs
01:961C CDD293          	  1608: 		CALL	GETCHR			; Get next character
01:961F CA8180          	  1609: PRINTT:	JP		Z,PrintCRLF		; CRLF if just PRINT
01:9622 C8              	  1610: PRNTLP: RET		Z				; End of list - Exit
01:9623 FEA5            	  1611: 		CP		ZTAB			; "TAB(" token?
01:9625 CAA996          	  1612: 		JP		Z,DOTAB			; Yes - Do TAB routine
01:9628 FEA8            	  1613: 		CP		ZSPC			; "SPC(" token?
01:962A CAA996          	  1614: 		JP		Z,DOTAB			; Yes - Do SPC routine
01:962D E5              	  1615: 		PUSH	HL				; Save code string address
01:962E FE2C            	  1616: 		CP		','				; Comma?
01:9630 CA9296          	  1617: 		JP		Z,DOCOM			; Yes - Move to next zone
01:9633 FE3B            	  1618: 		CP		59 ;";"			; Semi-colon?
01:9635 CACC96          	  1619: 		JP		Z,NEXITM		; Do semi-colon routine
01:9638 C1              	  1620: 		POP		BC				; Code string address to BC
01:9639 CD4D98          	  1621: 		CALL	EVAL			; Evaluate expression
01:963C E5              	  1622: 		PUSH	HL				; Save code string address
01:963D 3AAD10          	  1623: 		LD		A,(TYPE)		; Get variable type
01:9640 B7              	  1624: 		OR		A				; Is it a string variable?
01:9641 C26996          	  1625: 		JP		NZ,PRNTST		; Yes - Output string contents
01:9644 CDC2A3          	  1626: 		CALL	NUMASC			; Convert number to text
01:9647 CDD29C          	  1627: 		CALL	CRTST			; Create temporary string
01:964A 3620            	  1628: 		LD		(HL),' '		; Followed by a space
01:964C 2AE410          	  1629: 		LD		HL,(FPREG)		; Get length of output
01:964F 34              	  1630: 		INC		(HL)			; Plus 1 for the space
01:9650 2AE410          	  1631: 		LD		HL,(FPREG)		; < Not needed >
01:9653 3A4210          	  1632: 		LD		A,(LWIDTH)		; Get width of line
01:9656 47              	  1633: 		LD		B,A				; To B
01:9657 04              	  1634: 		INC		B				; Width 255 (No limit)?
01:9658 CA6596          	  1635: 		JP		Z,PRNTNB		; Yes - Output number string
01:965B 04              	  1636: 		INC		B				; Adjust it
01:965C 3AAB10          	  1637: 		LD		A,(CURPOS)		; Get cursor position
01:965F 86              	  1638: 		ADD		A,(HL)			; Add length of string
01:9660 3D              	  1639: 		DEC		A				; Adjust it
01:9661 B8              	  1640: 		CP		B				; Will output fit on this line?
01:9662 D48180          	  1641: 		CALL	NC,PrintCRLF		; No - CRLF first
01:9665 CD179D          	  1642: PRNTNB: CALL	PRS1			; Output string at (HL)
01:9668 AF              	  1643: 		XOR		A				; Skip CALL by setting 'z' flag
01:9669 C4179D          	  1644: PRNTST: CALL	NZ,PRS1			; Output string at (HL)
01:966C E1              	  1645: 		POP		HL				; Restore code string address
01:966D C31B96          	  1646: 		JP		MRPRNT			; See if more to PRINT
                        	  1647: 
01:9670 3AAB10          	  1648: STTLIN: LD		A,(CURPOS)		; Make sure on new line
01:9673 B7              	  1649: 		OR		A				; Already at start?
01:9674 C8              	  1650: 		RET		Z				; Yes - Do nothing
01:9675 C38180          	  1651: 		JP		PrintCRLF		; Start a new line
                        	  1652: 
01:9678 3600            	  1653: ENDINP: LD		(HL),0			; Mark end of buffer
01:967A 216010          	  1654: 		LD		HL,BUFFER-1		; Point to buffer
01:967D CD8180          	  1655: 		call	PrintCRLF
01:9680 AF              	  1656: DONULL: XOR		A				; Set to position 0
01:9681 32AB10          	  1657: 		LD		(CURPOS),A		; Store it
01:9684 3A4110          	  1658: 		LD		A,(NULLS)		; Get number of nulls
01:9687 3D              	  1659: NULLP:	DEC		A				; Count them
01:9688 C8              	  1660: 		RET		Z				; Return if done
01:9689 F5              	  1661: 		PUSH	AF				; Save count
01:968A AF              	  1662: 		XOR		A				; Load a null
01:968B CD5392          	  1663: 		CALL	OUTC			; Output it
01:968E F1              	  1664: 		POP		AF				; Restore count
01:968F C38796          	  1665: 		JP		NULLP			; Keep counting
                        	  1666: 
01:9692 3A4310          	  1667: DOCOM:	LD		A,(COMMAN)		; Get comma width
01:9695 47              	  1668: 		LD		B,A				; Save in B
01:9696 3AAB10          	  1669: 		LD		A,(CURPOS)		; Get current position
01:9699 B8              	  1670: 		CP		B				; Within the limit?
01:969A D48180          	  1671: 		CALL	NC,PrintCRLF		; No - output CRLF
01:969D D2CC96          	  1672: 		JP		NC,NEXITM		; Get next item
01:96A0 D60E            	  1673: ZONELP: SUB		14				; Next zone of 14 characters
01:96A2 D2A096          	  1674: 		JP		NC,ZONELP		; Repeat if more zones
01:96A5 2F              	  1675: 		CPL						; Number of spaces to output
01:96A6 C3C196          	  1676: 		JP		ASPCS			; Output them
                        	  1677: 
01:96A9 F5              	  1678: DOTAB:	PUSH	AF				; Save token
01:96AA CD999F          	  1679: 		CALL	FNDNUM			; Evaluate expression
01:96AD CD4892          	  1680: 		CALL	CHKSYN			; Make sure ")" follows
01:96B0 29              	  1681: 		db	")"
01:96B1 2B              	  1682: 		DEC		HL				; Back space on to ")"
01:96B2 F1              	  1683: 		POP		AF				; Restore token
01:96B3 D6A8            	  1684: 		SUB		ZSPC			; Was it "SPC(" ?
01:96B5 E5              	  1685: 		PUSH	HL				; Save code string address
01:96B6 CABC96          	  1686: 		JP		Z,DOSPC			; Yes - Do 'E' spaces
01:96B9 3AAB10          	  1687: 		LD		A,(CURPOS)		; Get current position
01:96BC 2F              	  1688: DOSPC:	CPL						; Number of spaces to print to
01:96BD 83              	  1689: 		ADD		A,E				; Total number to print
01:96BE D2CC96          	  1690: 		JP		NC,NEXITM		; TAB < Current POS(X)
01:96C1 3C              	  1691: ASPCS:	INC		A				; Output A spaces
01:96C2 47              	  1692: 		LD		B,A				; Save number to print
01:96C3 3E20            	  1693: 		LD		A,' '			; Space
01:96C5 CD5392          	  1694: SPCLP:	CALL	OUTC			; Output character in A
01:96C8 05              	  1695: 		DEC		B				; Count them
01:96C9 C2C596          	  1696: 		JP		NZ,SPCLP		; Repeat if more
01:96CC E1              	  1697: NEXITM: POP		HL				; Restore code string address
01:96CD CDD293          	  1698: 		CALL	GETCHR			; Get next character
01:96D0 C32296          	  1699: 		JP		PRNTLP			; More to print
                        	  1700: 
01:96D3 3F5265646F206672	  1701: REDO:	db	"?Redo from start",CR,LF,0
01:96DB 6F6D207374617274
01:96E3 0D
01:96E4 0A
01:96E5 00
                        	  1702: 
01:96E6 3ACD10          	  1703: BADINP: LD		A,(READFG)		; READ or INPUT?
01:96E9 B7              	  1704: 		OR		A
01:96EA C2748F          	  1705: 		JP		NZ,DATSNR		; READ - ?SN Error
01:96ED C1              	  1706: 		POP		BC				; Throw away code string addr
01:96EE 21D396          	  1707: 		LD		HL,REDO			; "Redo from start" message
01:96F1 CD149D          	  1708: 		CALL	PRS				; Output string
01:96F4 C3C590          	  1709: 		JP		DOAGN			; Do last INPUT again
                        	  1710: 
01:96F7 CD7F9C          	  1711: INPUT:	CALL	IDTEST			; Test for illegal direct
01:96FA 7E              	  1712: 		LD		A,(HL)			; Get character after "INPUT"
01:96FB FE22            	  1713: 		CP		'"'				; Is there a prompt string?
01:96FD 3E00            	  1714: 		LD		A,0				; Clear A and leave flags
01:96FF 324510          	  1715: 		LD		(CTLOFG),A		; Enable output
01:9702 C21197          	  1716: 		JP		NZ,NOPMPT		; No prompt - get input
01:9705 CDD39C          	  1717: 		CALL	QTSTR			; Get string terminated by '"'
01:9708 CD4892          	  1718: 		CALL	CHKSYN			; Check for ';' after prompt
01:970B 3B              	  1719: 		db	';'
01:970C E5              	  1720: 		PUSH	HL				; Save code string address
01:970D CD179D          	  1721: 		CALL	PRS1			; Output prompt string
01:9710 3E              	  1722: 		db	3EH				; Skip "PUSH HL"
01:9711 E5              	  1723: NOPMPT: PUSH	HL				; Save code string address
01:9712 CDC990          	  1724: 		CALL	PROMPT			; Get input with "? " prompt
01:9715 C1              	  1725: 		POP		BC				; Restore code string address
01:9716 DA2494          	  1726: 		JP		C,INPBRK		; Break pressed - Exit
01:9719 23              	  1727: 		INC		HL				; Next byte
01:971A 7E              	  1728: 		LD		A,(HL)			; Get it
01:971B B7              	  1729: 		OR		A				; End of line?
01:971C 2B              	  1730: 		DEC		HL				; Back again
01:971D C5              	  1731: 		PUSH	BC				; Re-save code string address
01:971E CA6B95          	  1732: 		JP		Z,NXTDTA		; Yes - Find next DATA stmt
01:9721 362C            	  1733: 		LD		(HL),','		; Store comma as separator
01:9723 C32B97          	  1734: 		JP		NXTITM			; Get next item
                        	  1735: 
01:9726 E5              	  1736: READ:	PUSH	HL				; Save code string address
01:9727 2ADC10          	  1737: 		LD		HL,(NXTDAT)		; Next DATA statement
01:972A F6              	  1738: 		db	0F6H			; Flag "READ"
01:972B AF              	  1739: NXTITM: XOR		A				; Flag "INPUT"
01:972C 32CD10          	  1740: 		LD		(READFG),A		; Save "READ"/"INPUT" flag
01:972F E3              	  1741: 		EX		(SP),HL			; Get code str' , Save pointer
01:9730 C33797          	  1742: 		JP		GTVLUS			; Get values
                        	  1743: 
01:9733 CD4892          	  1744: NEDMOR: CALL	CHKSYN			; Check for comma between items
01:9736 2C              	  1745: 		db	   ','
01:9737 CD319A          	  1746: GTVLUS: CALL	GETVAR			; Get variable name
01:973A E3              	  1747: 		EX		(SP),HL			; Save code str" , Get pointer
01:973B D5              	  1748: 		PUSH	DE				; Save variable address
01:973C 7E              	  1749: 		LD		A,(HL)			; Get next "INPUT"/"DATA" byte
01:973D FE2C            	  1750: 		CP		','				; Comma?
01:973F CA5F97          	  1751: 		JP		Z,ANTVLU		; Yes - Get another value
01:9742 3ACD10          	  1752: 		LD		A,(READFG)		; Is it READ?
01:9745 B7              	  1753: 		OR		A
01:9746 C2CC97          	  1754: 		JP		NZ,FDTLP		; Yes - Find next DATA stmt
01:9749 3E3F            	  1755: 		LD		A,'?'			; More INPUT needed
01:974B CD5392          	  1756: 		CALL	OUTC			; Output character
01:974E CDC990          	  1757: 		CALL	PROMPT			; Get INPUT with prompt
01:9751 D1              	  1758: 		POP		DE				; Variable address
01:9752 C1              	  1759: 		POP		BC				; Code string address
01:9753 DA2494          	  1760: 		JP		C,INPBRK		; Break pressed
01:9756 23              	  1761: 		INC		HL				; Point to next DATA byte
01:9757 7E              	  1762: 		LD		A,(HL)			; Get byte
01:9758 B7              	  1763: 		OR		A				; Is it zero (No input) ?
01:9759 2B              	  1764: 		DEC		HL				; Back space INPUT pointer
01:975A C5              	  1765: 		PUSH	BC				; Save code string address
01:975B CA6B95          	  1766: 		JP		Z,NXTDTA		; Find end of buffer
01:975E D5              	  1767: 		PUSH	DE				; Save variable address
01:975F 3AAD10          	  1768: ANTVLU: LD		A,(TYPE)		; Check data type
01:9762 B7              	  1769: 		OR		A				; Is it numeric?
01:9763 CA8997          	  1770: 		JP		Z,INPBIN		; Yes - Convert to binary
01:9766 CDD293          	  1771: 		CALL	GETCHR			; Get next character
01:9769 57              	  1772: 		LD		D,A				; Save input character
01:976A 47              	  1773: 		LD		B,A				; Again
01:976B FE22            	  1774: 		CP		'"'				; Start of literal sting?"
01:976D CA7D97          	  1775: 		JP		Z,STRENT		; Yes - Create string entry
01:9770 3ACD10          	  1776: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:9773 B7              	  1777: 		OR		A
01:9774 57              	  1778: 		LD		D,A				; Save 00 if "INPUT"
01:9775 CA7A97          	  1779: 		JP		Z,ITMSEP		; "INPUT" - End with 00
01:9778 163A            	  1780: 		LD		D,':'			; "DATA" - End with 00 or ':'
01:977A 062C            	  1781: ITMSEP: LD		B,','			; Item separator
01:977C 2B              	  1782: 		DEC		HL				; Back space for DTSTR
01:977D CDD69C          	  1783: STRENT: CALL	DTSTR			; Get string terminated by D
01:9780 EB              	  1784: 		EX		DE,HL			; String address to DE
01:9781 219497          	  1785: 		LD		HL,LTSTND		; Where to go after LETSTR
01:9784 E3              	  1786: 		EX		(SP),HL			; Save HL , get input pointer
01:9785 D5              	  1787: 		PUSH	DE				; Save address of string
01:9786 C39E95          	  1788: 		JP		LETSTR			; Assign string to variable
                        	  1789: 
01:9789 CDD293          	  1790: INPBIN: CALL	GETCHR			; Get next character
01:978C CD24A3          	  1791: 		CALL	ASCTFP			; Convert ASCII to FP number
01:978F E3              	  1792: 		EX		(SP),HL			; Save input ptr, Get var addr
01:9790 CD75A2          	  1793: 		CALL	FPTHL			; Move FPREG to variable
01:9793 E1              	  1794: 		POP		HL				; Restore input pointer
01:9794 2B              	  1795: LTSTND: DEC		HL				; DEC 'cos GETCHR INCs
01:9795 CDD293          	  1796: 		CALL	GETCHR			; Get next character
01:9798 CAA097          	  1797: 		JP		Z,MORDT			; End of line - More needed?
01:979B FE2C            	  1798: 		CP		','				; Another value?
01:979D C2E696          	  1799: 		JP		NZ,BADINP		; No - Bad input
01:97A0 E3              	  1800: MORDT:	EX		(SP),HL			; Get code string address
01:97A1 2B              	  1801: 		DEC		HL				; DEC 'cos GETCHR INCs
01:97A2 CDD293          	  1802: 		CALL	GETCHR			; Get next character
01:97A5 C23397          	  1803: 		JP		NZ,NEDMOR		; More needed - Get it
01:97A8 D1              	  1804: 		POP		DE				; Restore DATA pointer
01:97A9 3ACD10          	  1805: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:97AC B7              	  1806: 		OR		A
01:97AD EB              	  1807: 		EX		DE,HL			; DATA pointer to HL
01:97AE C2F893          	  1808: 		JP		NZ,UPDATA		; Update DATA pointer if "READ"
01:97B1 D5              	  1809: 		PUSH	DE				; Save code string address
01:97B2 B6              	  1810: 		OR		(HL)			; More input given?
01:97B3 21BB97          	  1811: 		LD		HL,EXTIG		; "?Extra ignored" message
01:97B6 C4149D          	  1812: 		CALL	NZ,PRS			; Output string if extra given
01:97B9 E1              	  1813: 		POP		HL				; Restore code string address
01:97BA C9              	  1814: 		RET
                        	  1815: 
01:97BB 3F45787472612069	  1816: EXTIG:	db	"?Extra ignored",CR,LF,0
01:97C3 676E6F726564
01:97C9 0D
01:97CA 0A
01:97CB 00
                        	  1817: 
01:97CC CD6C95          	  1818: FDTLP:	CALL	DATAA			; Get next statement
01:97CF B7              	  1819: 		OR		A				; End of line?
01:97D0 C2E597          	  1820: 		JP		NZ,FANDT		; No - See if DATA statement
01:97D3 23              	  1821: 		INC		HL
01:97D4 7E              	  1822: 		LD		A,(HL)			; End of program?
01:97D5 23              	  1823: 		INC		HL
01:97D6 B6              	  1824: 		OR		(HL)			; 00 00 Ends program
01:97D7 1E06            	  1825: 		LD		E,OD			; ?OD Error
01:97D9 CA8E8F          	  1826: 		JP		Z,ERROR			; Yes - Out of DATA
01:97DC 23              	  1827: 		INC		HL
01:97DD 5E              	  1828: 		LD		E,(HL)			; LSB of line number
01:97DE 23              	  1829: 		INC		HL
01:97DF 56              	  1830: 		LD		D,(HL)			; MSB of line number
01:97E0 EB              	  1831: 		EX		DE,HL
01:97E1 22C910          	  1832: 		LD		(DATLIN),HL		; Set line of current DATA item
01:97E4 EB              	  1833: 		EX		DE,HL
01:97E5 CDD293          	  1834: FANDT:	CALL	GETCHR			; Get next character
01:97E8 FE83            	  1835: 		CP		ZDATA			; "DATA" token
01:97EA C2CC97          	  1836: 		JP		NZ,FDTLP		; No "DATA" - Keep looking
01:97ED C35F97          	  1837: 		JP		ANTVLU			; Found - Convert input
                        	  1838: 
01:97F0 110000          	  1839: NEXT:	LD		DE,0			; In case no index given
01:97F3 C4319A          	  1840: NEXT1:	CALL	NZ,GETVAR		; Get index address
01:97F6 22CE10          	  1841: 		LD		(BRKLIN),HL		; Save code string address
01:97F9 CD238F          	  1842: 		CALL	BAKSTK			; Look for "FOR" block
01:97FC C2808F          	  1843: 		JP		NZ,NFERR		; No "FOR" - ?NF Error
01:97FF F9              	  1844: 		LD		SP,HL			; Clear nested loops
01:9800 D5              	  1845: 		PUSH	DE				; Save index address
01:9801 7E              	  1846: 		LD		A,(HL)			; Get sign of STEP
01:9802 23              	  1847: 		INC		HL
01:9803 F5              	  1848: 		PUSH	AF				; Save sign of STEP
01:9804 D5              	  1849: 		PUSH	DE				; Save index address
01:9805 CD5BA2          	  1850: 		CALL	PHLTFP			; Move index value to FPREG
01:9808 E3              	  1851: 		EX		(SP),HL			; Save address of TO value
01:9809 E5              	  1852: 		PUSH	HL				; Save address of index
01:980A CDC89F          	  1853: 		CALL	ADDPHL			; Add STEP to index value
01:980D E1              	  1854: 		POP		HL				; Restore address of index
01:980E CD75A2          	  1855: 		CALL	FPTHL			; Move value to index variable
01:9811 E1              	  1856: 		POP		HL				; Restore address of TO value
01:9812 CD6CA2          	  1857: 		CALL	LOADFP			; Move TO value to BCDE
01:9815 E5              	  1858: 		PUSH	HL				; Save address of line of FOR
01:9816 CD98A2          	  1859: 		CALL	CMPNUM			; Compare index with TO value
01:9819 E1              	  1860: 		POP		HL				; Restore address of line num
01:981A C1              	  1861: 		POP		BC				; Address of sign of STEP
01:981B 90              	  1862: 		SUB		B				; Compare with expected sign
01:981C CD6CA2          	  1863: 		CALL	LOADFP			; BC = Loop stmt,DE = Line num
01:981F CA2B98          	  1864: 		JP		Z,KILFOR		; Loop finished - Terminate it
01:9822 EB              	  1865: 		EX		DE,HL			; Loop statement line number
01:9823 225C10          	  1866: 		LD		(LINEAT),HL		; Set loop line number
01:9826 69              	  1867: 		LD		L,C				; Set code string to loop
01:9827 60              	  1868: 		LD		H,B
01:9828 C38E93          	  1869: 		JP		PUTFID			; Put back "FOR" and continue
                        	  1870: 
01:982B F9              	  1871: KILFOR: LD		SP,HL			; Remove "FOR" block
01:982C 2ACE10          	  1872: 		LD		HL,(BRKLIN)		; Code string after "NEXT"
01:982F 7E              	  1873: 		LD		A,(HL)			; Get next byte in code string
01:9830 FE2C            	  1874: 		CP		','				; More NEXTs ?
01:9832 C29293          	  1875: 		JP		NZ,RUNCNT		; No - Do next statement
01:9835 CDD293          	  1876: 		CALL	GETCHR			; Position to index name
01:9838 CDF397          	  1877: 		CALL	NEXT1			; Re-enter NEXT routine
                        	  1878: ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        	  1879: 
01:983B CD4D98          	  1880: GETNUM: CALL	EVAL			; Get a numeric expression
01:983E F6              	  1881: TSTNUM: db	   0F6H			   ; Clear carry (numeric)
01:983F 37              	  1882: TSTSTR: SCF						; Set carry (string)
01:9840 3AAD10          	  1883: CHKTYP: LD		A,(TYPE)		; Check types match
01:9843 8F              	  1884: 		ADC		A,A				; Expected + actual
01:9844 B7              	  1885: 		OR		A				; Clear carry , set parity
01:9845 E8              	  1886: 		RET		PE				; Even parity - Types match
01:9846 C38C8F          	  1887: 		JP		TMERR			; Different types - Error
                        	  1888: 
01:9849 CD4892          	  1889: OPNPAR: CALL	CHKSYN			; Make sure "(" follows
01:984C 28              	  1890: 		db	"("
01:984D 2B              	  1891: EVAL:	DEC		HL				; Evaluate expression & save
01:984E 1600            	  1892: 		LD		D,0				; Precedence value
01:9850 D5              	  1893: EVAL1:	PUSH	DE				; Save precedence
01:9851 0E01            	  1894: 		LD		C,1
01:9853 CD578F          	  1895: 		CALL	CHKSTK			; Check for 1 level of stack
01:9856 CDC498          	  1896: 		CALL	OPRND			; Get next expression value
01:9859 22D010          	  1897: EVAL2:	LD		(NXTOPR),HL		; Save address of next operator
01:985C 2AD010          	  1898: EVAL3:	LD		HL,(NXTOPR)		; Restore address of next opr
01:985F C1              	  1899: 		POP		BC				; Precedence value and operator
01:9860 78              	  1900: 		LD		A,B				; Get precedence value
01:9861 FE78            	  1901: 		CP		78H				; "AND" or "OR" ?
01:9863 D43E98          	  1902: 		CALL	NC,TSTNUM		; No - Make sure it's a number
01:9866 7E              	  1903: 		LD		A,(HL)			; Get next operator / function
01:9867 1600            	  1904: 		LD		D,0				; Clear Last relation
01:9869 D6B3            	  1905: RLTLP:	SUB		ZGTR			; ">" Token
01:986B DA8598          	  1906: 		JP		C,FOPRND		; + - * / ^ AND OR - Test it
01:986E FE03            	  1907: 		CP		ZLTH+1-ZGTR		; < = >
01:9870 D28598          	  1908: 		JP		NC,FOPRND		; Function - Call it
01:9873 FE01            	  1909: 		CP		ZEQUAL-ZGTR		; "="
01:9875 17              	  1910: 		RLA						; <- Test for legal
01:9876 AA              	  1911: 		XOR		D				; <- combinations of < = >
01:9877 BA              	  1912: 		CP		D				; <- by combining last token
01:9878 57              	  1913: 		LD		D,A				; <- with current one
01:9879 DA7A8F          	  1914: 		JP		C,SNERR			; Error if "<<' '==" or ">>"
01:987C 22C510          	  1915: 		LD		(CUROPR),HL		; Save address of current token
01:987F CDD293          	  1916: 		CALL	GETCHR			; Get next character
01:9882 C36998          	  1917: 		JP		RLTLP			; Treat the two as one
                        	  1918: 
01:9885 7A              	  1919: FOPRND: LD		A,D				; < = > found ?
01:9886 B7              	  1920: 		OR		A
01:9887 C2AC99          	  1921: 		JP		NZ,TSTRED		; Yes - Test for reduction
01:988A 7E              	  1922: 		LD		A,(HL)			; Get operator token
01:988B 22C510          	  1923: 		LD		(CUROPR),HL		; Save operator address
01:988E D6AC            	  1924: 		SUB		ZPLUS			; Operator or function?
01:9890 D8              	  1925: 		RET		C				; Neither - Exit
01:9891 FE07            	  1926: 		CP		ZOR+1-ZPLUS		; Is it + - * / ^ AND OR ?
01:9893 D0              	  1927: 		RET		NC				; No - Exit
01:9894 5F              	  1928: 		LD		E,A				; Coded operator
01:9895 3AAD10          	  1929: 		LD		A,(TYPE)		; Get data type
01:9898 3D              	  1930: 		DEC		A				; FF = numeric , 00 = string
01:9899 B3              	  1931: 		OR		E				; Combine with coded operator
01:989A 7B              	  1932: 		LD		A,E				; Get coded operator
01:989B CA0A9E          	  1933: 		JP		Z,CONCAT		; String concatenation
01:989E 07              	  1934: 		RLCA					; Times 2
01:989F 83              	  1935: 		ADD		A,E				; Times 3
01:98A0 5F              	  1936: 		LD		E,A				; To DE (D is 0)
01:98A1 216C8E          	  1937: 		LD		HL,PRITAB		; Precedence table
01:98A4 19              	  1938: 		ADD		HL,DE			; To the operator concerned
01:98A5 78              	  1939: 		LD		A,B				; Last operator precedence
01:98A6 56              	  1940: 		LD		D,(HL)			; Get evaluation precedence
01:98A7 BA              	  1941: 		CP		D				; Compare with eval precedence
01:98A8 D0              	  1942: 		RET		NC				; Exit if higher precedence
01:98A9 23              	  1943: 		INC		HL				; Point to routine address
01:98AA CD3E98          	  1944: 		CALL	TSTNUM			; Make sure it's a number
                        	  1945: 
01:98AD C5              	  1946: STKTHS: PUSH	BC				; Save last precedence & token
01:98AE 015C98          	  1947: 		LD		BC,EVAL3		; Where to go on prec' break
01:98B1 C5              	  1948: 		PUSH	BC				; Save on stack for return
01:98B2 43              	  1949: 		LD		B,E				; Save operator
01:98B3 4A              	  1950: 		LD		C,D				; Save precedence
01:98B4 CD4EA2          	  1951: 		CALL	STAKFP			; Move value to stack
01:98B7 58              	  1952: 		LD		E,B				; Restore operator
01:98B8 51              	  1953: 		LD		D,C				; Restore precedence
01:98B9 4E              	  1954: 		LD		C,(HL)			; Get LSB of routine address
01:98BA 23              	  1955: 		INC		HL
01:98BB 46              	  1956: 		LD		B,(HL)			; Get MSB of routine address
01:98BC 23              	  1957: 		INC		HL
01:98BD C5              	  1958: 		PUSH	BC				; Save routine address
01:98BE 2AC510          	  1959: 		LD		HL,(CUROPR)		; Address of current operator
01:98C1 C35098          	  1960: 		JP		EVAL1			; Loop until prec' break
                        	  1961: 
01:98C4 AF              	  1962: OPRND:	XOR		A				; Get operand routine
01:98C5 32AD10          	  1963: 		LD		(TYPE),A		; Set numeric expected
01:98C8 CDD293          	  1964: 		CALL	GETCHR			; Get next character
01:98CB 1E24            	  1965: 		LD		E,MO			; ?MO Error
01:98CD CA8E8F          	  1966: 		JP		Z,ERROR			; No operand - Error
01:98D0 DA24A3          	  1967: 		JP		C,ASCTFP		; Number - Get value
01:98D3 CD7394          	  1968: 		CALL	CHKLTR			; See if a letter
01:98D6 D22B99          	  1969: 		JP		NC,CONVAR		; Letter - Find variable
01:98D9 FE26            	  1970: 		CP		'&'				; &H = HEX, &B = BINARY
01:98DB 2012            	  1971: 		JR		NZ, NOTAMP
01:98DD CDD293          	  1972: 		CALL	GETCHR			; Get next character
01:98E0 FE48            	  1973: 		CP		'H'				; Hex number indicated? [function added]
01:98E2 CA6CA7          	  1974: 		JP		Z,HEXTFP		; Convert Hex to FPREG
01:98E5 FE42            	  1975: 		CP		'B'				; Binary number indicated? [function added]
01:98E7 CADCA7          	  1976: 		JP		Z,BINTFP		; Convert Bin to FPREG
01:98EA 1E02            	  1977: 		LD		E,SN			; If neither then a ?SN Error
01:98EC CA8E8F          	  1978: 		JP		Z,ERROR			; 
01:98EF FEAC            	  1979: NOTAMP: CP		ZPLUS			; '+' Token ?
01:98F1 CAC498          	  1980: 		JP		Z,OPRND			; Yes - Look for operand
01:98F4 FE2E            	  1981: 		CP		'.'				; '.' ?
01:98F6 CA24A3          	  1982: 		JP		Z,ASCTFP		; Yes - Create FP number
01:98F9 FEAD            	  1983: 		CP		ZMINUS			; '-' Token ?
01:98FB CA1A99          	  1984: 		JP		Z,MINUS			; Yes - Do minus
01:98FE FE22            	  1985: 		CP		'"'				; Literal string ?
01:9900 CAD39C          	  1986: 		JP		Z,QTSTR			; Get string terminated by '"'
01:9903 FEAA            	  1987: 		CP		ZNOT			; "NOT" Token ?
01:9905 CA0C9A          	  1988: 		JP		Z,EVNOT			; Yes - Eval NOT expression
01:9908 FEA7            	  1989: 		CP		ZFN				; "FN" Token ?
01:990A CA379C          	  1990: 		JP		Z,DOFN			; Yes - Do FN routine
01:990D D6B6            	  1991: 		SUB		ZSGN			; Is it a function?
01:990F D23C99          	  1992: 		JP		NC,FNOFST		; Yes - Evaluate function
01:9912 CD4998          	  1993: EVLPAR: CALL	OPNPAR			; Evaluate expression in "()"
01:9915 CD4892          	  1994: 		CALL	CHKSYN			; Make sure ")" follows
01:9918 29              	  1995: 		db	")"
01:9919 C9              	  1996: 		RET
                        	  1997: 
01:991A 167D            	  1998: MINUS:	LD		D,7DH			; '-' precedence
01:991C CD5098          	  1999: 		CALL	EVAL1			; Evaluate until prec' break
01:991F 2AD010          	  2000: 		LD		HL,(NXTOPR)		; Get next operator address
01:9922 E5              	  2001: 		PUSH	HL				; Save next operator address
01:9923 CD46A2          	  2002: 		CALL	INVSGN			; Negate value
01:9926 CD3E98          	  2003: RETNUM: CALL	TSTNUM			; Make sure it's a number
01:9929 E1              	  2004: 		POP		HL				; Restore next operator address
01:992A C9              	  2005: 		RET
                        	  2006: 
01:992B CD319A          	  2007: CONVAR: CALL	GETVAR			; Get variable address to DE
01:992E E5              	  2008: FRMEVL: PUSH	HL				; Save code string address
01:992F EB              	  2009: 		EX		DE,HL			; Variable address to HL
01:9930 22E410          	  2010: 		LD		(FPREG),HL		; Save address of variable
01:9933 3AAD10          	  2011: 		LD		A,(TYPE)		; Get type
01:9936 B7              	  2012: 		OR		A				; Numeric?
01:9937 CC5BA2          	  2013: 		CALL	Z,PHLTFP		; Yes - Move contents to FPREG
01:993A E1              	  2014: 		POP		HL				; Restore code string address
01:993B C9              	  2015: 		RET
                        	  2016: 
01:993C 0600            	  2017: FNOFST: LD		B,0				; Get address of function
01:993E 07              	  2018: 		RLCA					; Double function offset
01:993F 4F              	  2019: 		LD		C,A				; BC = Offset in function table
01:9940 C5              	  2020: 		PUSH	BC				; Save adjusted token value
01:9941 CDD293          	  2021: 		CALL	GETCHR			; Get next character
01:9944 79              	  2022: 		LD		A,C				; Get adjusted token value
01:9945 FE31            	  2023: 		CP		2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
01:9947 DA6399          	  2024: 		JP		C,FNVAL			; No - Do function
01:994A CD4998          	  2025: 		CALL	OPNPAR			; Evaluate expression  (X,...
01:994D CD4892          	  2026: 		CALL	CHKSYN			; Make sure ',' follows
01:9950 2C              	  2027: 		db	   ','
01:9951 CD3F98          	  2028: 		CALL	TSTSTR			; Make sure it's a string
01:9954 EB              	  2029: 		EX		DE,HL			; Save code string address
01:9955 2AE410          	  2030: 		LD		HL,(FPREG)		; Get address of string
01:9958 E3              	  2031: 		EX		(SP),HL			; Save address of string
01:9959 E5              	  2032: 		PUSH	HL				; Save adjusted token value
01:995A EB              	  2033: 		EX		DE,HL			; Restore code string address
01:995B CD9C9F          	  2034: 		CALL	GETINT			; Get integer 0-255
01:995E EB              	  2035: 		EX		DE,HL			; Save code string address
01:995F E3              	  2036: 		EX		(SP),HL			; Save integer,HL = adj' token
01:9960 C36B99          	  2037: 		JP		GOFUNC			; Jump to string function
                        	  2038: 
01:9963 CD1299          	  2039: FNVAL:	CALL	EVLPAR			; Evaluate expression
01:9966 E3              	  2040: 		EX		(SP),HL			; HL = Adjusted token value
01:9967 112699          	  2041: 		LD		DE,RETNUM		; Return number from function
01:996A D5              	  2042: 		PUSH	DE				; Save on stack
01:996B 01C58C          	  2043: GOFUNC: LD		BC,FNCTAB		; Function routine addresses
01:996E 09              	  2044: 		ADD		HL,BC			; Point to right address
01:996F 4E              	  2045: 		LD		C,(HL)			; Get LSB of address
01:9970 23              	  2046: 		INC		HL				;
01:9971 66              	  2047: 		LD		H,(HL)			; Get MSB of address
01:9972 69              	  2048: 		LD		L,C				; Address to HL
01:9973 E9              	  2049: 		JP		(HL)			; Jump to function
                        	  2050: 
01:9974 15              	  2051: SGNEXP: DEC		D				; Dee to flag negative exponent
01:9975 FEAD            	  2052: 		CP		ZMINUS			; '-' token ?
01:9977 C8              	  2053: 		RET		Z				; Yes - Return
01:9978 FE2D            	  2054: 		CP		'-'				; '-' ASCII ?
01:997A C8              	  2055: 		RET		Z				; Yes - Return
01:997B 14              	  2056: 		INC		D				; Inc to flag positive exponent
01:997C FE2B            	  2057: 		CP		'+'				; '+' ASCII ?
01:997E C8              	  2058: 		RET		Z				; Yes - Return
01:997F FEAC            	  2059: 		CP		ZPLUS			; '+' token ?
01:9981 C8              	  2060: 		RET		Z				; Yes - Return
01:9982 2B              	  2061: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9983 C9              	  2062: 		RET						; Return "NZ"
                        	  2063: 
01:9984 F6              	  2064: POR:	db	   0F6H			   ; Flag "OR"
01:9985 AF              	  2065: PAND:	XOR		A				; Flag "AND"
01:9986 F5              	  2066: 		PUSH	AF				; Save "AND" / "OR" flag
01:9987 CD3E98          	  2067: 		CALL	TSTNUM			; Make sure it's a number
01:998A CD8794          	  2068: 		CALL	DEINT			; Get integer -32768 to 32767
01:998D F1              	  2069: 		POP		AF				; Restore "AND" / "OR" flag
01:998E EB              	  2070: 		EX		DE,HL			; <- Get last
01:998F C1              	  2071: 		POP		BC				; <-  value
01:9990 E3              	  2072: 		EX		(SP),HL			; <-  from
01:9991 EB              	  2073: 		EX		DE,HL			; <-  stack
01:9992 CD5EA2          	  2074: 		CALL	FPBCDE			; Move last value to FPREG
01:9995 F5              	  2075: 		PUSH	AF				; Save "AND" / "OR" flag
01:9996 CD8794          	  2076: 		CALL	DEINT			; Get integer -32768 to 32767
01:9999 F1              	  2077: 		POP		AF				; Restore "AND" / "OR" flag
01:999A C1              	  2078: 		POP		BC				; Get value
01:999B 79              	  2079: 		LD		A,C				; Get LSB
01:999C 21F59B          	  2080: 		LD		HL,ACPASS		; Address of save AC as current
01:999F C2A799          	  2081: 		JP		NZ,POR1			; Jump if OR
01:99A2 A3              	  2082: 		AND		E				; "AND" LSBs
01:99A3 4F              	  2083: 		LD		C,A				; Save LSB
01:99A4 78              	  2084: 		LD		A,B				; Get MBS
01:99A5 A2              	  2085: 		AND		D				; "AND" MSBs
01:99A6 E9              	  2086: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2087: 
01:99A7 B3              	  2088: POR1:	OR		E				; "OR" LSBs
01:99A8 4F              	  2089: 		LD		C,A				; Save LSB
01:99A9 78              	  2090: 		LD		A,B				; Get MSB
01:99AA B2              	  2091: 		OR		D				; "OR" MSBs
01:99AB E9              	  2092: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2093: 
01:99AC 21BE99          	  2094: TSTRED: LD		HL,CMPLOG		; Logical compare routine
01:99AF 3AAD10          	  2095: 		LD		A,(TYPE)		; Get data type
01:99B2 1F              	  2096: 		RRA						; Carry set = string
01:99B3 7A              	  2097: 		LD		A,D				; Get last precedence value
01:99B4 17              	  2098: 		RLA						; Times 2 plus carry
01:99B5 5F              	  2099: 		LD		E,A				; To E
01:99B6 1664            	  2100: 		LD		D,64H			; Relational precedence
01:99B8 78              	  2101: 		LD		A,B				; Get current precedence
01:99B9 BA              	  2102: 		CP		D				; Compare with last
01:99BA D0              	  2103: 		RET		NC				; Eval if last was rel' or log'
01:99BB C3AD98          	  2104: 		JP		STKTHS			; Stack this one and get next
                        	  2105: 
01:99BE C099            	  2106: CMPLOG: dw	CMPLG1			; Compare two values / strings
01:99C0 79              	  2107: CMPLG1: LD		A,C				; Get data type
01:99C1 B7              	  2108: 		OR		A
01:99C2 1F              	  2109: 		RRA
01:99C3 C1              	  2110: 		POP		BC				; Get last expression to BCDE
01:99C4 D1              	  2111: 		POP		DE
01:99C5 F5              	  2112: 		PUSH	AF				; Save status
01:99C6 CD4098          	  2113: 		CALL	CHKTYP			; Check that types match
01:99C9 21029A          	  2114: 		LD		HL,CMPRES		; Result to comparison
01:99CC E5              	  2115: 		PUSH	HL				; Save for RETurn
01:99CD CA98A2          	  2116: 		JP		Z,CMPNUM		; Compare values if numeric
01:99D0 AF              	  2117: 		XOR		A				; Compare two strings
01:99D1 32AD10          	  2118: 		LD		(TYPE),A		; Set type to numeric
01:99D4 D5              	  2119: 		PUSH	DE				; Save string name
01:99D5 CD579E          	  2120: 		CALL	GSTRCU			; Get current string
01:99D8 7E              	  2121: 		LD		A,(HL)			; Get length of string
01:99D9 23              	  2122: 		INC		HL
01:99DA 23              	  2123: 		INC		HL
01:99DB 4E              	  2124: 		LD		C,(HL)			; Get LSB of address
01:99DC 23              	  2125: 		INC		HL
01:99DD 46              	  2126: 		LD		B,(HL)			; Get MSB of address
01:99DE D1              	  2127: 		POP		DE				; Restore string name
01:99DF C5              	  2128: 		PUSH	BC				; Save address of string
01:99E0 F5              	  2129: 		PUSH	AF				; Save length of string
01:99E1 CD5B9E          	  2130: 		CALL	GSTRDE			; Get second string
01:99E4 CD6CA2          	  2131: 		CALL	LOADFP			; Get address of second string
01:99E7 F1              	  2132: 		POP		AF				; Restore length of string 1
01:99E8 57              	  2133: 		LD		D,A				; Length to D
01:99E9 E1              	  2134: 		POP		HL				; Restore address of string 1
01:99EA 7B              	  2135: CMPSTR: LD		A,E				; Bytes of string 2 to do
01:99EB B2              	  2136: 		OR		D				; Bytes of string 1 to do
01:99EC C8              	  2137: 		RET		Z				; Exit if all bytes compared
01:99ED 7A              	  2138: 		LD		A,D				; Get bytes of string 1 to do
01:99EE D601            	  2139: 		SUB		1
01:99F0 D8              	  2140: 		RET		C				; Exit if end of string 1
01:99F1 AF              	  2141: 		XOR		A
01:99F2 BB              	  2142: 		CP		E				; Bytes of string 2 to do
01:99F3 3C              	  2143: 		INC		A
01:99F4 D0              	  2144: 		RET		NC				; Exit if end of string 2
01:99F5 15              	  2145: 		DEC		D				; Count bytes in string 1
01:99F6 1D              	  2146: 		DEC		E				; Count bytes in string 2
01:99F7 0A              	  2147: 		LD		A,(BC)			; Byte in string 2
01:99F8 BE              	  2148: 		CP		(HL)			; Compare to byte in string 1
01:99F9 23              	  2149: 		INC		HL				; Move up string 1
01:99FA 03              	  2150: 		INC		BC				; Move up string 2
01:99FB CAEA99          	  2151: 		JP		Z,CMPSTR		; Same - Try next bytes
01:99FE 3F              	  2152: 		CCF						; Flag difference (">" or "<")
01:99FF C328A2          	  2153: 		JP		FLGDIF			; "<" gives -1 , ">" gives +1
                        	  2154: 
01:9A02 3C              	  2155: CMPRES: INC		A				; Increment current value
01:9A03 8F              	  2156: 		ADC		A,A				; Double plus carry
01:9A04 C1              	  2157: 		POP		BC				; Get other value
01:9A05 A0              	  2158: 		AND		B				; Combine them
01:9A06 C6FF            	  2159: 		ADD		A,-1			; Carry set if different
01:9A08 9F              	  2160: 		SBC		A,A				; 00 - Equal , FF - Different
01:9A09 C32FA2          	  2161: 		JP		FLGREL			; Set current value & continue
                        	  2162: 
01:9A0C 165A            	  2163: EVNOT:	LD		D,5AH			; Precedence value for "NOT"
01:9A0E CD5098          	  2164: 		CALL	EVAL1			; Eval until precedence break
01:9A11 CD3E98          	  2165: 		CALL	TSTNUM			; Make sure it's a number
01:9A14 CD8794          	  2166: 		CALL	DEINT			; Get integer -32768 - 32767
01:9A17 7B              	  2167: 		LD		A,E				; Get LSB
01:9A18 2F              	  2168: 		CPL						; Invert LSB
01:9A19 4F              	  2169: 		LD		C,A				; Save "NOT" of LSB
01:9A1A 7A              	  2170: 		LD		A,D				; Get MSB
01:9A1B 2F              	  2171: 		CPL						; Invert MSB
01:9A1C CDF59B          	  2172: 		CALL	ACPASS			; Save AC as current
01:9A1F C1              	  2173: 		POP		BC				; Clean up stack
01:9A20 C35C98          	  2174: 		JP		EVAL3			; Continue evaluation
                        	  2175: 
01:9A23 2B              	  2176: DIMRET: DEC		HL				; DEC 'cos GETCHR INCs
01:9A24 CDD293          	  2177: 		CALL	GETCHR			; Get next character
01:9A27 C8              	  2178: 		RET		Z				; End of DIM statement
01:9A28 CD4892          	  2179: 		CALL	CHKSYN			; Make sure ',' follows
01:9A2B 2C              	  2180: 		db	   ','
01:9A2C 01239A          	  2181: DIM:	LD		BC,DIMRET		; Return to "DIMRET"
01:9A2F C5              	  2182: 		PUSH	BC				; Save on stack
01:9A30 F6              	  2183: 		db	   0F6H			   ; Flag "Create" variable
01:9A31 AF              	  2184: GETVAR: XOR		A				; Find variable address,to DE
01:9A32 32AC10          	  2185: 		LD		(LCRFLG),A		; Set locate / create flag
01:9A35 46              	  2186: 		LD		B,(HL)			; Get First byte of name
01:9A36 CD7394          	  2187: GTFNAM: CALL	CHKLTR			; See if a letter
01:9A39 DA7A8F          	  2188: 		JP		C,SNERR			; ?SN Error if not a letter
01:9A3C AF              	  2189: 		XOR		A
01:9A3D 4F              	  2190: 		LD		C,A				; Clear second byte of name
01:9A3E 32AD10          	  2191: 		LD		(TYPE),A		; Set type to numeric
01:9A41 CDD293          	  2192: 		CALL	GETCHR			; Get next character
01:9A44 DA4D9A          	  2193: 		JP		C,SVNAM2		; Numeric - Save in name
01:9A47 CD7394          	  2194: 		CALL	CHKLTR			; See if a letter
01:9A4A DA5A9A          	  2195: 		JP		C,CHARTY		; Not a letter - Check type
01:9A4D 4F              	  2196: SVNAM2: LD		C,A				; Save second byte of name
01:9A4E CDD293          	  2197: ENDNAM: CALL	GETCHR			; Get next character
01:9A51 DA4E9A          	  2198: 		JP		C,ENDNAM		; Numeric - Get another
01:9A54 CD7394          	  2199: 		CALL	CHKLTR			; See if a letter
01:9A57 D24E9A          	  2200: 		JP		NC,ENDNAM		; Letter - Get another
01:9A5A D624            	  2201: CHARTY: SUB		'$'				; String variable?
01:9A5C C2699A          	  2202: 		JP		NZ,NOTSTR		; No - Numeric variable
01:9A5F 3C              	  2203: 		INC		A				; A = 1 (string type)
01:9A60 32AD10          	  2204: 		LD		(TYPE),A		; Set type to string
01:9A63 0F              	  2205: 		RRCA					; A = 80H , Flag for string
01:9A64 81              	  2206: 		ADD		A,C				; 2nd byte of name has bit 7 on
01:9A65 4F              	  2207: 		LD		C,A				; Resave second byte on name
01:9A66 CDD293          	  2208: 		CALL	GETCHR			; Get next character
01:9A69 3ACB10          	  2209: NOTSTR: LD		A,(FORFLG)		; Array name needed ?
01:9A6C 3D              	  2210: 		DEC		A
01:9A6D CA169B          	  2211: 		JP		Z,ARLDSV		; Yes - Get array name
01:9A70 F2799A          	  2212: 		JP		P,NSCFOR		; No array with "FOR" or "FN"
01:9A73 7E              	  2213: 		LD		A,(HL)			; Get byte again
01:9A74 D628            	  2214: 		SUB		'('				; Subscripted variable?
01:9A76 CAEE9A          	  2215: 		JP		Z,SBSCPT		; Yes - Sort out subscript
                        	  2216: 
01:9A79 AF              	  2217: NSCFOR: XOR		A				; Simple variable
01:9A7A 32CB10          	  2218: 		LD		(FORFLG),A		; Clear "FOR" flag
01:9A7D E5              	  2219: 		PUSH	HL				; Save code string address
01:9A7E 50              	  2220: 		LD		D,B				; DE = Variable name to find
01:9A7F 59              	  2221: 		LD		E,C
01:9A80 2ADE10          	  2222: 		LD		HL,(FNRGNM)		; FN argument name
01:9A83 CD4292          	  2223: 		CALL	CPDEHL			; Is it the FN argument?
01:9A86 11E010          	  2224: 		LD		DE,FNARG		; Point to argument value
01:9A89 CA5EA1          	  2225: 		JP		Z,POPHRT		; Yes - Return FN argument value
01:9A8C 2AD810          	  2226: 		LD		HL,(VAREND)		; End of variables
01:9A8F EB              	  2227: 		EX		DE,HL			; Address of end of search
01:9A90 2AD610          	  2228: 		LD		HL,(PROGND)		; Start of variables address
01:9A93 CD4292          	  2229: FNDVAR: CALL	CPDEHL			; End of variable list table?
01:9A96 CAAC9A          	  2230: 		JP		Z,CFEVAL		; Yes - Called from EVAL?
01:9A99 79              	  2231: 		LD		A,C				; Get second byte of name
01:9A9A 96              	  2232: 		SUB		(HL)			; Compare with name in list
01:9A9B 23              	  2233: 		INC		HL				; Move on to first byte
01:9A9C C2A19A          	  2234: 		JP		NZ,FNTHR		; Different - Find another
01:9A9F 78              	  2235: 		LD		A,B				; Get first byte of name
01:9AA0 96              	  2236: 		SUB		(HL)			; Compare with name in list
01:9AA1 23              	  2237: FNTHR:	INC		HL				; Move on to LSB of value
01:9AA2 CAE09A          	  2238: 		JP		Z,RETADR		; Found - Return address
01:9AA5 23              	  2239: 		INC		HL				; <- Skip
01:9AA6 23              	  2240: 		INC		HL				; <- over
01:9AA7 23              	  2241: 		INC		HL				; <- F.P.
01:9AA8 23              	  2242: 		INC		HL				; <- value
01:9AA9 C3939A          	  2243: 		JP		FNDVAR			; Keep looking
                        	  2244: 
01:9AAC E1              	  2245: CFEVAL: POP		HL				; Restore code string address
01:9AAD E3              	  2246: 		EX		(SP),HL			; Get return address
01:9AAE D5              	  2247: 		PUSH	DE				; Save address of variable
01:9AAF 112E99          	  2248: 		LD		DE,FRMEVL		; Return address in EVAL
01:9AB2 CD4292          	  2249: 		CALL	CPDEHL			; Called from EVAL ?
01:9AB5 D1              	  2250: 		POP		DE				; Restore address of variable
01:9AB6 CAE39A          	  2251: 		JP		Z,RETNUL		; Yes - Return null variable
01:9AB9 E3              	  2252: 		EX		(SP),HL			; Put back return
01:9ABA E5              	  2253: 		PUSH	HL				; Save code string address
01:9ABB C5              	  2254: 		PUSH	BC				; Save variable name
01:9ABC 010600          	  2255: 		LD		BC,6			; 2 byte name plus 4 byte data
01:9ABF 2ADA10          	  2256: 		LD		HL,(ARREND)		; End of arrays
01:9AC2 E5              	  2257: 		PUSH	HL				; Save end of arrays
01:9AC3 09              	  2258: 		ADD		HL,BC			; Move up 6 bytes
01:9AC4 C1              	  2259: 		POP		BC				; Source address in BC
01:9AC5 E5              	  2260: 		PUSH	HL				; Save new end address
01:9AC6 CD468F          	  2261: 		CALL	MOVUP			; Move arrays up
01:9AC9 E1              	  2262: 		POP		HL				; Restore new end address
01:9ACA 22DA10          	  2263: 		LD		(ARREND),HL		; Set new end address
01:9ACD 60              	  2264: 		LD		H,B				; End of variables to HL
01:9ACE 69              	  2265: 		LD		L,C
01:9ACF 22D810          	  2266: 		LD		(VAREND),HL		; Set new end address
                        	  2267: 
01:9AD2 2B              	  2268: ZEROLP: DEC		HL				; Back through to zero variable
01:9AD3 3600            	  2269: 		LD		(HL),0			; Zero byte in variable
01:9AD5 CD4292          	  2270: 		CALL	CPDEHL			; Done them all?
01:9AD8 C2D29A          	  2271: 		JP		NZ,ZEROLP		; No - Keep on going
01:9ADB D1              	  2272: 		POP		DE				; Get variable name
01:9ADC 73              	  2273: 		LD		(HL),E			; Store second character
01:9ADD 23              	  2274: 		INC		HL
01:9ADE 72              	  2275: 		LD		(HL),D			; Store first character
01:9ADF 23              	  2276: 		INC		HL
01:9AE0 EB              	  2277: RETADR: EX		DE,HL			; Address of variable in DE
01:9AE1 E1              	  2278: 		POP		HL				; Restore code string address
01:9AE2 C9              	  2279: 		RET
                        	  2280: 
01:9AE3 32E710          	  2281: RETNUL: LD		(FPEXP),A		; Set result to zero
01:9AE6 21168F          	  2282: 		LD		HL,ZERBYT		; Also set a null string
01:9AE9 22E410          	  2283: 		LD		(FPREG),HL		; Save for EVAL
01:9AEC E1              	  2284: 		POP		HL				; Restore code string address
01:9AED C9              	  2285: 		RET
                        	  2286: 
01:9AEE E5              	  2287: SBSCPT: PUSH	HL				; Save code string address
01:9AEF 2AAC10          	  2288: 		LD		HL,(LCRFLG)		; Locate/Create and Type
01:9AF2 E3              	  2289: 		EX		(SP),HL			; Save and get code string
01:9AF3 57              	  2290: 		LD		D,A				; Zero number of dimensions
01:9AF4 D5              	  2291: SCPTLP: PUSH	DE				; Save number of dimensions
01:9AF5 C5              	  2292: 		PUSH	BC				; Save array name
01:9AF6 CD7B94          	  2293: 		CALL	FPSINT			; Get subscript (0-32767)
01:9AF9 C1              	  2294: 		POP		BC				; Restore array name
01:9AFA F1              	  2295: 		POP		AF				; Get number of dimensions
01:9AFB EB              	  2296: 		EX		DE,HL
01:9AFC E3              	  2297: 		EX		(SP),HL			; Save subscript value
01:9AFD E5              	  2298: 		PUSH	HL				; Save LCRFLG and TYPE
01:9AFE EB              	  2299: 		EX		DE,HL
01:9AFF 3C              	  2300: 		INC		A				; Count dimensions
01:9B00 57              	  2301: 		LD		D,A				; Save in D
01:9B01 7E              	  2302: 		LD		A,(HL)			; Get next byte in code string
01:9B02 FE2C            	  2303: 		CP		','				; Comma (more to come)?
01:9B04 CAF49A          	  2304: 		JP		Z,SCPTLP		; Yes - More subscripts
01:9B07 CD4892          	  2305: 		CALL	CHKSYN			; Make sure ")" follows
01:9B0A 29              	  2306: 		db	   ")"
01:9B0B 22D010          	  2307: 		LD		(NXTOPR),HL		; Save code string address
01:9B0E E1              	  2308: 		POP		HL				; Get LCRFLG and TYPE
01:9B0F 22AC10          	  2309: 		LD		(LCRFLG),HL		; Restore Locate/create & type
01:9B12 1E00            	  2310: 		LD		E,0				; Flag not CSAVE* or CLOAD*
01:9B14 D5              	  2311: 		PUSH	DE				; Save number of dimensions (D)
01:9B15 11              	  2312: 		db	   11H			   ; Skip "PUSH HL" and "PUSH AF'
                        	  2313: 
01:9B16 E5              	  2314: ARLDSV: PUSH	HL				; Save code string address
01:9B17 F5              	  2315: 		PUSH	AF				; A = 00 , Flags set = Z,N
01:9B18 2AD810          	  2316: 		LD		HL,(VAREND)		; Start of arrays
01:9B1B 3E              	  2317: 		db	   3EH			   ; Skip "ADD HL,DE"
01:9B1C 19              	  2318: FNDARY: ADD		HL,DE			; Move to next array start
01:9B1D EB              	  2319: 		EX		DE,HL
01:9B1E 2ADA10          	  2320: 		LD		HL,(ARREND)		; End of arrays
01:9B21 EB              	  2321: 		EX		DE,HL			; Current array pointer
01:9B22 CD4292          	  2322: 		CALL	CPDEHL			; End of arrays found?
01:9B25 CA4E9B          	  2323: 		JP		Z,CREARY		; Yes - Create array
01:9B28 7E              	  2324: 		LD		A,(HL)			; Get second byte of name
01:9B29 B9              	  2325: 		CP		C				; Compare with name given
01:9B2A 23              	  2326: 		INC		HL				; Move on
01:9B2B C2309B          	  2327: 		JP		NZ,NXTARY		; Different - Find next array
01:9B2E 7E              	  2328: 		LD		A,(HL)			; Get first byte of name
01:9B2F B8              	  2329: 		CP		B				; Compare with name given
01:9B30 23              	  2330: NXTARY: INC		HL				; Move on
01:9B31 5E              	  2331: 		LD		E,(HL)			; Get LSB of next array address
01:9B32 23              	  2332: 		INC		HL
01:9B33 56              	  2333: 		LD		D,(HL)			; Get MSB of next array address
01:9B34 23              	  2334: 		INC		HL
01:9B35 C21C9B          	  2335: 		JP		NZ,FNDARY		; Not found - Keep looking
01:9B38 3AAC10          	  2336: 		LD		A,(LCRFLG)		; Found Locate or Create it?
01:9B3B B7              	  2337: 		OR		A
01:9B3C C2838F          	  2338: 		JP		NZ,DDERR		; Create - ?DD Error
01:9B3F F1              	  2339: 		POP		AF				; Locate - Get number of dim'ns
01:9B40 44              	  2340: 		LD		B,H				; BC Points to array dim'ns
01:9B41 4D              	  2341: 		LD		C,L
01:9B42 CA5EA1          	  2342: 		JP		Z,POPHRT		; Jump if array load/save
01:9B45 96              	  2343: 		SUB		(HL)			; Same number of dimensions?
01:9B46 CAAC9B          	  2344: 		JP		Z,FINDEL		; Yes - Find element
01:9B49 1E10            	  2345: BSERR:	LD		E,BS			; ?BS Error
01:9B4B C38E8F          	  2346: 		JP		ERROR			; Output error
                        	  2347: 
01:9B4E 110400          	  2348: CREARY: LD		DE,4			; 4 Bytes per entry
01:9B51 F1              	  2349: 		POP		AF				; Array to save or 0 dim'ns?
01:9B52 CA9C94          	  2350: 		JP		Z,FCERR			; Yes - ?FC Error
01:9B55 71              	  2351: 		LD		(HL),C			; Save second byte of name
01:9B56 23              	  2352: 		INC		HL
01:9B57 70              	  2353: 		LD		(HL),B			; Save first byte of name
01:9B58 23              	  2354: 		INC		HL
01:9B59 4F              	  2355: 		LD		C,A				; Number of dimensions to C
01:9B5A CD578F          	  2356: 		CALL	CHKSTK			; Check if enough memory
01:9B5D 23              	  2357: 		INC		HL				; Point to number of dimensions
01:9B5E 23              	  2358: 		INC		HL
01:9B5F 22C510          	  2359: 		LD		(CUROPR),HL		; Save address of pointer
01:9B62 71              	  2360: 		LD		(HL),C			; Set number of dimensions
01:9B63 23              	  2361: 		INC		HL
01:9B64 3AAC10          	  2362: 		LD		A,(LCRFLG)		; Locate of Create?
01:9B67 17              	  2363: 		RLA						; Carry set = Create
01:9B68 79              	  2364: 		LD		A,C				; Get number of dimensions
01:9B69 010B00          	  2365: CRARLP: LD		BC,10+1			; Default dimension size 10
01:9B6C D2719B          	  2366: 		JP		NC,DEFSIZ		; Locate - Set default size
01:9B6F C1              	  2367: 		POP		BC				; Get specified dimension size
01:9B70 03              	  2368: 		INC		BC				; Include zero element
01:9B71 71              	  2369: DEFSIZ: LD		(HL),C			; Save LSB of dimension size
01:9B72 23              	  2370: 		INC		HL
01:9B73 70              	  2371: 		LD		(HL),B			; Save MSB of dimension size
01:9B74 23              	  2372: 		INC		HL
01:9B75 F5              	  2373: 		PUSH	AF				; Save num' of dim'ns an status
01:9B76 E5              	  2374: 		PUSH	HL				; Save address of dim'n size
01:9B77 CD09A3          	  2375: 		CALL	MLDEBC			; Multiply DE by BC to find
01:9B7A EB              	  2376: 		EX		DE,HL			; amount of mem needed (to DE)
01:9B7B E1              	  2377: 		POP		HL				; Restore address of dimension
01:9B7C F1              	  2378: 		POP		AF				; Restore number of dimensions
01:9B7D 3D              	  2379: 		DEC		A				; Count them
01:9B7E C2699B          	  2380: 		JP		NZ,CRARLP		; Do next dimension if more
01:9B81 F5              	  2381: 		PUSH	AF				; Save locate/create flag
01:9B82 42              	  2382: 		LD		B,D				; MSB of memory needed
01:9B83 4B              	  2383: 		LD		C,E				; LSB of memory needed
01:9B84 EB              	  2384: 		EX		DE,HL
01:9B85 19              	  2385: 		ADD		HL,DE			; Add bytes to array start
01:9B86 DA6F8F          	  2386: 		JP		C,OMERR			; Too big - Error
01:9B89 CD608F          	  2387: 		CALL	ENFMEM			; See if enough memory
01:9B8C 22DA10          	  2388: 		LD		(ARREND),HL		; Save new end of array
                        	  2389: 
01:9B8F 2B              	  2390: ZERARY: DEC		HL				; Back through array data
01:9B90 3600            	  2391: 		LD		(HL),0			; Set array element to zero
01:9B92 CD4292          	  2392: 		CALL	CPDEHL			; All elements zeroed?
01:9B95 C28F9B          	  2393: 		JP		NZ,ZERARY		; No - Keep on going
01:9B98 03              	  2394: 		INC		BC				; Number of bytes + 1
01:9B99 57              	  2395: 		LD		D,A				; A=0
01:9B9A 2AC510          	  2396: 		LD		HL,(CUROPR)		; Get address of array
01:9B9D 5E              	  2397: 		LD		E,(HL)			; Number of dimensions
01:9B9E EB              	  2398: 		EX		DE,HL			; To HL
01:9B9F 29              	  2399: 		ADD		HL,HL			; Two bytes per dimension size
01:9BA0 09              	  2400: 		ADD		HL,BC			; Add number of bytes
01:9BA1 EB              	  2401: 		EX		DE,HL			; Bytes needed to DE
01:9BA2 2B              	  2402: 		DEC		HL
01:9BA3 2B              	  2403: 		DEC		HL
01:9BA4 73              	  2404: 		LD		(HL),E			; Save LSB of bytes needed
01:9BA5 23              	  2405: 		INC		HL
01:9BA6 72              	  2406: 		LD		(HL),D			; Save MSB of bytes needed
01:9BA7 23              	  2407: 		INC		HL
01:9BA8 F1              	  2408: 		POP		AF				; Locate / Create?
01:9BA9 DAD09B          	  2409: 		JP		C,ENDDIM		; A is 0 , End if create
01:9BAC 47              	  2410: FINDEL: LD		B,A				; Find array element
01:9BAD 4F              	  2411: 		LD		C,A
01:9BAE 7E              	  2412: 		LD		A,(HL)			; Number of dimensions
01:9BAF 23              	  2413: 		INC		HL
01:9BB0 16              	  2414: 		db	   16H			   ; Skip "POP HL"
01:9BB1 E1              	  2415: FNDELP: POP		HL				; Address of next dim' size
01:9BB2 5E              	  2416: 		LD		E,(HL)			; Get LSB of dim'n size
01:9BB3 23              	  2417: 		INC		HL
01:9BB4 56              	  2418: 		LD		D,(HL)			; Get MSB of dim'n size
01:9BB5 23              	  2419: 		INC		HL
01:9BB6 E3              	  2420: 		EX		(SP),HL			; Save address - Get index
01:9BB7 F5              	  2421: 		PUSH	AF				; Save number of dim'ns
01:9BB8 CD4292          	  2422: 		CALL	CPDEHL			; Dimension too large?
01:9BBB D2499B          	  2423: 		JP		NC,BSERR		; Yes - ?BS Error
01:9BBE E5              	  2424: 		PUSH	HL				; Save index
01:9BBF CD09A3          	  2425: 		CALL	MLDEBC			; Multiply previous by size
01:9BC2 D1              	  2426: 		POP		DE				; Index supplied to DE
01:9BC3 19              	  2427: 		ADD		HL,DE			; Add index to pointer
01:9BC4 F1              	  2428: 		POP		AF				; Number of dimensions
01:9BC5 3D              	  2429: 		DEC		A				; Count them
01:9BC6 44              	  2430: 		LD		B,H				; MSB of pointer
01:9BC7 4D              	  2431: 		LD		C,L				; LSB of pointer
01:9BC8 C2B19B          	  2432: 		JP		NZ,FNDELP		; More - Keep going
01:9BCB 29              	  2433: 		ADD		HL,HL			; 4 Bytes per element
01:9BCC 29              	  2434: 		ADD		HL,HL
01:9BCD C1              	  2435: 		POP		BC				; Start of array
01:9BCE 09              	  2436: 		ADD		HL,BC			; Point to element
01:9BCF EB              	  2437: 		EX		DE,HL			; Address of element to DE
01:9BD0 2AD010          	  2438: ENDDIM: LD		HL,(NXTOPR)		; Got code string address
01:9BD3 C9              	  2439: 		RET
                        	  2440: 
01:9BD4 2ADA10          	  2441: FRE:	LD		HL,(ARREND)		; Start of free memory
01:9BD7 EB              	  2442: 		EX		DE,HL			; To DE
01:9BD8 210000          	  2443: 		LD		HL,0			; End of free memory
01:9BDB 39              	  2444: 		ADD		HL,SP			; Current stack value
01:9BDC 3AAD10          	  2445: 		LD		A,(TYPE)		; Dummy argument type
01:9BDF B7              	  2446: 		OR		A
01:9BE0 CAF09B          	  2447: 		JP		Z,FRENUM		; Numeric - Free variable space
01:9BE3 CD579E          	  2448: 		CALL	GSTRCU			; Current string to pool
01:9BE6 CD579D          	  2449: 		CALL	GARBGE			; Garbage collection
01:9BE9 2A5A10          	  2450: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9BEC EB              	  2451: 		EX		DE,HL			; To DE
01:9BED 2AC310          	  2452: 		LD		HL,(STRBOT)		; Bottom of string space
01:9BF0 7D              	  2453: FRENUM: LD		A,L				; Get LSB of end
01:9BF1 93              	  2454: 		SUB		E				; Subtract LSB of beginning
01:9BF2 4F              	  2455: 		LD		C,A				; Save difference if C
01:9BF3 7C              	  2456: 		LD		A,H				; Get MSB of end
01:9BF4 9A              	  2457: 		SBC		A,D				; Subtract MSB of beginning
01:9BF5 41              	  2458: ACPASS: LD		B,C				; Return integer AC
01:9BF6 50              	  2459: ABPASS: LD		D,B				; Return integer AB
01:9BF7 1E00            	  2460: 		LD		E,0
01:9BF9 21AD10          	  2461: 		LD		HL,TYPE			; Point to type
01:9BFC 73              	  2462: 		LD		(HL),E			; Set type to numeric
01:9BFD 0690            	  2463: 		LD		B,80H+16		; 16 bit integer
01:9BFF C334A2          	  2464: 		JP		RETINT			; Return the integr
                        	  2465: 
01:9C02 3AAB10          	  2466: POS:	LD		A,(CURPOS)		; Get cursor position
01:9C05 47              	  2467: PASSA:	LD		B,A				; Put A into AB
01:9C06 AF              	  2468: 		XOR		A				; Zero A
01:9C07 C3F69B          	  2469: 		JP		ABPASS			; Return integer AB
                        	  2470: 
01:9C0A CD8D9C          	  2471: DEF:	CALL	CHEKFN			; Get "FN" and name
01:9C0D CD7F9C          	  2472: 		CALL	IDTEST			; Test for illegal direct
01:9C10 016C95          	  2473: 		LD		BC,DATAA			; To get next statement
01:9C13 C5              	  2474: 		PUSH	BC				; Save address for RETurn
01:9C14 D5              	  2475: 		PUSH	DE				; Save address of function ptr
01:9C15 CD4892          	  2476: 		CALL	CHKSYN			; Make sure "(" follows
01:9C18 28              	  2477: 		db	   "("
01:9C19 CD319A          	  2478: 		CALL	GETVAR			; Get argument variable name
01:9C1C E5              	  2479: 		PUSH	HL				; Save code string address
01:9C1D EB              	  2480: 		EX		DE,HL			; Argument address to HL
01:9C1E 2B              	  2481: 		DEC		HL
01:9C1F 56              	  2482: 		LD		D,(HL)			; Get first byte of arg name
01:9C20 2B              	  2483: 		DEC		HL
01:9C21 5E              	  2484: 		LD		E,(HL)			; Get second byte of arg name
01:9C22 E1              	  2485: 		POP		HL				; Restore code string address
01:9C23 CD3E98          	  2486: 		CALL	TSTNUM			; Make sure numeric argument
01:9C26 CD4892          	  2487: 		CALL	CHKSYN			; Make sure ")" follows
01:9C29 29              	  2488: 		db	   ")"
01:9C2A CD4892          	  2489: 		CALL	CHKSYN			; Make sure "=" follows
01:9C2D B4              	  2490: 		db	   ZEQUAL		   ; "=" token
01:9C2E 44              	  2491: 		LD		B,H				; Code string address to BC
01:9C2F 4D              	  2492: 		LD		C,L
01:9C30 E3              	  2493: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C31 71              	  2494: 		LD		(HL),C			; Save LSB of FN code string
01:9C32 23              	  2495: 		INC		HL
01:9C33 70              	  2496: 		LD		(HL),B			; Save MSB of FN code string
01:9C34 C3CC9C          	  2497: 		JP		SVSTAD			; Save address and do function
                        	  2498: 
01:9C37 CD8D9C          	  2499: DOFN:	CALL	CHEKFN			; Make sure FN follows
01:9C3A D5              	  2500: 		PUSH	DE				; Save function pointer address
01:9C3B CD1299          	  2501: 		CALL	EVLPAR			; Evaluate expression in "()"
01:9C3E CD3E98          	  2502: 		CALL	TSTNUM			; Make sure numeric result
01:9C41 E3              	  2503: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C42 5E              	  2504: 		LD		E,(HL)			; Get LSB of FN code string
01:9C43 23              	  2505: 		INC		HL
01:9C44 56              	  2506: 		LD		D,(HL)			; Get MSB of FN code string
01:9C45 23              	  2507: 		INC		HL
01:9C46 7A              	  2508: 		LD		A,D				; And function DEFined?
01:9C47 B3              	  2509: 		OR		E
01:9C48 CA868F          	  2510: 		JP		Z,UFERR			; No - ?UF Error
01:9C4B 7E              	  2511: 		LD		A,(HL)			; Get LSB of argument address
01:9C4C 23              	  2512: 		INC		HL
01:9C4D 66              	  2513: 		LD		H,(HL)			; Get MSB of argument address
01:9C4E 6F              	  2514: 		LD		L,A				; HL = Arg variable address
01:9C4F E5              	  2515: 		PUSH	HL				; Save it
01:9C50 2ADE10          	  2516: 		LD		HL,(FNRGNM)		; Get old argument name
01:9C53 E3              	  2517: 		EX		(SP),HL ;		; Save old , Get new
01:9C54 22DE10          	  2518: 		LD		(FNRGNM),HL		; Set new argument name
01:9C57 2AE210          	  2519: 		LD		HL,(FNARG+2)	; Get LSB,NLSB of old arg value
01:9C5A E5              	  2520: 		PUSH	HL				; Save it
01:9C5B 2AE010          	  2521: 		LD		HL,(FNARG)		; Get MSB,EXP of old arg value
01:9C5E E5              	  2522: 		PUSH	HL				; Save it
01:9C5F 21E010          	  2523: 		LD		HL,FNARG		; HL = Value of argument
01:9C62 D5              	  2524: 		PUSH	DE				; Save FN code string address
01:9C63 CD75A2          	  2525: 		CALL	FPTHL			; Move FPREG to argument
01:9C66 E1              	  2526: 		POP		HL				; Get FN code string address
01:9C67 CD3B98          	  2527: 		CALL	GETNUM			; Get value from function
01:9C6A 2B              	  2528: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9C6B CDD293          	  2529: 		CALL	GETCHR			; Get next character
01:9C6E C27A8F          	  2530: 		JP		NZ,SNERR		; Bad character in FN - Error
01:9C71 E1              	  2531: 		POP		HL				; Get MSB,EXP of old arg
01:9C72 22E010          	  2532: 		LD		(FNARG),HL		; Restore it
01:9C75 E1              	  2533: 		POP		HL				; Get LSB,NLSB of old arg
01:9C76 22E210          	  2534: 		LD		(FNARG+2),HL	; Restore it
01:9C79 E1              	  2535: 		POP		HL				; Get name of old arg
01:9C7A 22DE10          	  2536: 		LD		(FNRGNM),HL		; Restore it
01:9C7D E1              	  2537: 		POP		HL				; Restore code string address
01:9C7E C9              	  2538: 		RET
                        	  2539: 
01:9C7F E5              	  2540: IDTEST: PUSH	HL				; Save code string address
01:9C80 2A5C10          	  2541: 		LD		HL,(LINEAT)		; Get current line number
01:9C83 23              	  2542: 		INC		HL				; -1 means direct statement
01:9C84 7C              	  2543: 		LD		A,H
01:9C85 B5              	  2544: 		OR		L
01:9C86 E1              	  2545: 		POP		HL				; Restore code string address
01:9C87 C0              	  2546: 		RET		NZ				; Return if in program
01:9C88 1E16            	  2547: 		LD		E,ID			; ?ID Error
01:9C8A C38E8F          	  2548: 		JP		ERROR
                        	  2549: 
01:9C8D CD4892          	  2550: CHEKFN: CALL	CHKSYN			; Make sure FN follows
01:9C90 A7              	  2551: 		db	   ZFN			   ; "FN" token
01:9C91 3E80            	  2552: 		LD		A,80H
01:9C93 32CB10          	  2553: 		LD		(FORFLG),A		; Flag FN name to find
01:9C96 B6              	  2554: 		OR		(HL)			; FN name has bit 7 set
01:9C97 47              	  2555: 		LD		B,A				; in first byte of name
01:9C98 CD369A          	  2556: 		CALL	GTFNAM			; Get FN name
01:9C9B C33E98          	  2557: 		JP		TSTNUM			; Make sure numeric function
                        	  2558: 
01:9C9E CD3E98          	  2559: STRR:	CALL	TSTNUM			; Make sure it's a number
01:9CA1 CDC2A3          	  2560: 		CALL	NUMASC			; Turn number into text
01:9CA4 CDD29C          	  2561: STR1:	CALL	CRTST			; Create string entry for it
01:9CA7 CD579E          	  2562: 		CALL	GSTRCU			; Current string to pool
01:9CAA 01B29E          	  2563: 		LD		BC,TOPOOL		; Save in string pool
01:9CAD C5              	  2564: 		PUSH	BC				; Save address on stack
                        	  2565: 
01:9CAE 7E              	  2566: SAVSTR: LD		A,(HL)			; Get string length
01:9CAF 23              	  2567: 		INC		HL
01:9CB0 23              	  2568: 		INC		HL
01:9CB1 E5              	  2569: 		PUSH	HL				; Save pointer to string
01:9CB2 CD2D9D          	  2570: 		CALL	TESTR			; See if enough string space
01:9CB5 E1              	  2571: 		POP		HL				; Restore pointer to string
01:9CB6 4E              	  2572: 		LD		C,(HL)			; Get LSB of address
01:9CB7 23              	  2573: 		INC		HL
01:9CB8 46              	  2574: 		LD		B,(HL)			; Get MSB of address
01:9CB9 CDC69C          	  2575: 		CALL	CRTMST			; Create string entry
01:9CBC E5              	  2576: 		PUSH	HL				; Save pointer to MSB of addr
01:9CBD 6F              	  2577: 		LD		L,A				; Length of string
01:9CBE CD4A9E          	  2578: 		CALL	TOSTRA			; Move to string area
01:9CC1 D1              	  2579: 		POP		DE				; Restore pointer to MSB
01:9CC2 C9              	  2580: 		RET
                        	  2581: 
01:9CC3 CD2D9D          	  2582: MKTMST: CALL	TESTR			; See if enough string space
01:9CC6 21BF10          	  2583: CRTMST: LD		HL,TMPSTR		; Temporary string
01:9CC9 E5              	  2584: 		PUSH	HL				; Save it
01:9CCA 77              	  2585: 		LD		(HL),A			; Save length of string
01:9CCB 23              	  2586: 		INC		HL
01:9CCC 23              	  2587: SVSTAD: INC		HL
01:9CCD 73              	  2588: 		LD		(HL),E			; Save LSB of address
01:9CCE 23              	  2589: 		INC		HL
01:9CCF 72              	  2590: 		LD		(HL),D			; Save MSB of address
01:9CD0 E1              	  2591: 		POP		HL				; Restore pointer
01:9CD1 C9              	  2592: 		RET
                        	  2593: 
01:9CD2 2B              	  2594: CRTST:	DEC		HL				; DEC - INCed after
01:9CD3 0622            	  2595: QTSTR:	LD		B,'"'			; Terminating quote "
01:9CD5 50              	  2596: 		LD		D,B				; Quote to D
01:9CD6 E5              	  2597: DTSTR:	PUSH	HL				; Save start
01:9CD7 0EFF            	  2598: 		LD		C,-1			; Set counter to -1
01:9CD9 23              	  2599: QTSTLP: INC		HL				; Move on
01:9CDA 7E              	  2600: 		LD		A,(HL)			; Get byte
01:9CDB 0C              	  2601: 		INC		C				; Count bytes
01:9CDC B7              	  2602: 		OR		A				; End of line?
01:9CDD CAE89C          	  2603: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CE0 BA              	  2604: 		CP		D				; Terminator D found?
01:9CE1 CAE89C          	  2605: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CE4 B8              	  2606: 		CP		B				; Terminator B found?
01:9CE5 C2D99C          	  2607: 		JP		NZ,QTSTLP		; No - Keep looking
01:9CE8 FE22            	  2608: CRTSTE: CP		'"'				; End with '"'?
01:9CEA CCD293          	  2609: 		CALL	Z,GETCHR		; Yes - Get next character
01:9CED E3              	  2610: 		EX		(SP),HL			; Starting quote
01:9CEE 23              	  2611: 		INC		HL				; First byte of string
01:9CEF EB              	  2612: 		EX		DE,HL			; To DE
01:9CF0 79              	  2613: 		LD		A,C				; Get length
01:9CF1 CDC69C          	  2614: 		CALL	CRTMST			; Create string entry
01:9CF4 11BF10          	  2615: TSTOPL: LD		DE,TMPSTR		; Temporary string
01:9CF7 2AB110          	  2616: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9CFA 22E410          	  2617: 		LD		(FPREG),HL		; Save address of string ptr
01:9CFD 3E01            	  2618: 		LD		A,1
01:9CFF 32AD10          	  2619: 		LD		(TYPE),A		; Set type to string
01:9D02 CD78A2          	  2620: 		CALL	DETHL4			; Move string to pool
01:9D05 CD4292          	  2621: 		CALL	CPDEHL			; Out of string pool?
01:9D08 22B110          	  2622: 		LD		(TMSTPT),HL		; Save new pointer
01:9D0B E1              	  2623: 		POP		HL				; Restore code string address
01:9D0C 7E              	  2624: 		LD		A,(HL)			; Get next code byte
01:9D0D C0              	  2625: 		RET		NZ				; Return if pool OK
01:9D0E 1E1E            	  2626: 		LD		E,ST			; ?ST Error
01:9D10 C38E8F          	  2627: 		JP		ERROR			; String pool overflow
                        	  2628: 
01:9D13 23              	  2629: PRNUMS: INC		HL				; Skip leading space
01:9D14 CDD29C          	  2630: PRS:	CALL	CRTST			; Create string entry for it
01:9D17 CD579E          	  2631: PRS1:	CALL	GSTRCU			; Current string to pool
01:9D1A CD6CA2          	  2632: 		CALL	LOADFP			; Move string block to BCDE
01:9D1D 1C              	  2633: 		INC		E				; Length + 1
01:9D1E 1D              	  2634: PRSLP:	DEC		E				; Count characters
01:9D1F C8              	  2635: 		RET		Z				; End of string
01:9D20 0A              	  2636: 		LD		A,(BC)			; Get byte to output
01:9D21 CD5392          	  2637: 		CALL	OUTC			; Output character in A
01:9D24 FE0D            	  2638: 		CP		CR				; Return?
01:9D26 CC8096          	  2639: 		CALL	Z,DONULL		; Yes - Do nulls
01:9D29 03              	  2640: 		INC		BC				; Next byte in string
01:9D2A C31E9D          	  2641: 		JP		PRSLP			; More characters to output
                        	  2642: 
01:9D2D B7              	  2643: TESTR:	OR		A				; Test if enough room
01:9D2E 0E              	  2644: 		db	   0EH			   ; No garbage collection done
01:9D2F F1              	  2645: GRBDON: POP		AF				; Garbage collection done
01:9D30 F5              	  2646: 		PUSH	AF				; Save status
01:9D31 2A5A10          	  2647: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9D34 EB              	  2648: 		EX		DE,HL			; To DE
01:9D35 2AC310          	  2649: 		LD		HL,(STRBOT)		; Bottom of string area
01:9D38 2F              	  2650: 		CPL						; Negate length (Top down)
01:9D39 4F              	  2651: 		LD		C,A				; -Length to BC
01:9D3A 06FF            	  2652: 		LD		B,-1			; BC = -ve length of string
01:9D3C 09              	  2653: 		ADD		HL,BC			; Add to bottom of space in use
01:9D3D 23              	  2654: 		INC		HL				; Plus one for 2's complement
01:9D3E CD4292          	  2655: 		CALL	CPDEHL			; Below string RAM area?
01:9D41 DA4B9D          	  2656: 		JP		C,TESTOS		; Tidy up if not done else err
01:9D44 22C310          	  2657: 		LD		(STRBOT),HL		; Save new bottom of area
01:9D47 23              	  2658: 		INC		HL				; Point to first byte of string
01:9D48 EB              	  2659: 		EX		DE,HL			; Address to DE
01:9D49 F1              	  2660: POPAF:	POP		AF				; Throw away status push
01:9D4A C9              	  2661: 		RET
                        	  2662: 
01:9D4B F1              	  2663: TESTOS: POP		AF				; Garbage collect been done?
01:9D4C 1E1A            	  2664: 		LD		E,OS			; ?OS Error
01:9D4E CA8E8F          	  2665: 		JP		Z,ERROR			; Yes - Not enough string apace
01:9D51 BF              	  2666: 		CP		A				; Flag garbage collect done
01:9D52 F5              	  2667: 		PUSH	AF				; Save status
01:9D53 012F9D          	  2668: 		LD		BC,GRBDON		; Garbage collection done
01:9D56 C5              	  2669: 		PUSH	BC				; Save for RETurn
01:9D57 2AAF10          	  2670: GARBGE: LD		HL,(LSTRAM)		; Get end of RAM pointer
01:9D5A 22C310          	  2671: GARBLP: LD		(STRBOT),HL		; Reset string pointer
01:9D5D 210000          	  2672: 		LD		HL,0
01:9D60 E5              	  2673: 		PUSH	HL				; Flag no string found
01:9D61 2A5A10          	  2674: 		LD		HL,(STRSPC)		; Get bottom of string space
01:9D64 E5              	  2675: 		PUSH	HL				; Save bottom of string space
01:9D65 21B310          	  2676: 		LD		HL,TMSTPL		; Temporary string pool
01:9D68 EB              	  2677: GRBLP:	EX		DE,HL
01:9D69 2AB110          	  2678: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9D6C EB              	  2679: 		EX		DE,HL
01:9D6D CD4292          	  2680: 		CALL	CPDEHL			; Temporary string pool done?
01:9D70 01689D          	  2681: 		LD		BC,GRBLP		; Loop until string pool done
01:9D73 C2BC9D          	  2682: 		JP		NZ,STPOOL		; No - See if in string area
01:9D76 2AD610          	  2683: 		LD		HL,(PROGND)		; Start of simple variables
01:9D79 EB              	  2684: SMPVAR: EX		DE,HL
01:9D7A 2AD810          	  2685: 		LD		HL,(VAREND)		; End of simple variables
01:9D7D EB              	  2686: 		EX		DE,HL
01:9D7E CD4292          	  2687: 		CALL	CPDEHL			; All simple strings done?
01:9D81 CA8F9D          	  2688: 		JP		Z,ARRLP			; Yes - Do string arrays
01:9D84 7E              	  2689: 		LD		A,(HL)			; Get type of variable
01:9D85 23              	  2690: 		INC		HL
01:9D86 23              	  2691: 		INC		HL
01:9D87 B7              	  2692: 		OR		A				; "S" flag set if string
01:9D88 CDBF9D          	  2693: 		CALL	STRADD			; See if string in string area
01:9D8B C3799D          	  2694: 		JP		SMPVAR			; Loop until simple ones done
                        	  2695: 
01:9D8E C1              	  2696: GNXARY: POP		BC				; Scrap address of this array
01:9D8F EB              	  2697: ARRLP:	EX		DE,HL
01:9D90 2ADA10          	  2698: 		LD		HL,(ARREND)		; End of string arrays
01:9D93 EB              	  2699: 		EX		DE,HL
01:9D94 CD4292          	  2700: 		CALL	CPDEHL			; All string arrays done?
01:9D97 CAE59D          	  2701: 		JP		Z,SCNEND		; Yes - Move string if found
01:9D9A CD6CA2          	  2702: 		CALL	LOADFP			; Get array name to BCDE
01:9D9D 7B              	  2703: 		LD		A,E				; Get type of array		
01:9D9E E5              	  2704: 		PUSH	HL				; Save address of num of dim'ns
01:9D9F 09              	  2705: 		ADD		HL,BC			; Start of next array
01:9DA0 B7              	  2706: 		OR		A				; Test type of array
01:9DA1 F28E9D          	  2707: 		JP		P,GNXARY		; Numeric array - Ignore it
01:9DA4 22C510          	  2708: 		LD		(CUROPR),HL		; Save address of next array
01:9DA7 E1              	  2709: 		POP		HL				; Get address of num of dim'ns
01:9DA8 4E              	  2710: 		LD		C,(HL)			; BC = Number of dimensions
01:9DA9 0600            	  2711: 		LD		B,0
01:9DAB 09              	  2712: 		ADD		HL,BC			; Two bytes per dimension size
01:9DAC 09              	  2713: 		ADD		HL,BC
01:9DAD 23              	  2714: 		INC		HL				; Plus one for number of dim'ns
01:9DAE EB              	  2715: GRBARY: EX		DE,HL
01:9DAF 2AC510          	  2716: 		LD		HL,(CUROPR)		; Get address of next array
01:9DB2 EB              	  2717: 		EX		DE,HL
01:9DB3 CD4292          	  2718: 		CALL	CPDEHL			; Is this array finished?
01:9DB6 CA8F9D          	  2719: 		JP		Z,ARRLP			; Yes - Get next one
01:9DB9 01AE9D          	  2720: 		LD		BC,GRBARY		; Loop until array all done
01:9DBC C5              	  2721: STPOOL: PUSH	BC				; Save return address
01:9DBD F680            	  2722: 		OR		80H				; Flag string type
01:9DBF 7E              	  2723: STRADD: LD		A,(HL)			; Get string length
01:9DC0 23              	  2724: 		INC		HL
01:9DC1 23              	  2725: 		INC		HL
01:9DC2 5E              	  2726: 		LD		E,(HL)			; Get LSB of string address
01:9DC3 23              	  2727: 		INC		HL
01:9DC4 56              	  2728: 		LD		D,(HL)			; Get MSB of string address
01:9DC5 23              	  2729: 		INC		HL
01:9DC6 F0              	  2730: 		RET		P				; Not a string - Return
01:9DC7 B7              	  2731: 		OR		A				; Set flags on string length
01:9DC8 C8              	  2732: 		RET		Z				; Null string - Return
01:9DC9 44              	  2733: 		LD		B,H				; Save variable pointer
01:9DCA 4D              	  2734: 		LD		C,L
01:9DCB 2AC310          	  2735: 		LD		HL,(STRBOT)		; Bottom of new area
01:9DCE CD4292          	  2736: 		CALL	CPDEHL			; String been done?
01:9DD1 60              	  2737: 		LD		H,B				; Restore variable pointer
01:9DD2 69              	  2738: 		LD		L,C
01:9DD3 D8              	  2739: 		RET		C				; String done - Ignore
01:9DD4 E1              	  2740: 		POP		HL				; Return address
01:9DD5 E3              	  2741: 		EX		(SP),HL			; Lowest available string area
01:9DD6 CD4292          	  2742: 		CALL	CPDEHL			; String within string area?
01:9DD9 E3              	  2743: 		EX		(SP),HL			; Lowest available string area
01:9DDA E5              	  2744: 		PUSH	HL				; Re-save return address
01:9DDB 60              	  2745: 		LD		H,B				; Restore variable pointer
01:9DDC 69              	  2746: 		LD		L,C
01:9DDD D0              	  2747: 		RET		NC				; Outside string area - Ignore
01:9DDE C1              	  2748: 		POP		BC				; Get return , Throw 2 away
01:9DDF F1              	  2749: 		POP		AF				; 
01:9DE0 F1              	  2750: 		POP		AF				; 
01:9DE1 E5              	  2751: 		PUSH	HL				; Save variable pointer
01:9DE2 D5              	  2752: 		PUSH	DE				; Save address of current
01:9DE3 C5              	  2753: 		PUSH	BC				; Put back return address
01:9DE4 C9              	  2754: 		RET						; Go to it
                        	  2755: 
01:9DE5 D1              	  2756: SCNEND: POP		DE				; Addresses of strings
01:9DE6 E1              	  2757: 		POP		HL				; 
01:9DE7 7D              	  2758: 		LD		A,L				; HL = 0 if no more to do
01:9DE8 B4              	  2759: 		OR		H
01:9DE9 C8              	  2760: 		RET		Z				; No more to do - Return
01:9DEA 2B              	  2761: 		DEC		HL
01:9DEB 46              	  2762: 		LD		B,(HL)			; MSB of address of string
01:9DEC 2B              	  2763: 		DEC		HL
01:9DED 4E              	  2764: 		LD		C,(HL)			; LSB of address of string
01:9DEE E5              	  2765: 		PUSH	HL				; Save variable address
01:9DEF 2B              	  2766: 		DEC		HL
01:9DF0 2B              	  2767: 		DEC		HL
01:9DF1 6E              	  2768: 		LD		L,(HL)			; HL = Length of string
01:9DF2 2600            	  2769: 		LD		H,0
01:9DF4 09              	  2770: 		ADD		HL,BC			; Address of end of string+1
01:9DF5 50              	  2771: 		LD		D,B				; String address to DE
01:9DF6 59              	  2772: 		LD		E,C
01:9DF7 2B              	  2773: 		DEC		HL				; Last byte in string
01:9DF8 44              	  2774: 		LD		B,H				; Address to BC
01:9DF9 4D              	  2775: 		LD		C,L
01:9DFA 2AC310          	  2776: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9DFD CD498F          	  2777: 		CALL	MOVSTR			; Move string to new address
01:9E00 E1              	  2778: 		POP		HL				; Restore variable address
01:9E01 71              	  2779: 		LD		(HL),C			; Save new LSB of address
01:9E02 23              	  2780: 		INC		HL
01:9E03 70              	  2781: 		LD		(HL),B			; Save new MSB of address
01:9E04 69              	  2782: 		LD		L,C				; Next string area+1 to HL
01:9E05 60              	  2783: 		LD		H,B
01:9E06 2B              	  2784: 		DEC		HL				; Next string area address
01:9E07 C35A9D          	  2785: 		JP		GARBLP			; Look for more strings
                        	  2786: 
01:9E0A C5              	  2787: CONCAT: PUSH	BC				; Save prec' opr & code string
01:9E0B E5              	  2788: 		PUSH	HL				; 
01:9E0C 2AE410          	  2789: 		LD		HL,(FPREG)		; Get first string
01:9E0F E3              	  2790: 		EX		(SP),HL			; Save first string
01:9E10 CDC498          	  2791: 		CALL	OPRND			; Get second string
01:9E13 E3              	  2792: 		EX		(SP),HL			; Restore first string
01:9E14 CD3F98          	  2793: 		CALL	TSTSTR			; Make sure it's a string
01:9E17 7E              	  2794: 		LD		A,(HL)			; Get length of second string
01:9E18 E5              	  2795: 		PUSH	HL				; Save first string
01:9E19 2AE410          	  2796: 		LD		HL,(FPREG)		; Get second string
01:9E1C E5              	  2797: 		PUSH	HL				; Save second string
01:9E1D 86              	  2798: 		ADD		A,(HL)			; Add length of second string
01:9E1E 1E1C            	  2799: 		LD		E,LS			; ?LS Error
01:9E20 DA8E8F          	  2800: 		JP		C,ERROR			; String too long - Error
01:9E23 CDC39C          	  2801: 		CALL	MKTMST			; Make temporary string
01:9E26 D1              	  2802: 		POP		DE				; Get second string to DE
01:9E27 CD5B9E          	  2803: 		CALL	GSTRDE			; Move to string pool if needed
01:9E2A E3              	  2804: 		EX		(SP),HL			; Get first string
01:9E2B CD5A9E          	  2805: 		CALL	GSTRHL			; Move to string pool if needed
01:9E2E E5              	  2806: 		PUSH	HL				; Save first string
01:9E2F 2AC110          	  2807: 		LD		HL,(TMPSTR+2)	; Temporary string address
01:9E32 EB              	  2808: 		EX		DE,HL			; To DE
01:9E33 CD419E          	  2809: 		CALL	SSTSA			; First string to string area
01:9E36 CD419E          	  2810: 		CALL	SSTSA			; Second string to string area
01:9E39 215998          	  2811: 		LD		HL,EVAL2		; Return to evaluation loop
01:9E3C E3              	  2812: 		EX		(SP),HL			; Save return,get code string
01:9E3D E5              	  2813: 		PUSH	HL				; Save code string address
01:9E3E C3F49C          	  2814: 		JP		TSTOPL			; To temporary string to pool
                        	  2815: 
01:9E41 E1              	  2816: SSTSA:	POP		HL				; Return address
01:9E42 E3              	  2817: 		EX		(SP),HL			; Get string block,save return
01:9E43 7E              	  2818: 		LD		A,(HL)			; Get length of string
01:9E44 23              	  2819: 		INC		HL
01:9E45 23              	  2820: 		INC		HL
01:9E46 4E              	  2821: 		LD		C,(HL)			; Get LSB of string address
01:9E47 23              	  2822: 		INC		HL
01:9E48 46              	  2823: 		LD		B,(HL)			; Get MSB of string address
01:9E49 6F              	  2824: 		LD		L,A				; Length to L
01:9E4A 2C              	  2825: TOSTRA: INC		L				; INC - DECed after
01:9E4B 2D              	  2826: TSALP:	DEC		L				; Count bytes moved
01:9E4C C8              	  2827: 		RET		Z				; End of string - Return
01:9E4D 0A              	  2828: 		LD		A,(BC)			; Get source
01:9E4E 12              	  2829: 		LD		(DE),A			; Save destination
01:9E4F 03              	  2830: 		INC		BC				; Next source
01:9E50 13              	  2831: 		INC		DE				; Next destination
01:9E51 C34B9E          	  2832: 		JP		TSALP			; Loop until string moved
                        	  2833: 
01:9E54 CD3F98          	  2834: GETSTR: CALL	TSTSTR			; Make sure it's a string
01:9E57 2AE410          	  2835: GSTRCU: LD		HL,(FPREG)		; Get current string
01:9E5A EB              	  2836: GSTRHL: EX		DE,HL			; Save DE
01:9E5B CD759E          	  2837: GSTRDE: CALL	BAKTMP			; Was it last tmp-str?
01:9E5E EB              	  2838: 		EX		DE,HL			; Restore DE
01:9E5F C0              	  2839: 		RET		NZ				; No - Return
01:9E60 D5              	  2840: 		PUSH	DE				; Save string
01:9E61 50              	  2841: 		LD		D,B				; String block address to DE
01:9E62 59              	  2842: 		LD		E,C
01:9E63 1B              	  2843: 		DEC		DE				; Point to length
01:9E64 4E              	  2844: 		LD		C,(HL)			; Get string length
01:9E65 2AC310          	  2845: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9E68 CD4292          	  2846: 		CALL	CPDEHL			; Last one in string area?
01:9E6B C2739E          	  2847: 		JP		NZ,POPHL		; No - Return
01:9E6E 47              	  2848: 		LD		B,A				; Clear B (A=0)
01:9E6F 09              	  2849: 		ADD		HL,BC			; Remove string from str' area
01:9E70 22C310          	  2850: 		LD		(STRBOT),HL		; Save new bottom of str' area
01:9E73 E1              	  2851: POPHL:	POP		HL				; Restore string
01:9E74 C9              	  2852: 		RET
                        	  2853: 
01:9E75 2AB110          	  2854: BAKTMP: LD		HL,(TMSTPT)		; Get temporary string pool top
01:9E78 2B              	  2855: 		DEC		HL				; Back
01:9E79 46              	  2856: 		LD		B,(HL)			; Get MSB of address
01:9E7A 2B              	  2857: 		DEC		HL				; Back
01:9E7B 4E              	  2858: 		LD		C,(HL)			; Get LSB of address
01:9E7C 2B              	  2859: 		DEC		HL				; Back
01:9E7D 2B              	  2860: 		DEC		HL				; Back
01:9E7E CD4292          	  2861: 		CALL	CPDEHL			; String last in string pool?
01:9E81 C0              	  2862: 		RET		NZ				; Yes - Leave it
01:9E82 22B110          	  2863: 		LD		(TMSTPT),HL		; Save new string pool top
01:9E85 C9              	  2864: 		RET
                        	  2865: 
01:9E86 01059C          	  2866: LEN:	LD		BC,PASSA		; To return integer A
01:9E89 C5              	  2867: 		PUSH	BC				; Save address
01:9E8A CD549E          	  2868: GETLEN: CALL	GETSTR			; Get string and its length
01:9E8D AF              	  2869: 		XOR		A
01:9E8E 57              	  2870: 		LD		D,A				; Clear D
01:9E8F 32AD10          	  2871: 		LD		(TYPE),A		; Set type to numeric
01:9E92 7E              	  2872: 		LD		A,(HL)			; Get length of string
01:9E93 B7              	  2873: 		OR		A				; Set status flags
01:9E94 C9              	  2874: 		RET
                        	  2875: 
01:9E95 01059C          	  2876: ASCC:	LD		BC,PASSA		; To return integer A
01:9E98 C5              	  2877: 		PUSH	BC				; Save address
01:9E99 CD8A9E          	  2878: GTFLNM: CALL	GETLEN			; Get length of string
01:9E9C CA9C94          	  2879: 		JP		Z,FCERR			; Null string - Error
01:9E9F 23              	  2880: 		INC		HL
01:9EA0 23              	  2881: 		INC		HL
01:9EA1 5E              	  2882: 		LD		E,(HL)			; Get LSB of address
01:9EA2 23              	  2883: 		INC		HL
01:9EA3 56              	  2884: 		LD		D,(HL)			; Get MSB of address
01:9EA4 1A              	  2885: 		LD		A,(DE)			; Get first byte of string
01:9EA5 C9              	  2886: 		RET
                        	  2887: 
01:9EA6 3E01            	  2888: CHR:	LD		A,1				; One character string
01:9EA8 CDC39C          	  2889: 		CALL	MKTMST			; Make a temporary string
01:9EAB CD9F9F          	  2890: 		CALL	MAKINT			; Make it integer A
01:9EAE 2AC110          	  2891: 		LD		HL,(TMPSTR+2)	; Get address of string
01:9EB1 73              	  2892: 		LD		(HL),E			; Save character
01:9EB2 C1              	  2893: TOPOOL: POP		BC				; Clean up stack
01:9EB3 C3F49C          	  2894: 		JP		TSTOPL			; Temporary string to pool
                        	  2895: 
01:9EB6 CD4F9F          	  2896: LEFT:	CALL	LFRGNM			; Get number and ending ")"
01:9EB9 AF              	  2897: 		XOR		A				; Start at first byte in string
01:9EBA E3              	  2898: RIGHT1: EX		(SP),HL			; Save code string,Get string
01:9EBB 4F              	  2899: 		LD		C,A				; Starting position in string
01:9EBC E5              	  2900: MID1:	PUSH	HL				; Save string block address
01:9EBD 7E              	  2901: 		LD		A,(HL)			; Get length of string
01:9EBE B8              	  2902: 		CP		B				; Compare with number given
01:9EBF DAC49E          	  2903: 		JP		C,ALLFOL		; All following bytes required
01:9EC2 78              	  2904: 		LD		A,B				; Get new length
01:9EC3 11              	  2905: 		db	   11H			   ; Skip "LD C,0"
01:9EC4 0E00            	  2906: ALLFOL: LD		C,0				; First byte of string
01:9EC6 C5              	  2907: 		PUSH	BC				; Save position in string
01:9EC7 CD2D9D          	  2908: 		CALL	TESTR			; See if enough string space
01:9ECA C1              	  2909: 		POP		BC				; Get position in string
01:9ECB E1              	  2910: 		POP		HL				; Restore string block address
01:9ECC E5              	  2911: 		PUSH	HL				; And re-save it
01:9ECD 23              	  2912: 		INC		HL
01:9ECE 23              	  2913: 		INC		HL
01:9ECF 46              	  2914: 		LD		B,(HL)			; Get LSB of address
01:9ED0 23              	  2915: 		INC		HL
01:9ED1 66              	  2916: 		LD		H,(HL)			; Get MSB of address
01:9ED2 68              	  2917: 		LD		L,B				; HL = address of string
01:9ED3 0600            	  2918: 		LD		B,0				; BC = starting address
01:9ED5 09              	  2919: 		ADD		HL,BC			; Point to that byte
01:9ED6 44              	  2920: 		LD		B,H				; BC = source string
01:9ED7 4D              	  2921: 		LD		C,L
01:9ED8 CDC69C          	  2922: 		CALL	CRTMST			; Create a string entry
01:9EDB 6F              	  2923: 		LD		L,A				; Length of new string
01:9EDC CD4A9E          	  2924: 		CALL	TOSTRA			; Move string to string area
01:9EDF D1              	  2925: 		POP		DE				; Clear stack
01:9EE0 CD5B9E          	  2926: 		CALL	GSTRDE			; Move to string pool if needed
01:9EE3 C3F49C          	  2927: 		JP		TSTOPL			; Temporary string to pool
                        	  2928: 
01:9EE6 CD4F9F          	  2929: RIGHT:	CALL	LFRGNM			; Get number and ending ")"
01:9EE9 D1              	  2930: 		POP		DE				; Get string length
01:9EEA D5              	  2931: 		PUSH	DE				; And re-save
01:9EEB 1A              	  2932: 		LD		A,(DE)			; Get length
01:9EEC 90              	  2933: 		SUB		B				; Move back N bytes
01:9EED C3BA9E          	  2934: 		JP		RIGHT1			; Go and get sub-string
                        	  2935: 
01:9EF0 EB              	  2936: MID:	EX		DE,HL			; Get code string address
01:9EF1 7E              	  2937: 		LD		A,(HL)			; Get next byte ',' or ")"
01:9EF2 CD549F          	  2938: 		CALL	MIDNUM			; Get number supplied
01:9EF5 04              	  2939: 		INC		B				; Is it character zero?
01:9EF6 05              	  2940: 		DEC		B
01:9EF7 CA9C94          	  2941: 		JP		Z,FCERR			; Yes - Error
01:9EFA C5              	  2942: 		PUSH	BC				; Save starting position
01:9EFB 1EFF            	  2943: 		LD		E,255			; All of string
01:9EFD FE29            	  2944: 		CP		')'				; Any length given?
01:9EFF CA099F          	  2945: 		JP		Z,RSTSTR		; No - Rest of string
01:9F02 CD4892          	  2946: 		CALL	CHKSYN			; Make sure ',' follows
01:9F05 2C              	  2947: 		db	   ','
01:9F06 CD9C9F          	  2948: 		CALL	GETINT			; Get integer 0-255
01:9F09 CD4892          	  2949: RSTSTR: CALL	CHKSYN			; Make sure ")" follows
01:9F0C 29              	  2950: 		db	   ")"
01:9F0D F1              	  2951: 		POP		AF				; Restore starting position
01:9F0E E3              	  2952: 		EX		(SP),HL			; Get string,8ave code string
01:9F0F 01BC9E          	  2953: 		LD		BC,MID1			; Continuation of MID$ routine
01:9F12 C5              	  2954: 		PUSH	BC				; Save for return
01:9F13 3D              	  2955: 		DEC		A				; Starting position-1
01:9F14 BE              	  2956: 		CP		(HL)			; Compare with length
01:9F15 0600            	  2957: 		LD		B,0				; Zero bytes length
01:9F17 D0              	  2958: 		RET		NC				; Null string if start past end
01:9F18 4F              	  2959: 		LD		C,A				; Save starting position-1
01:9F19 7E              	  2960: 		LD		A,(HL)			; Get length of string
01:9F1A 91              	  2961: 		SUB		C				; Subtract start
01:9F1B BB              	  2962: 		CP		E				; Enough string for it?
01:9F1C 47              	  2963: 		LD		B,A				; Save maximum length available
01:9F1D D8              	  2964: 		RET		C				; Truncate string if needed
01:9F1E 43              	  2965: 		LD		B,E				; Set specified length
01:9F1F C9              	  2966: 		RET						; Go and create string
                        	  2967: 
01:9F20 CD8A9E          	  2968: VAL:	CALL	GETLEN			; Get length of string
01:9F23 CA3DA0          	  2969: 		JP		Z,RESZER		; Result zero
01:9F26 5F              	  2970: 		LD		E,A				; Save length
01:9F27 23              	  2971: 		INC		HL
01:9F28 23              	  2972: 		INC		HL
01:9F29 7E              	  2973: 		LD		A,(HL)			; Get LSB of address
01:9F2A 23              	  2974: 		INC		HL
01:9F2B 66              	  2975: 		LD		H,(HL)			; Get MSB of address
01:9F2C 6F              	  2976: 		LD		L,A				; HL = String address
01:9F2D E5              	  2977: 		PUSH	HL				; Save string address
01:9F2E 19              	  2978: 		ADD		HL,DE
01:9F2F 46              	  2979: 		LD		B,(HL)			; Get end of string+1 byte
01:9F30 72              	  2980: 		LD		(HL),D			; Zero it to terminate
01:9F31 E3              	  2981: 		EX		(SP),HL			; Save string end,get start
01:9F32 C5              	  2982: 		PUSH	BC				; Save end+1 byte
01:9F33 7E              	  2983: 		LD		A,(HL)			; Get starting byte
01:9F34 FE24            	  2984: 		CP		'$'				; Hex number indicated? [function added]
01:9F36 C23E9F          	  2985: 		JP		NZ,VAL1
01:9F39 CD6CA7          	  2986: 		CALL	HEXTFP			; Convert Hex to FPREG
01:9F3C 180D            	  2987: 		JR		VAL3
01:9F3E FE25            	  2988: VAL1:	CP		'%'				; Binary number indicated? [function added]
01:9F40 C2489F          	  2989: 		JP		NZ,VAL2
01:9F43 CDDCA7          	  2990: 		CALL	BINTFP		; Convert Bin to FPREG
01:9F46 1803            	  2991: 		JR		VAL3
01:9F48 CD24A3          	  2992: VAL2:	CALL	ASCTFP			; Convert ASCII string to FP
01:9F4B C1              	  2993: VAL3:	POP		BC				; Restore end+1 byte
01:9F4C E1              	  2994: 		POP		HL				; Restore end+1 address
01:9F4D 70              	  2995: 		LD		(HL),B			; Put back original byte
01:9F4E C9              	  2996: 		RET
                        	  2997: 
01:9F4F EB              	  2998: LFRGNM: EX		DE,HL			; Code string address to HL
01:9F50 CD4892          	  2999: 		CALL	CHKSYN			; Make sure ")" follows
01:9F53 29              	  3000: 		db	   ")"
01:9F54 C1              	  3001: MIDNUM: POP		BC				; Get return address
01:9F55 D1              	  3002: 		POP		DE				; Get number supplied
01:9F56 C5              	  3003: 		PUSH	BC				; Re-save return address
01:9F57 43              	  3004: 		LD		B,E				; Number to B
01:9F58 C9              	  3005: 		RET
                        	  3006: 
01:9F59 CD9F9F          	  3007: INP:	CALL	MAKINT			; Make it integer A
01:9F5C 323F10          	  3008: 		LD		(INPORT),A		; Set input port
01:9F5F CD3E10          	  3009: 		CALL	INPSUB			; Get input from port
01:9F62 C3059C          	  3010: 		JP		PASSA			; Return integer A
                        	  3011: 
01:9F65 CD899F          	  3012: POUT:	CALL	SETIO			; Set up port number
01:9F68 C30610          	  3013: 		JP		OUTSUB			; Output data and return
                        	  3014: 
01:9F6B CD899F          	  3015: WAIT:	CALL	SETIO			; Set up port number
01:9F6E F5              	  3016: 		PUSH	AF				; Save AND mask
01:9F6F 1E00            	  3017: 		LD		E,0				; Assume zero if none given
01:9F71 2B              	  3018: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9F72 CDD293          	  3019: 		CALL	GETCHR			; Get next character
01:9F75 CA7F9F          	  3020: 		JP		Z,NOXOR			; No XOR byte given
01:9F78 CD4892          	  3021: 		CALL	CHKSYN			; Make sure ',' follows
01:9F7B 2C              	  3022: 		db	   ','
01:9F7C CD9C9F          	  3023: 		CALL	GETINT			; Get integer 0-255 to XOR with
01:9F7F C1              	  3024: NOXOR:	POP		BC				; Restore AND mask
01:9F80 CD3E10          	  3025: WAITLP: CALL	INPSUB			; Get input
01:9F83 AB              	  3026: 		XOR		E				; Flip selected bits
01:9F84 A0              	  3027: 		AND		B				; Result non-zero?
01:9F85 CA809F          	  3028: 		JP		Z,WAITLP		; No = keep waiting
01:9F88 C9              	  3029: 		RET
                        	  3030: 
01:9F89 CD9C9F          	  3031: SETIO:	CALL	GETINT			; Get integer 0-255
01:9F8C 323F10          	  3032: 		LD		(INPORT),A		; Set input port
01:9F8F 320710          	  3033: 		LD		(OTPORT),A		; Set output port
01:9F92 CD4892          	  3034: 		CALL	CHKSYN			; Make sure ',' follows
01:9F95 2C              	  3035: 		db	   ','
01:9F96 C39C9F          	  3036: 		JP		GETINT			; Get integer 0-255 and return
                        	  3037: 
01:9F99 CDD293          	  3038: FNDNUM: CALL	GETCHR			; Get next character
01:9F9C CD3B98          	  3039: GETINT: CALL	GETNUM			; Get a number from 0 to 255
01:9F9F CD8194          	  3040: MAKINT: CALL	DEPINT			; Make sure value 0 - 255
01:9FA2 7A              	  3041: 		LD		A,D				; Get MSB of number
01:9FA3 B7              	  3042: 		OR		A				; Zero?
01:9FA4 C29C94          	  3043: 		JP		NZ,FCERR		; No - Error
01:9FA7 2B              	  3044: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9FA8 CDD293          	  3045: 		CALL	GETCHR			; Get next character
01:9FAB 7B              	  3046: 		LD		A,E				; Get number to A
01:9FAC C9              	  3047: 		RET
                        	  3048: 
01:9FAD CD8794          	  3049: PEEK:	CALL	DEINT			; Get memory address
01:9FB0 1A              	  3050: 		LD		A,(DE)			; Get byte in memory
01:9FB1 C3059C          	  3051: 		JP		PASSA			; Return integer A
                        	  3052: 
01:9FB4 CD3B98          	  3053: POKE:	CALL	GETNUM			; Get memory address
01:9FB7 CD8794          	  3054: 		CALL	DEINT			; Get integer -32768 to 3276
01:9FBA D5              	  3055: 		PUSH	DE				; Save memory address
01:9FBB CD4892          	  3056: 		CALL	CHKSYN			; Make sure ',' follows
01:9FBE 2C              	  3057: 		db	   ','
01:9FBF CD9C9F          	  3058: 		CALL	GETINT			; Get integer 0-255
01:9FC2 D1              	  3059: 		POP		DE				; Restore memory address
01:9FC3 12              	  3060: 		LD		(DE),A			; Load it into memory
01:9FC4 C9              	  3061: 		RET
                        	  3062: 
01:9FC5 219BA4          	  3063: ROUND:	LD		HL,HALF			; Add 0.5 to FPREG
01:9FC8 CD6CA2          	  3064: ADDPHL: CALL	LOADFP			; Load FP at (HL) to BCDE
01:9FCB C3D79F          	  3065: 		JP		FPADD			; Add BCDE to FPREG
                        	  3066: 
01:9FCE CD6CA2          	  3067: SUBPHL: CALL	LOADFP			; FPREG = -FPREG + number at HL
01:9FD1 21              	  3068: 		db	   21H			   ; Skip "POP BC" and "POP DE"
01:9FD2 C1              	  3069: PSUB:	POP		BC				; Get FP number from stack
01:9FD3 D1              	  3070: 		POP		DE
01:9FD4 CD46A2          	  3071: SUBCDE: CALL	INVSGN			; Negate FPREG
01:9FD7 78              	  3072: FPADD:	LD		A,B				; Get FP exponent
01:9FD8 B7              	  3073: 		OR		A				; Is number zero?
01:9FD9 C8              	  3074: 		RET		Z				; Yes - Nothing to add
01:9FDA 3AE710          	  3075: 		LD		A,(FPEXP)		; Get FPREG exponent
01:9FDD B7              	  3076: 		OR		A				; Is this number zero?
01:9FDE CA5EA2          	  3077: 		JP		Z,FPBCDE		; Yes - Move BCDE to FPREG
01:9FE1 90              	  3078: 		SUB		B				; BCDE number larger?
01:9FE2 D2F19F          	  3079: 		JP		NC,NOSWAP		; No - Don't swap them
01:9FE5 2F              	  3080: 		CPL						; Two's complement
01:9FE6 3C              	  3081: 		INC		A				;  FP exponent
01:9FE7 EB              	  3082: 		EX		DE,HL
01:9FE8 CD4EA2          	  3083: 		CALL	STAKFP			; Put FPREG on stack
01:9FEB EB              	  3084: 		EX		DE,HL
01:9FEC CD5EA2          	  3085: 		CALL	FPBCDE			; Move BCDE to FPREG
01:9FEF C1              	  3086: 		POP		BC				; Restore number from stack
01:9FF0 D1              	  3087: 		POP		DE
01:9FF1 FE19            	  3088: NOSWAP: CP		24+1			; Second number insignificant?
01:9FF3 D0              	  3089: 		RET		NC				; Yes - First number is result
01:9FF4 F5              	  3090: 		PUSH	AF				; Save number of bits to scale
01:9FF5 CD83A2          	  3091: 		CALL	SIGNS			; Set MSBs & sign of result
01:9FF8 67              	  3092: 		LD		H,A				; Save sign of result
01:9FF9 F1              	  3093: 		POP		AF				; Restore scaling factor
01:9FFA CD9CA0          	  3094: 		CALL	SCALE			; Scale BCDE to same exponent
01:9FFD B4              	  3095: 		OR		H				; Result to be positive?
01:9FFE 21E410          	  3096: 		LD		HL,FPREG		; Point to FPREG
01:A001 F217A0          	  3097: 		JP		P,MINCDE		; No - Subtract FPREG from CDE
01:A004 CD7CA0          	  3098: 		CALL	PLUCDE			; Add FPREG to CDE
01:A007 D25DA0          	  3099: 		JP		NC,RONDUP		; No overflow - Round it up
01:A00A 23              	  3100: 		INC		HL				; Point to exponent
01:A00B 34              	  3101: 		INC		(HL)			; Increment it
01:A00C CA898F          	  3102: 		JP		Z,OVERR			; Number overflowed - Error
01:A00F 2E01            	  3103: 		LD		L,1				; 1 bit to shift right
01:A011 CDB2A0          	  3104: 		CALL	SHRT1			; Shift result right
01:A014 C35DA0          	  3105: 		JP		RONDUP			; Round it up
                        	  3106: 
01:A017 AF              	  3107: MINCDE: XOR		A				; Clear A and carry
01:A018 90              	  3108: 		SUB		B				; Negate exponent
01:A019 47              	  3109: 		LD		B,A				; Re-save exponent
01:A01A 7E              	  3110: 		LD		A,(HL)			; Get LSB of FPREG
01:A01B 9B              	  3111: 		SBC		A, E			; Subtract LSB of BCDE
01:A01C 5F              	  3112: 		LD		E,A				; Save LSB of BCDE
01:A01D 23              	  3113: 		INC		HL
01:A01E 7E              	  3114: 		LD		A,(HL)			; Get NMSB of FPREG
01:A01F 9A              	  3115: 		SBC		A,D				; Subtract NMSB of BCDE
01:A020 57              	  3116: 		LD		D,A				; Save NMSB of BCDE
01:A021 23              	  3117: 		INC		HL
01:A022 7E              	  3118: 		LD		A,(HL)			; Get MSB of FPREG
01:A023 99              	  3119: 		SBC		A,C				; Subtract MSB of BCDE
01:A024 4F              	  3120: 		LD		C,A				; Save MSB of BCDE
01:A025 DC88A0          	  3121: CONPOS: CALL	C,COMPL			; Overflow - Make it positive
                        	  3122: 
01:A028 68              	  3123: BNORM:	LD		L,B				; L = Exponent
01:A029 63              	  3124: 		LD		H,E				; H = LSB
01:A02A AF              	  3125: 		XOR		A
01:A02B 47              	  3126: BNRMLP: LD		B,A				; Save bit count
01:A02C 79              	  3127: 		LD		A,C				; Get MSB
01:A02D B7              	  3128: 		OR		A				; Is it zero?
01:A02E C24AA0          	  3129: 		JP		NZ,PNORM		; No - Do it bit at a time
01:A031 4A              	  3130: 		LD		C,D				; MSB = NMSB
01:A032 54              	  3131: 		LD		D,H				; NMSB= LSB
01:A033 65              	  3132: 		LD		H,L				; LSB = VLSB
01:A034 6F              	  3133: 		LD		L,A				; VLSB= 0
01:A035 78              	  3134: 		LD		A,B				; Get exponent
01:A036 D608            	  3135: 		SUB		8				; Count 8 bits
01:A038 FEE0            	  3136: 		CP		-24-8			; Was number zero?
01:A03A C22BA0          	  3137: 		JP		NZ,BNRMLP		; No - Keep normalising
01:A03D AF              	  3138: RESZER: XOR		A				; Result is zero
01:A03E 32E710          	  3139: SAVEXP: LD		(FPEXP),A		; Save result as zero
01:A041 C9              	  3140: 		RET
                        	  3141: 
01:A042 05              	  3142: NORMAL: DEC		B				; Count bits
01:A043 29              	  3143: 		ADD		HL,HL			; Shift HL left
01:A044 7A              	  3144: 		LD		A,D				; Get NMSB
01:A045 17              	  3145: 		RLA						; Shift left with last bit
01:A046 57              	  3146: 		LD		D,A				; Save NMSB
01:A047 79              	  3147: 		LD		A,C				; Get MSB
01:A048 8F              	  3148: 		ADC		A,A				; Shift left with last bit
01:A049 4F              	  3149: 		LD		C,A				; Save MSB
01:A04A F242A0          	  3150: PNORM:	JP		P,NORMAL		; Not done - Keep going
01:A04D 78              	  3151: 		LD		A,B				; Number of bits shifted
01:A04E 5C              	  3152: 		LD		E,H				; Save HL in EB
01:A04F 45              	  3153: 		LD		B,L
01:A050 B7              	  3154: 		OR		A				; Any shifting done?
01:A051 CA5DA0          	  3155: 		JP		Z,RONDUP		; No - Round it up
01:A054 21E710          	  3156: 		LD		HL,FPEXP		; Point to exponent
01:A057 86              	  3157: 		ADD		A,(HL)			; Add shifted bits
01:A058 77              	  3158: 		LD		(HL),A			; Re-save exponent
01:A059 D23DA0          	  3159: 		JP		NC,RESZER		; Underflow - Result is zero
01:A05C C8              	  3160: 		RET		Z				; Result is zero
01:A05D 78              	  3161: RONDUP: LD		A,B				; Get VLSB of number
01:A05E 21E710          	  3162: RONDB:	LD		HL,FPEXP		; Point to exponent
01:A061 B7              	  3163: 		OR		A				; Any rounding?
01:A062 FC6FA0          	  3164: 		CALL	M,FPROND		; Yes - Round number up
01:A065 46              	  3165: 		LD		B,(HL)			; B = Exponent
01:A066 23              	  3166: 		INC		HL
01:A067 7E              	  3167: 		LD		A,(HL)			; Get sign of result
01:A068 E680            	  3168: 		AND		10000000B		; Only bit 7 needed
01:A06A A9              	  3169: 		XOR		C				; Set correct sign
01:A06B 4F              	  3170: 		LD		C,A				; Save correct sign in number
01:A06C C35EA2          	  3171: 		JP		FPBCDE			; Move BCDE to FPREG
                        	  3172: 
01:A06F 1C              	  3173: FPROND: INC		E				; Round LSB
01:A070 C0              	  3174: 		RET		NZ				; Return if ok
01:A071 14              	  3175: 		INC		D				; Round NMSB
01:A072 C0              	  3176: 		RET		NZ				; Return if ok
01:A073 0C              	  3177: 		INC		C				; Round MSB
01:A074 C0              	  3178: 		RET		NZ				; Return if ok
01:A075 0E80            	  3179: 		LD		C,80H			; Set normal value
01:A077 34              	  3180: 		INC		(HL)			; Increment exponent
01:A078 C0              	  3181: 		RET		NZ				; Return if ok
01:A079 C3898F          	  3182: 		JP		OVERR			; Overflow error
                        	  3183: 
01:A07C 7E              	  3184: PLUCDE: LD		A,(HL)			; Get LSB of FPREG
01:A07D 83              	  3185: 		ADD		A,E				; Add LSB of BCDE
01:A07E 5F              	  3186: 		LD		E,A				; Save LSB of BCDE
01:A07F 23              	  3187: 		INC		HL
01:A080 7E              	  3188: 		LD		A,(HL)			; Get NMSB of FPREG
01:A081 8A              	  3189: 		ADC		A,D				; Add NMSB of BCDE
01:A082 57              	  3190: 		LD		D,A				; Save NMSB of BCDE
01:A083 23              	  3191: 		INC		HL
01:A084 7E              	  3192: 		LD		A,(HL)			; Get MSB of FPREG
01:A085 89              	  3193: 		ADC		A,C				; Add MSB of BCDE
01:A086 4F              	  3194: 		LD		C,A				; Save MSB of BCDE
01:A087 C9              	  3195: 		RET
                        	  3196: 
01:A088 21E810          	  3197: COMPL:	LD		HL,SGNRES		; Sign of result
01:A08B 7E              	  3198: 		LD		A,(HL)			; Get sign of result
01:A08C 2F              	  3199: 		CPL						; Negate it
01:A08D 77              	  3200: 		LD		(HL),A			; Put it back
01:A08E AF              	  3201: 		XOR		A
01:A08F 6F              	  3202: 		LD		L,A				; Set L to zero
01:A090 90              	  3203: 		SUB		B				; Negate exponent,set carry
01:A091 47              	  3204: 		LD		B,A				; Re-save exponent
01:A092 7D              	  3205: 		LD		A,L				; Load zero
01:A093 9B              	  3206: 		SBC		A,E				; Negate LSB
01:A094 5F              	  3207: 		LD		E,A				; Re-save LSB
01:A095 7D              	  3208: 		LD		A,L				; Load zero
01:A096 9A              	  3209: 		SBC		A,D				; Negate NMSB
01:A097 57              	  3210: 		LD		D,A				; Re-save NMSB
01:A098 7D              	  3211: 		LD		A,L				; Load zero
01:A099 99              	  3212: 		SBC		A,C				; Negate MSB
01:A09A 4F              	  3213: 		LD		C,A				; Re-save MSB
01:A09B C9              	  3214: 		RET
                        	  3215: 
01:A09C 0600            	  3216: SCALE:	LD		B,0				; Clear underflow
01:A09E D608            	  3217: SCALLP: SUB		8				; 8 bits (a whole byte)?
01:A0A0 DAABA0          	  3218: 		JP		C,SHRITE		; No - Shift right A bits
01:A0A3 43              	  3219: 		LD		B,E				; <- Shift
01:A0A4 5A              	  3220: 		LD		E,D				; <- right
01:A0A5 51              	  3221: 		LD		D,C				; <- eight
01:A0A6 0E00            	  3222: 		LD		C,0				; <- bits
01:A0A8 C39EA0          	  3223: 		JP		SCALLP			; More bits to shift
                        	  3224: 
01:A0AB C609            	  3225: SHRITE: ADD		A,8+1			; Adjust count
01:A0AD 6F              	  3226: 		LD		L,A				; Save bits to shift
01:A0AE AF              	  3227: SHRLP:	XOR		A				; Flag for all done
01:A0AF 2D              	  3228: 		DEC		L				; All shifting done?
01:A0B0 C8              	  3229: 		RET		Z				; Yes - Return
01:A0B1 79              	  3230: 		LD		A,C				; Get MSB
01:A0B2 1F              	  3231: SHRT1:	RRA						; Shift it right
01:A0B3 4F              	  3232: 		LD		C,A				; Re-save
01:A0B4 7A              	  3233: 		LD		A,D				; Get NMSB
01:A0B5 1F              	  3234: 		RRA						; Shift right with last bit
01:A0B6 57              	  3235: 		LD		D,A				; Re-save it
01:A0B7 7B              	  3236: 		LD		A,E				; Get LSB
01:A0B8 1F              	  3237: 		RRA						; Shift right with last bit
01:A0B9 5F              	  3238: 		LD		E,A				; Re-save it
01:A0BA 78              	  3239: 		LD		A,B				; Get underflow
01:A0BB 1F              	  3240: 		RRA						; Shift right with last bit
01:A0BC 47              	  3241: 		LD		B,A				; Re-save underflow
01:A0BD C3AEA0          	  3242: 		JP		SHRLP			; More bits to do
                        	  3243: 
01:A0C0 00              	  3244: UNITY:	db		000H,000H,000H,081H	   ; 1.00000
01:A0C1 00
01:A0C2 00
01:A0C3 81
                        	  3245: 
01:A0C4 03              	  3246: LOGTAB: db	   3					   ; Table used by LOG
01:A0C5 AA              	  3247: 		db	   0AAH,056H,019H,080H	   ; 0.59898
01:A0C6 56
01:A0C7 19
01:A0C8 80
01:A0C9 F1              	  3248: 		db	   0F1H,022H,076H,080H	   ; 0.96147
01:A0CA 22
01:A0CB 76
01:A0CC 80
01:A0CD 45              	  3249: 		db	   045H,0AAH,038H,082H	   ; 2.88539
01:A0CE AA
01:A0CF 38
01:A0D0 82
                        	  3250: 
01:A0D1 CD1DA2          	  3251: LOG:	CALL	TSTSGN			; Test sign of value
01:A0D4 B7              	  3252: 		OR		A
01:A0D5 EA9C94          	  3253: 		JP		PE,FCERR		; ?FC Error if <= zero
01:A0D8 21E710          	  3254: 		LD		HL,FPEXP		; Point to exponent
01:A0DB 7E              	  3255: 		LD		A,(HL)			; Get exponent
01:A0DC 013580          	  3256: 		LD		BC,8035H		; BCDE = SQR(1/2)
01:A0DF 11F304          	  3257: 		LD		DE,04F3H
01:A0E2 90              	  3258: 		SUB		B				; Scale value to be < 1
01:A0E3 F5              	  3259: 		PUSH	AF				; Save scale factor
01:A0E4 70              	  3260: 		LD		(HL),B			; Save new exponent
01:A0E5 D5              	  3261: 		PUSH	DE				; Save SQR(1/2)
01:A0E6 C5              	  3262: 		PUSH	BC
01:A0E7 CDD79F          	  3263: 		CALL	FPADD			; Add SQR(1/2) to value
01:A0EA C1              	  3264: 		POP		BC				; Restore SQR(1/2)
01:A0EB D1              	  3265: 		POP		DE
01:A0EC 04              	  3266: 		INC		B				; Make it SQR(2)
01:A0ED CD73A1          	  3267: 		CALL	DVBCDE			; Divide by SQR(2)
01:A0F0 21C0A0          	  3268: 		LD		HL,UNITY		; Point to 1.
01:A0F3 CDCE9F          	  3269: 		CALL	SUBPHL			; Subtract FPREG from 1
01:A0F6 21C4A0          	  3270: 		LD		HL,LOGTAB		; Coefficient table
01:A0F9 CD65A5          	  3271: 		CALL	SUMSER			; Evaluate sum of series
01:A0FC 018080          	  3272: 		LD		BC,8080H		; BCDE = -0.5
01:A0FF 110000          	  3273: 		LD		DE,0000H
01:A102 CDD79F          	  3274: 		CALL	FPADD			; Subtract 0.5 from FPREG
01:A105 F1              	  3275: 		POP		AF				; Restore scale factor
01:A106 CD98A3          	  3276: 		CALL	RSCALE			; Re-scale number
01:A109 013180          	  3277: MULLN2: LD		BC,8031H		; BCDE = Ln(2)
01:A10C 111872          	  3278: 		LD		DE,7218H
01:A10F 21              	  3279: 		db	   21H			   ; Skip "POP BC" and "POP DE"
                        	  3280: 
01:A110 C1              	  3281: MULTT:	POP		BC				; Get number from stack
01:A111 D1              	  3282: 		POP		DE
01:A112 CD1DA2          	  3283: FPMULT: CALL	TSTSGN			; Test sign of FPREG
01:A115 C8              	  3284: 		RET		Z				; Return zero if zero
01:A116 2E00            	  3285: 		LD		L,0				; Flag add exponents
01:A118 CDDBA1          	  3286: 		CALL	ADDEXP			; Add exponents
01:A11B 79              	  3287: 		LD		A,C				; Get MSB of multiplier
01:A11C 32F610          	  3288: 		LD		(MULVAL),A		; Save MSB of multiplier
01:A11F EB              	  3289: 		EX		DE,HL
01:A120 22F710          	  3290: 		LD		(MULVAL+1),HL	; Save rest of multiplier
01:A123 010000          	  3291: 		LD		BC,0			; Partial product (BCDE) = zero
01:A126 50              	  3292: 		LD		D,B
01:A127 58              	  3293: 		LD		E,B
01:A128 2128A0          	  3294: 		LD		HL,BNORM		; Address of normalise
01:A12B E5              	  3295: 		PUSH	HL				; Save for return
01:A12C 2134A1          	  3296: 		LD		HL,MULT8		; Address of 8 bit multiply
01:A12F E5              	  3297: 		PUSH	HL				; Save for NMSB,MSB
01:A130 E5              	  3298: 		PUSH	HL				; 
01:A131 21E410          	  3299: 		LD		HL,FPREG		; Point to number
01:A134 7E              	  3300: MULT8:	LD		A,(HL)			; Get LSB of number
01:A135 23              	  3301: 		INC		HL				; Point to NMSB
01:A136 B7              	  3302: 		OR		A				; Test LSB
01:A137 CA60A1          	  3303: 		JP		Z,BYTSFT		; Zero - shift to next byte
01:A13A E5              	  3304: 		PUSH	HL				; Save address of number
01:A13B 2E08            	  3305: 		LD		L,8				; 8 bits to multiply by
01:A13D 1F              	  3306: MUL8LP: RRA						; Shift LSB right
01:A13E 67              	  3307: 		LD		H,A				; Save LSB
01:A13F 79              	  3308: 		LD		A,C				; Get MSB
01:A140 D24EA1          	  3309: 		JP		NC,NOMADD		; Bit was zero - Don't add
01:A143 E5              	  3310: 		PUSH	HL				; Save LSB and count
01:A144 2AF710          	  3311: 		LD		HL,(MULVAL+1)	; Get LSB and NMSB
01:A147 19              	  3312: 		ADD		HL,DE			; Add NMSB and LSB
01:A148 EB              	  3313: 		EX		DE,HL			; Leave sum in DE
01:A149 E1              	  3314: 		POP		HL				; Restore MSB and count
01:A14A 3AF610          	  3315: 		LD		A,(MULVAL)		; Get MSB of multiplier
01:A14D 89              	  3316: 		ADC		A,C				; Add MSB
01:A14E 1F              	  3317: NOMADD: RRA						; Shift MSB right
01:A14F 4F              	  3318: 		LD		C,A				; Re-save MSB
01:A150 7A              	  3319: 		LD		A,D				; Get NMSB
01:A151 1F              	  3320: 		RRA						; Shift NMSB right
01:A152 57              	  3321: 		LD		D,A				; Re-save NMSB
01:A153 7B              	  3322: 		LD		A,E				; Get LSB
01:A154 1F              	  3323: 		RRA						; Shift LSB right
01:A155 5F              	  3324: 		LD		E,A				; Re-save LSB
01:A156 78              	  3325: 		LD		A,B				; Get VLSB
01:A157 1F              	  3326: 		RRA						; Shift VLSB right
01:A158 47              	  3327: 		LD		B,A				; Re-save VLSB
01:A159 2D              	  3328: 		DEC		L				; Count bits multiplied
01:A15A 7C              	  3329: 		LD		A,H				; Get LSB of multiplier
01:A15B C23DA1          	  3330: 		JP		NZ,MUL8LP		; More - Do it
01:A15E E1              	  3331: POPHRT: POP		HL				; Restore address of number
01:A15F C9              	  3332: 		RET
                        	  3333: 
01:A160 43              	  3334: BYTSFT: LD		B,E				; Shift partial product left
01:A161 5A              	  3335: 		LD		E,D
01:A162 51              	  3336: 		LD		D,C
01:A163 4F              	  3337: 		LD		C,A
01:A164 C9              	  3338: 		RET
                        	  3339: 
01:A165 CD4EA2          	  3340: DIV10:	CALL	STAKFP			; Save FPREG on stack
01:A168 012084          	  3341: 		LD		BC,8420H		; BCDE = 10.
01:A16B 110000          	  3342: 		LD		DE,0000H
01:A16E CD5EA2          	  3343: 		CALL	FPBCDE			; Move 10 to FPREG
                        	  3344: 
01:A171 C1              	  3345: DIV:	POP		BC				; Get number from stack
01:A172 D1              	  3346: 		POP		DE
01:A173 CD1DA2          	  3347: DVBCDE: CALL	TSTSGN			; Test sign of FPREG
01:A176 CA7D8F          	  3348: 		JP		Z,DZERR			; Error if division by zero
01:A179 2EFF            	  3349: 		LD		L,-1			; Flag subtract exponents
01:A17B CDDBA1          	  3350: 		CALL	ADDEXP			; Subtract exponents
01:A17E 34              	  3351: 		INC		(HL)			; Add 2 to exponent to adjust
01:A17F 34              	  3352: 		INC		(HL)
01:A180 2B              	  3353: 		DEC		HL				; Point to MSB
01:A181 7E              	  3354: 		LD		A,(HL)			; Get MSB of dividend
01:A182 321210          	  3355: 		LD		(DIV3),A		; Save for subtraction
01:A185 2B              	  3356: 		DEC		HL
01:A186 7E              	  3357: 		LD		A,(HL)			; Get NMSB of dividend
01:A187 320E10          	  3358: 		LD		(DIV2),A		; Save for subtraction
01:A18A 2B              	  3359: 		DEC		HL
01:A18B 7E              	  3360: 		LD		A,(HL)			; Get MSB of dividend
01:A18C 320A10          	  3361: 		LD		(DIV1),A		; Save for subtraction
01:A18F 41              	  3362: 		LD		B,C				; Get MSB
01:A190 EB              	  3363: 		EX		DE,HL			; NMSB,LSB to HL
01:A191 AF              	  3364: 		XOR		A
01:A192 4F              	  3365: 		LD		C,A				; Clear MSB of quotient
01:A193 57              	  3366: 		LD		D,A				; Clear NMSB of quotient
01:A194 5F              	  3367: 		LD		E,A				; Clear LSB of quotient
01:A195 321510          	  3368: 		LD		(DIV4),A		; Clear overflow count
01:A198 E5              	  3369: DIVLP:	PUSH	HL				; Save divisor
01:A199 C5              	  3370: 		PUSH	BC
01:A19A 7D              	  3371: 		LD		A,L				; Get LSB of number
01:A19B CD0910          	  3372: 		CALL	DIVSUP			; Subt' divisor from dividend
01:A19E DE00            	  3373: 		SBC		A,0				; Count for overflows
01:A1A0 3F              	  3374: 		CCF
01:A1A1 D2ABA1          	  3375: 		JP		NC,RESDIV		; Restore divisor if borrow
01:A1A4 321510          	  3376: 		LD		(DIV4),A		; Re-save overflow count
01:A1A7 F1              	  3377: 		POP		AF				; Scrap divisor
01:A1A8 F1              	  3378: 		POP		AF
01:A1A9 37              	  3379: 		SCF						; Set carry to
01:A1AA D2              	  3380: 		db	   0D2H			   ; Skip "POP BC" and "POP HL"
                        	  3381: 
01:A1AB C1              	  3382: RESDIV: POP		BC				; Restore divisor
01:A1AC E1              	  3383: 		POP		HL
01:A1AD 79              	  3384: 		LD		A,C				; Get MSB of quotient
01:A1AE 3C              	  3385: 		INC		A
01:A1AF 3D              	  3386: 		DEC		A
01:A1B0 1F              	  3387: 		RRA						; Bit 0 to bit 7
01:A1B1 FA5EA0          	  3388: 		JP		M,RONDB			; Done - Normalise result
01:A1B4 17              	  3389: 		RLA						; Restore carry
01:A1B5 7B              	  3390: 		LD		A,E				; Get LSB of quotient
01:A1B6 17              	  3391: 		RLA						; Double it
01:A1B7 5F              	  3392: 		LD		E,A				; Put it back
01:A1B8 7A              	  3393: 		LD		A,D				; Get NMSB of quotient
01:A1B9 17              	  3394: 		RLA						; Double it
01:A1BA 57              	  3395: 		LD		D,A				; Put it back
01:A1BB 79              	  3396: 		LD		A,C				; Get MSB of quotient
01:A1BC 17              	  3397: 		RLA						; Double it
01:A1BD 4F              	  3398: 		LD		C,A				; Put it back
01:A1BE 29              	  3399: 		ADD		HL,HL			; Double NMSB,LSB of divisor
01:A1BF 78              	  3400: 		LD		A,B				; Get MSB of divisor
01:A1C0 17              	  3401: 		RLA						; Double it
01:A1C1 47              	  3402: 		LD		B,A				; Put it back
01:A1C2 3A1510          	  3403: 		LD		A,(DIV4)		; Get VLSB of quotient
01:A1C5 17              	  3404: 		RLA						; Double it
01:A1C6 321510          	  3405: 		LD		(DIV4),A		; Put it back
01:A1C9 79              	  3406: 		LD		A,C				; Get MSB of quotient
01:A1CA B2              	  3407: 		OR		D				; Merge NMSB
01:A1CB B3              	  3408: 		OR		E				; Merge LSB
01:A1CC C298A1          	  3409: 		JP		NZ,DIVLP		; Not done - Keep dividing
01:A1CF E5              	  3410: 		PUSH	HL				; Save divisor
01:A1D0 21E710          	  3411: 		LD		HL,FPEXP		; Point to exponent
01:A1D3 35              	  3412: 		DEC		(HL)			; Divide by 2
01:A1D4 E1              	  3413: 		POP		HL				; Restore divisor
01:A1D5 C298A1          	  3414: 		JP		NZ,DIVLP		; Ok - Keep going
01:A1D8 C3898F          	  3415: 		JP		OVERR			; Overflow error
                        	  3416: 
01:A1DB 78              	  3417: ADDEXP: LD		A,B				; Get exponent of dividend
01:A1DC B7              	  3418: 		OR		A				; Test it
01:A1DD CAFFA1          	  3419: 		JP		Z,OVTST3		; Zero - Result zero
01:A1E0 7D              	  3420: 		LD		A,L				; Get add/subtract flag
01:A1E1 21E710          	  3421: 		LD		HL,FPEXP		; Point to exponent
01:A1E4 AE              	  3422: 		XOR		(HL)			; Add or subtract it
01:A1E5 80              	  3423: 		ADD		A,B				; Add the other exponent
01:A1E6 47              	  3424: 		LD		B,A				; Save new exponent
01:A1E7 1F              	  3425: 		RRA						; Test exponent for overflow
01:A1E8 A8              	  3426: 		XOR		B
01:A1E9 78              	  3427: 		LD		A,B				; Get exponent
01:A1EA F2FEA1          	  3428: 		JP		P,OVTST2		; Positive - Test for overflow
01:A1ED C680            	  3429: 		ADD		A,80H			; Add excess 128
01:A1EF 77              	  3430: 		LD		(HL),A			; Save new exponent
01:A1F0 CA5EA1          	  3431: 		JP		Z,POPHRT		; Zero - Result zero
01:A1F3 CD83A2          	  3432: 		CALL	SIGNS			; Set MSBs and sign of result
01:A1F6 77              	  3433: 		LD		(HL),A			; Save new exponent
01:A1F7 2B              	  3434: 		DEC		HL				; Point to MSB
01:A1F8 C9              	  3435: 		RET
                        	  3436: 
01:A1F9 CD1DA2          	  3437: OVTST1: CALL	TSTSGN			; Test sign of FPREG
01:A1FC 2F              	  3438: 		CPL						; Invert sign
01:A1FD E1              	  3439: 		POP		HL				; Clean up stack
01:A1FE B7              	  3440: OVTST2: OR		A				; Test if new exponent zero
01:A1FF E1              	  3441: OVTST3: POP		HL				; Clear off return address
01:A200 F23DA0          	  3442: 		JP		P,RESZER		; Result zero
01:A203 C3898F          	  3443: 		JP		OVERR			; Overflow error
                        	  3444: 
01:A206 CD69A2          	  3445: MLSP10: CALL	BCDEFP			; Move FPREG to BCDE
01:A209 78              	  3446: 		LD		A,B				; Get exponent
01:A20A B7              	  3447: 		OR		A				; Is it zero?
01:A20B C8              	  3448: 		RET		Z				; Yes - Result is zero
01:A20C C602            	  3449: 		ADD		A,2				; Multiply by 4
01:A20E DA898F          	  3450: 		JP		C,OVERR			; Overflow - ?OV Error
01:A211 47              	  3451: 		LD		B,A				; Re-save exponent
01:A212 CDD79F          	  3452: 		CALL	FPADD			; Add BCDE to FPREG (Times 5)
01:A215 21E710          	  3453: 		LD		HL,FPEXP		; Point to exponent
01:A218 34              	  3454: 		INC		(HL)			; Double number (Times 10)
01:A219 C0              	  3455: 		RET		NZ				; Ok - Return
01:A21A C3898F          	  3456: 		JP		OVERR			; Overflow error
                        	  3457: 
01:A21D 3AE710          	  3458: TSTSGN: LD		A,(FPEXP)		; Get sign of FPREG
01:A220 B7              	  3459: 		OR		A
01:A221 C8              	  3460: 		RET		Z				; RETurn if number is zero
01:A222 3AE610          	  3461: 		LD		A,(FPREG+2)		; Get MSB of FPREG
01:A225 FE              	  3462: 		db	   0FEH			   ; Test sign
01:A226 2F              	  3463: RETREL: CPL						; Invert sign
01:A227 17              	  3464: 		RLA						; Sign bit to carry
01:A228 9F              	  3465: FLGDIF: SBC		A,A				; Carry to all bits of A
01:A229 C0              	  3466: 		RET		NZ				; Return -1 if negative
01:A22A 3C              	  3467: 		INC		A				; Bump to +1
01:A22B C9              	  3468: 		RET						; Positive - Return +1
                        	  3469: 
01:A22C CD1DA2          	  3470: SGN:	CALL	TSTSGN			; Test sign of FPREG
01:A22F 0688            	  3471: FLGREL: LD		B,80H+8			; 8 bit integer in exponent
01:A231 110000          	  3472: 		LD		DE,0			; Zero NMSB and LSB
01:A234 21E710          	  3473: RETINT: LD		HL,FPEXP		; Point to exponent
01:A237 4F              	  3474: 		LD		C,A				; CDE = MSB,NMSB and LSB
01:A238 70              	  3475: 		LD		(HL),B			; Save exponent
01:A239 0600            	  3476: 		LD		B,0				; CDE = integer to normalise
01:A23B 23              	  3477: 		INC		HL				; Point to sign of result
01:A23C 3680            	  3478: 		LD		(HL),80H		; Set sign of result
01:A23E 17              	  3479: 		RLA						; Carry = sign of integer
01:A23F C325A0          	  3480: 		JP		CONPOS			; Set sign of result
                        	  3481: 
01:A242 CD1DA2          	  3482: ABS:	CALL	TSTSGN			; Test sign of FPREG
01:A245 F0              	  3483: 		RET		P				; Return if positive
01:A246 21E610          	  3484: INVSGN: LD		HL,FPREG+2		; Point to MSB
01:A249 7E              	  3485: 		LD		A,(HL)			; Get sign of mantissa
01:A24A EE80            	  3486: 		XOR		80H				; Invert sign of mantissa
01:A24C 77              	  3487: 		LD		(HL),A			; Re-save sign of mantissa
01:A24D C9              	  3488: 		RET
                        	  3489: 
01:A24E EB              	  3490: STAKFP: EX		DE,HL			; Save code string address
01:A24F 2AE410          	  3491: 		LD		HL,(FPREG)		; LSB,NLSB of FPREG
01:A252 E3              	  3492: 		EX		(SP),HL			; Stack them,get return
01:A253 E5              	  3493: 		PUSH	HL				; Re-save return
01:A254 2AE610          	  3494: 		LD		HL,(FPREG+2)	; MSB and exponent of FPREG
01:A257 E3              	  3495: 		EX		(SP),HL			; Stack them,get return
01:A258 E5              	  3496: 		PUSH	HL				; Re-save return
01:A259 EB              	  3497: 		EX		DE,HL			; Restore code string address
01:A25A C9              	  3498: 		RET
                        	  3499: 
01:A25B CD6CA2          	  3500: PHLTFP: CALL	LOADFP			; Number at HL to BCDE
01:A25E EB              	  3501: FPBCDE: EX		DE,HL			; Save code string address
01:A25F 22E410          	  3502: 		LD		(FPREG),HL		; Save LSB,NLSB of number
01:A262 60              	  3503: 		LD		H,B				; Exponent of number
01:A263 69              	  3504: 		LD		L,C				; MSB of number
01:A264 22E610          	  3505: 		LD		(FPREG+2),HL	; Save MSB and exponent
01:A267 EB              	  3506: 		EX		DE,HL			; Restore code string address
01:A268 C9              	  3507: 		RET
                        	  3508: 
01:A269 21E410          	  3509: BCDEFP: LD		HL,FPREG		; Point to FPREG
01:A26C 5E              	  3510: LOADFP: LD		E,(HL)			; Get LSB of number
01:A26D 23              	  3511: 		INC		HL
01:A26E 56              	  3512: 		LD		D,(HL)			; Get NMSB of number
01:A26F 23              	  3513: 		INC		HL
01:A270 4E              	  3514: 		LD		C,(HL)			; Get MSB of number
01:A271 23              	  3515: 		INC		HL
01:A272 46              	  3516: 		LD		B,(HL)			; Get exponent of number
01:A273 23              	  3517: INCHL:	INC		HL				; Used for conditional "INC HL"
01:A274 C9              	  3518: 		RET
                        	  3519: 
01:A275 11E410          	  3520: FPTHL:	LD		DE,FPREG		; Point to FPREG
01:A278 0604            	  3521: DETHL4: LD		B,4				; 4 bytes to move
01:A27A 1A              	  3522: DETHLB: LD		A,(DE)			; Get source
01:A27B 77              	  3523: 		LD		(HL),A			; Save destination
01:A27C 13              	  3524: 		INC		DE				; Next source
01:A27D 23              	  3525: 		INC		HL				; Next destination
01:A27E 05              	  3526: 		DEC		B				; Count bytes
01:A27F C27AA2          	  3527: 		JP		NZ,DETHLB		; Loop if more
01:A282 C9              	  3528: 		RET
                        	  3529: 
01:A283 21E610          	  3530: SIGNS:	LD		HL,FPREG+2		; Point to MSB of FPREG
01:A286 7E              	  3531: 		LD		A,(HL)			; Get MSB
01:A287 07              	  3532: 		RLCA					; Old sign to carry
01:A288 37              	  3533: 		SCF						; Set MSBit
01:A289 1F              	  3534: 		RRA						; Set MSBit of MSB
01:A28A 77              	  3535: 		LD		(HL),A			; Save new MSB
01:A28B 3F              	  3536: 		CCF						; Complement sign
01:A28C 1F              	  3537: 		RRA						; Old sign to carry
01:A28D 23              	  3538: 		INC		HL
01:A28E 23              	  3539: 		INC		HL
01:A28F 77              	  3540: 		LD		(HL),A			; Set sign of result
01:A290 79              	  3541: 		LD		A,C				; Get MSB
01:A291 07              	  3542: 		RLCA					; Old sign to carry
01:A292 37              	  3543: 		SCF						; Set MSBit
01:A293 1F              	  3544: 		RRA						; Set MSBit of MSB
01:A294 4F              	  3545: 		LD		C,A				; Save MSB
01:A295 1F              	  3546: 		RRA
01:A296 AE              	  3547: 		XOR		(HL)			; New sign of result
01:A297 C9              	  3548: 		RET
                        	  3549: 
01:A298 78              	  3550: CMPNUM: LD		A,B				; Get exponent of number
01:A299 B7              	  3551: 		OR		A
01:A29A CA1DA2          	  3552: 		JP		Z,TSTSGN		; Zero - Test sign of FPREG
01:A29D 2126A2          	  3553: 		LD		HL,RETREL		; Return relation routine
01:A2A0 E5              	  3554: 		PUSH	HL				; Save for return
01:A2A1 CD1DA2          	  3555: 		CALL	TSTSGN			; Test sign of FPREG
01:A2A4 79              	  3556: 		LD		A,C				; Get MSB of number
01:A2A5 C8              	  3557: 		RET		Z				; FPREG zero - Number's MSB
01:A2A6 21E610          	  3558: 		LD		HL,FPREG+2		; MSB of FPREG
01:A2A9 AE              	  3559: 		XOR		(HL)			; Combine signs
01:A2AA 79              	  3560: 		LD		A,C				; Get MSB of number
01:A2AB F8              	  3561: 		RET		M				; Exit if signs different
01:A2AC CDB2A2          	  3562: 		CALL	CMPFP			; Compare FP numbers
01:A2AF 1F              	  3563: 		RRA						; Get carry to sign
01:A2B0 A9              	  3564: 		XOR		C				; Combine with MSB of number
01:A2B1 C9              	  3565: 		RET
                        	  3566: 
01:A2B2 23              	  3567: CMPFP:	INC		HL				; Point to exponent
01:A2B3 78              	  3568: 		LD		A,B				; Get exponent
01:A2B4 BE              	  3569: 		CP		(HL)			; Compare exponents
01:A2B5 C0              	  3570: 		RET		NZ				; Different
01:A2B6 2B              	  3571: 		DEC		HL				; Point to MBS
01:A2B7 79              	  3572: 		LD		A,C				; Get MSB
01:A2B8 BE              	  3573: 		CP		(HL)			; Compare MSBs
01:A2B9 C0              	  3574: 		RET		NZ				; Different
01:A2BA 2B              	  3575: 		DEC		HL				; Point to NMSB
01:A2BB 7A              	  3576: 		LD		A,D				; Get NMSB
01:A2BC BE              	  3577: 		CP		(HL)			; Compare NMSBs
01:A2BD C0              	  3578: 		RET		NZ				; Different
01:A2BE 2B              	  3579: 		DEC		HL				; Point to LSB
01:A2BF 7B              	  3580: 		LD		A,E				; Get LSB
01:A2C0 96              	  3581: 		SUB		(HL)			; Compare LSBs
01:A2C1 C0              	  3582: 		RET		NZ				; Different
01:A2C2 E1              	  3583: 		POP		HL				; Drop RETurn
01:A2C3 E1              	  3584: 		POP		HL				; Drop another RETurn
01:A2C4 C9              	  3585: 		RET
                        	  3586: 
01:A2C5 47              	  3587: FPINT:	LD		B,A				; <- Move
01:A2C6 4F              	  3588: 		LD		C,A				; <- exponent
01:A2C7 57              	  3589: 		LD		D,A				; <- to all
01:A2C8 5F              	  3590: 		LD		E,A				; <- bits
01:A2C9 B7              	  3591: 		OR		A				; Test exponent
01:A2CA C8              	  3592: 		RET		Z				; Zero - Return zero
01:A2CB E5              	  3593: 		PUSH	HL				; Save pointer to number
01:A2CC CD69A2          	  3594: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A2CF CD83A2          	  3595: 		CALL	SIGNS			; Set MSBs & sign of result
01:A2D2 AE              	  3596: 		XOR		(HL)			; Combine with sign of FPREG
01:A2D3 67              	  3597: 		LD		H,A				; Save combined signs
01:A2D4 FCE9A2          	  3598: 		CALL	M,DCBCDE		; Negative - Decrement BCDE
01:A2D7 3E98            	  3599: 		LD		A,80H+24		; 24 bits
01:A2D9 90              	  3600: 		SUB		B				; Bits to shift
01:A2DA CD9CA0          	  3601: 		CALL	SCALE			; Shift BCDE
01:A2DD 7C              	  3602: 		LD		A,H				; Get combined sign
01:A2DE 17              	  3603: 		RLA						; Sign to carry
01:A2DF DC6FA0          	  3604: 		CALL	C,FPROND		; Negative - Round number up
01:A2E2 0600            	  3605: 		LD		B,0				; Zero exponent
01:A2E4 DC88A0          	  3606: 		CALL	C,COMPL			; If negative make positive
01:A2E7 E1              	  3607: 		POP		HL				; Restore pointer to number
01:A2E8 C9              	  3608: 		RET
                        	  3609: 
01:A2E9 1B              	  3610: DCBCDE: DEC		DE				; Decrement BCDE
01:A2EA 7A              	  3611: 		LD		A,D				; Test LSBs
01:A2EB A3              	  3612: 		AND		E
01:A2EC 3C              	  3613: 		INC		A
01:A2ED C0              	  3614: 		RET		NZ				; Exit if LSBs not FFFF
01:A2EE 0B              	  3615: 		DEC		BC				; Decrement MSBs
01:A2EF C9              	  3616: 		RET
                        	  3617: 
01:A2F0 21E710          	  3618: INT:	LD		HL,FPEXP		; Point to exponent
01:A2F3 7E              	  3619: 		LD		A,(HL)			; Get exponent
01:A2F4 FE98            	  3620: 		CP		80H+24			; Integer accuracy only?
01:A2F6 3AE410          	  3621: 		LD		A,(FPREG)		; Get LSB
01:A2F9 D0              	  3622: 		RET		NC				; Yes - Already integer
01:A2FA 7E              	  3623: 		LD		A,(HL)			; Get exponent
01:A2FB CDC5A2          	  3624: 		CALL	FPINT			; F.P to integer
01:A2FE 3698            	  3625: 		LD		(HL),80H+24		; Save 24 bit integer
01:A300 7B              	  3626: 		LD		A,E				; Get LSB of number
01:A301 F5              	  3627: 		PUSH	AF				; Save LSB
01:A302 79              	  3628: 		LD		A,C				; Get MSB of number
01:A303 17              	  3629: 		RLA						; Sign to carry
01:A304 CD25A0          	  3630: 		CALL	CONPOS			; Set sign of result
01:A307 F1              	  3631: 		POP		AF				; Restore LSB of number
01:A308 C9              	  3632: 		RET
                        	  3633: 
01:A309 210000          	  3634: MLDEBC: LD		HL,0			; Clear partial product
01:A30C 78              	  3635: 		LD		A,B				; Test multiplier
01:A30D B1              	  3636: 		OR		C
01:A30E C8              	  3637: 		RET		Z				; Return zero if zero
01:A30F 3E10            	  3638: 		LD		A,16			; 16 bits
01:A311 29              	  3639: MLDBLP: ADD		HL,HL			; Shift P.P left
01:A312 DA499B          	  3640: 		JP		C,BSERR			; ?BS Error if overflow
01:A315 EB              	  3641: 		EX		DE,HL
01:A316 29              	  3642: 		ADD		HL,HL			; Shift multiplier left
01:A317 EB              	  3643: 		EX		DE,HL
01:A318 D21FA3          	  3644: 		JP		NC,NOMLAD		; Bit was zero - No add
01:A31B 09              	  3645: 		ADD		HL,BC			; Add multiplicand
01:A31C DA499B          	  3646: 		JP		C,BSERR			; ?BS Error if overflow
01:A31F 3D              	  3647: NOMLAD: DEC		A				; Count bits
01:A320 C211A3          	  3648: 		JP		NZ,MLDBLP		; More
01:A323 C9              	  3649: 		RET
                        	  3650: 
01:A324 FE2D            	  3651: ASCTFP: CP		'-'				; Negative?
01:A326 F5              	  3652: 		PUSH	AF				; Save it and flags
01:A327 CA30A3          	  3653: 		JP		Z,CNVNUM		; Yes - Convert number
01:A32A FE2B            	  3654: 		CP		'+'				; Positive?
01:A32C CA30A3          	  3655: 		JP		Z,CNVNUM		; Yes - Convert number
01:A32F 2B              	  3656: 		DEC		HL				; DEC 'cos GETCHR INCs
01:A330 CD3DA0          	  3657: CNVNUM: CALL	RESZER			; Set result to zero
01:A333 47              	  3658: 		LD		B,A				; Digits after point counter
01:A334 57              	  3659: 		LD		D,A				; Sign of exponent
01:A335 5F              	  3660: 		LD		E,A				; Exponent of ten
01:A336 2F              	  3661: 		CPL
01:A337 4F              	  3662: 		LD		C,A				; Before or after point flag
01:A338 CDD293          	  3663: MANLP:	CALL	GETCHR			; Get next character
01:A33B DA81A3          	  3664: 		JP		C,ADDIG			; Digit - Add to number
01:A33E FE2E            	  3665: 		CP		'.'
01:A340 CA5CA3          	  3666: 		JP		Z,DPOINT		; '.' - Flag point
01:A343 FE45            	  3667: 		CP		'E'
01:A345 C260A3          	  3668: 		JP		NZ,CONEXP		; Not 'E' - Scale number
01:A348 CDD293          	  3669: 		CALL	GETCHR			; Get next character
01:A34B CD7499          	  3670: 		CALL	SGNEXP			; Get sign of exponent
01:A34E CDD293          	  3671: EXPLP:	CALL	GETCHR			; Get next character
01:A351 DAA3A3          	  3672: 		JP		C,EDIGIT		; Digit - Add to exponent
01:A354 14              	  3673: 		INC		D				; Is sign negative?
01:A355 C260A3          	  3674: 		JP		NZ,CONEXP		; No - Scale number
01:A358 AF              	  3675: 		XOR		A
01:A359 93              	  3676: 		SUB		E				; Negate exponent
01:A35A 5F              	  3677: 		LD		E,A				; And re-save it
01:A35B 0C              	  3678: 		INC		C				; Flag end of number
01:A35C 0C              	  3679: DPOINT: INC		C				; Flag point passed
01:A35D CA38A3          	  3680: 		JP		Z,MANLP			; Zero - Get another digit
01:A360 E5              	  3681: CONEXP: PUSH	HL				; Save code string address
01:A361 7B              	  3682: 		LD		A,E				; Get exponent
01:A362 90              	  3683: 		SUB		B				; Subtract digits after point
01:A363 F479A3          	  3684: SCALMI: CALL	P,SCALPL		; Positive - Multiply number
01:A366 F26FA3          	  3685: 		JP		P,ENDCON		; Positive - All done
01:A369 F5              	  3686: 		PUSH	AF				; Save number of times to /10
01:A36A CD65A1          	  3687: 		CALL	DIV10			; Divide by 10
01:A36D F1              	  3688: 		POP		AF				; Restore count
01:A36E 3C              	  3689: 		INC		A				; Count divides
                        	  3690: 
01:A36F C263A3          	  3691: ENDCON: JP		NZ,SCALMI		; More to do
01:A372 D1              	  3692: 		POP		DE				; Restore code string address
01:A373 F1              	  3693: 		POP		AF				; Restore sign of number
01:A374 CC46A2          	  3694: 		CALL	Z,INVSGN		; Negative - Negate number
01:A377 EB              	  3695: 		EX		DE,HL			; Code string address to HL
01:A378 C9              	  3696: 		RET
                        	  3697: 
01:A379 C8              	  3698: SCALPL: RET		Z				; Exit if no scaling needed
01:A37A F5              	  3699: MULTEN: PUSH	AF				; Save count
01:A37B CD06A2          	  3700: 		CALL	MLSP10			; Multiply number by 10
01:A37E F1              	  3701: 		POP		AF				; Restore count
01:A37F 3D              	  3702: 		DEC		A				; Count multiplies
01:A380 C9              	  3703: 		RET
                        	  3704: 
01:A381 D5              	  3705: ADDIG:	PUSH	DE				; Save sign of exponent
01:A382 57              	  3706: 		LD		D,A				; Save digit
01:A383 78              	  3707: 		LD		A,B				; Get digits after point
01:A384 89              	  3708: 		ADC		A,C				; Add one if after point
01:A385 47              	  3709: 		LD		B,A				; Re-save counter
01:A386 C5              	  3710: 		PUSH	BC				; Save point flags
01:A387 E5              	  3711: 		PUSH	HL				; Save code string address
01:A388 D5              	  3712: 		PUSH	DE				; Save digit
01:A389 CD06A2          	  3713: 		CALL	MLSP10			; Multiply number by 10
01:A38C F1              	  3714: 		POP		AF				; Restore digit
01:A38D D630            	  3715: 		SUB		'0'				; Make it absolute
01:A38F CD98A3          	  3716: 		CALL	RSCALE			; Re-scale number
01:A392 E1              	  3717: 		POP		HL				; Restore code string address
01:A393 C1              	  3718: 		POP		BC				; Restore point flags
01:A394 D1              	  3719: 		POP		DE				; Restore sign of exponent
01:A395 C338A3          	  3720: 		JP		MANLP			; Get another digit
                        	  3721: 
01:A398 CD4EA2          	  3722: RSCALE: CALL	STAKFP			; Put number on stack
01:A39B CD2FA2          	  3723: 		CALL	FLGREL			; Digit to add to FPREG
01:A39E C1              	  3724: PADD:	POP		BC				; Restore number
01:A39F D1              	  3725: 		POP		DE
01:A3A0 C3D79F          	  3726: 		JP		FPADD			; Add BCDE to FPREG and return
                        	  3727: 
01:A3A3 7B              	  3728: EDIGIT: LD		A,E				; Get digit
01:A3A4 07              	  3729: 		RLCA					; Times 2
01:A3A5 07              	  3730: 		RLCA					; Times 4
01:A3A6 83              	  3731: 		ADD		A,E				; Times 5
01:A3A7 07              	  3732: 		RLCA					; Times 10
01:A3A8 86              	  3733: 		ADD		A,(HL)			; Add next digit
01:A3A9 D630            	  3734: 		SUB		'0'				; Make it absolute
01:A3AB 5F              	  3735: 		LD		E,A				; Save new digit
01:A3AC C34EA3          	  3736: 		JP		EXPLP			; Look for another digit
                        	  3737: 
01:A3AF E5              	  3738: LINEIN: PUSH	HL				; Save code string address
01:A3B0 21128F          	  3739: 		LD		HL,INMSG		; Output " in "
01:A3B3 CD149D          	  3740: 		CALL	PRS				; Output string at HL
01:A3B6 E1              	  3741: 		POP		HL				; Restore code string address
01:A3B7 EB              	  3742: PRNTHL: EX		DE,HL			; Code string address to DE
01:A3B8 AF              	  3743: 		XOR		A
01:A3B9 0698            	  3744: 		LD		B,80H+24		; 24 bits
01:A3BB CD34A2          	  3745: 		CALL	RETINT			; Return the integer
01:A3BE 21139D          	  3746: 		LD		HL,PRNUMS		; Print number string
01:A3C1 E5              	  3747: 		PUSH	HL				; Save for return
01:A3C2 21E910          	  3748: NUMASC: LD		HL,PBUFF		; Convert number to ASCII
01:A3C5 E5              	  3749: 		PUSH	HL				; Save for return
01:A3C6 CD1DA2          	  3750: 		CALL	TSTSGN			; Test sign of FPREG
01:A3C9 3620            	  3751: 		LD		(HL),' '		; Space at start
01:A3CB F2D0A3          	  3752: 		JP		P,SPCFST		; Positive - Space to start
01:A3CE 362D            	  3753: 		LD		(HL),'-'		; '-' sign at start
01:A3D0 23              	  3754: SPCFST: INC		HL				; First byte of number
01:A3D1 3630            	  3755: 		LD		(HL),'0'		; '0' if zero
01:A3D3 CA86A4          	  3756: 		JP		Z,JSTZER		; Return '0' if zero
01:A3D6 E5              	  3757: 		PUSH	HL				; Save buffer address
01:A3D7 FC46A2          	  3758: 		CALL	M,INVSGN		; Negate FPREG if negative
01:A3DA AF              	  3759: 		XOR		A				; Zero A
01:A3DB F5              	  3760: 		PUSH	AF				; Save it
01:A3DC CD8CA4          	  3761: 		CALL	RNGTST			; Test number is in range
01:A3DF 014391          	  3762: SIXDIG: LD		BC,9143H		; BCDE - 99999.9
01:A3E2 11F84F          	  3763: 		LD		DE,4FF8H
01:A3E5 CD98A2          	  3764: 		CALL	CMPNUM			; Compare numbers
01:A3E8 B7              	  3765: 		OR		A
01:A3E9 E2FDA3          	  3766: 		JP		PO,INRNG		; > 99999.9 - Sort it out
01:A3EC F1              	  3767: 		POP		AF				; Restore count
01:A3ED CD7AA3          	  3768: 		CALL	MULTEN			; Multiply by ten
01:A3F0 F5              	  3769: 		PUSH	AF				; Re-save count
01:A3F1 C3DFA3          	  3770: 		JP		SIXDIG			; Test it again
                        	  3771: 
01:A3F4 CD65A1          	  3772: GTSIXD: CALL	DIV10			; Divide by 10
01:A3F7 F1              	  3773: 		POP		AF				; Get count
01:A3F8 3C              	  3774: 		INC		A				; Count divides
01:A3F9 F5              	  3775: 		PUSH	AF				; Re-save count
01:A3FA CD8CA4          	  3776: 		CALL	RNGTST			; Test number is in range
01:A3FD CDC59F          	  3777: INRNG:	CALL	ROUND			; Add 0.5 to FPREG
01:A400 3C              	  3778: 		INC		A
01:A401 CDC5A2          	  3779: 		CALL	FPINT			; F.P to integer
01:A404 CD5EA2          	  3780: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A407 010603          	  3781: 		LD		BC,0306H		; 1E+06 to 1E-03 range
01:A40A F1              	  3782: 		POP		AF				; Restore count
01:A40B 81              	  3783: 		ADD		A,C				; 6 digits before point
01:A40C 3C              	  3784: 		INC		A				; Add one
01:A40D FA19A4          	  3785: 		JP		M,MAKNUM		; Do it in 'E' form if < 1E-02
01:A410 FE08            	  3786: 		CP		6+1+1			; More than 999999 ?
01:A412 D219A4          	  3787: 		JP		NC,MAKNUM		; Yes - Do it in 'E' form
01:A415 3C              	  3788: 		INC		A				; Adjust for exponent
01:A416 47              	  3789: 		LD		B,A				; Exponent of number
01:A417 3E02            	  3790: 		LD		A,2				; Make it zero after
                        	  3791: 
01:A419 3D              	  3792: MAKNUM: DEC		A				; Adjust for digits to do
01:A41A 3D              	  3793: 		DEC		A
01:A41B E1              	  3794: 		POP		HL				; Restore buffer address
01:A41C F5              	  3795: 		PUSH	AF				; Save count
01:A41D 119FA4          	  3796: 		LD		DE,POWERS		; Powers of ten
01:A420 05              	  3797: 		DEC		B				; Count digits before point
01:A421 C22AA4          	  3798: 		JP		NZ,DIGTXT		; Not zero - Do number
01:A424 362E            	  3799: 		LD		(HL),'.'		; Save point
01:A426 23              	  3800: 		INC		HL				; Move on
01:A427 3630            	  3801: 		LD		(HL),'0'		; Save zero
01:A429 23              	  3802: 		INC		HL				; Move on
01:A42A 05              	  3803: DIGTXT: DEC		B				; Count digits before point
01:A42B 362E            	  3804: 		LD		(HL),'.'		; Save point in case
01:A42D CC73A2          	  3805: 		CALL	Z,INCHL			; Last digit - move on
01:A430 C5              	  3806: 		PUSH	BC				; Save digits before point
01:A431 E5              	  3807: 		PUSH	HL				; Save buffer address
01:A432 D5              	  3808: 		PUSH	DE				; Save powers of ten
01:A433 CD69A2          	  3809: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A436 E1              	  3810: 		POP		HL				; Powers of ten table
01:A437 062F            	  3811: 		LD		B, '0'-1		; ASCII '0' - 1
01:A439 04              	  3812: TRYAGN: INC		B				; Count subtractions
01:A43A 7B              	  3813: 		LD		A,E				; Get LSB
01:A43B 96              	  3814: 		SUB		(HL)			; Subtract LSB
01:A43C 5F              	  3815: 		LD		E,A				; Save LSB
01:A43D 23              	  3816: 		INC		HL
01:A43E 7A              	  3817: 		LD		A,D				; Get NMSB
01:A43F 9E              	  3818: 		SBC		A,(HL)			; Subtract NMSB
01:A440 57              	  3819: 		LD		D,A				; Save NMSB
01:A441 23              	  3820: 		INC		HL
01:A442 79              	  3821: 		LD		A,C				; Get MSB
01:A443 9E              	  3822: 		SBC		A,(HL)			; Subtract MSB
01:A444 4F              	  3823: 		LD		C,A				; Save MSB
01:A445 2B              	  3824: 		DEC		HL				; Point back to start
01:A446 2B              	  3825: 		DEC		HL
01:A447 D239A4          	  3826: 		JP		NC,TRYAGN		; No overflow - Try again
01:A44A CD7CA0          	  3827: 		CALL	PLUCDE			; Restore number
01:A44D 23              	  3828: 		INC		HL				; Start of next number
01:A44E CD5EA2          	  3829: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A451 EB              	  3830: 		EX		DE,HL			; Save point in table
01:A452 E1              	  3831: 		POP		HL				; Restore buffer address
01:A453 70              	  3832: 		LD		(HL),B			; Save digit in buffer
01:A454 23              	  3833: 		INC		HL				; And move on
01:A455 C1              	  3834: 		POP		BC				; Restore digit count
01:A456 0D              	  3835: 		DEC		C				; Count digits
01:A457 C22AA4          	  3836: 		JP		NZ,DIGTXT		; More - Do them
01:A45A 05              	  3837: 		DEC		B				; Any decimal part?
01:A45B CA6AA4          	  3838: 		JP		Z,DOEBIT		; No - Do 'E' bit
01:A45E 2B              	  3839: SUPTLZ: DEC		HL				; Move back through buffer
01:A45F 7E              	  3840: 		LD		A,(HL)			; Get character
01:A460 FE30            	  3841: 		CP		'0'				; '0' character?
01:A462 CA5EA4          	  3842: 		JP		Z,SUPTLZ		; Yes - Look back for more
01:A465 FE2E            	  3843: 		CP		'.'				; A decimal point?
01:A467 C473A2          	  3844: 		CALL	NZ,INCHL		; Move back over digit
                        	  3845: 
01:A46A F1              	  3846: DOEBIT: POP		AF				; Get 'E' flag
01:A46B CA89A4          	  3847: 		JP		Z,NOENED		; No 'E' needed - End buffer
01:A46E 3645            	  3848: 		LD		(HL),'E'		; Put 'E' in buffer
01:A470 23              	  3849: 		INC		HL				; And move on
01:A471 362B            	  3850: 		LD		(HL),'+'		; Put '+' in buffer
01:A473 F27AA4          	  3851: 		JP		P,OUTEXP		; Positive - Output exponent
01:A476 362D            	  3852: 		LD		(HL),'-'		; Put '-' in buffer
01:A478 2F              	  3853: 		CPL						; Negate exponent
01:A479 3C              	  3854: 		INC		A
01:A47A 062F            	  3855: OUTEXP: LD		B,'0'-1			; ASCII '0' - 1
01:A47C 04              	  3856: EXPTEN: INC		B				; Count subtractions
01:A47D D60A            	  3857: 		SUB		10				; Tens digit
01:A47F D27CA4          	  3858: 		JP		NC,EXPTEN		; More to do
01:A482 C63A            	  3859: 		ADD		A,'0'+10		; Restore and make ASCII
01:A484 23              	  3860: 		INC		HL				; Move on
01:A485 70              	  3861: 		LD		(HL),B			; Save MSB of exponent
01:A486 23              	  3862: JSTZER: INC		HL				;
01:A487 77              	  3863: 		LD		(HL),A			; Save LSB of exponent
01:A488 23              	  3864: 		INC		HL
01:A489 71              	  3865: NOENED: LD		(HL),C			; Mark end of buffer
01:A48A E1              	  3866: 		POP		HL				; Restore code string address
01:A48B C9              	  3867: 		RET
                        	  3868: 
01:A48C 017494          	  3869: RNGTST: LD		BC,9474H		; BCDE = 999999.
01:A48F 11F723          	  3870: 		LD		DE,23F7H
01:A492 CD98A2          	  3871: 		CALL	CMPNUM			; Compare numbers
01:A495 B7              	  3872: 		OR		A
01:A496 E1              	  3873: 		POP		HL				; Return address to HL
01:A497 E2F4A3          	  3874: 		JP		PO,GTSIXD		; Too big - Divide by ten
01:A49A E9              	  3875: 		JP		(HL)			; Otherwise return to caller
                        	  3876: 
01:A49B 00              	  3877: HALF:	db	   00H,00H,00H,80H ; 0.5
01:A49C 00
01:A49D 00
01:A49E 80
                        	  3878: 
01:A49F A0              	  3879: POWERS: db	   0A0H,086H,001H  ; 100000
01:A4A0 86
01:A4A1 01
01:A4A2 10              	  3880: 		db	   010H,027H,000H  ;  10000
01:A4A3 27
01:A4A4 00
01:A4A5 E8              	  3881: 		db	   0E8H,003H,000H  ;   1000
01:A4A6 03
01:A4A7 00
01:A4A8 64              	  3882: 		db	   064H,000H,000H  ;	100
01:A4A9 00
01:A4AA 00
01:A4AB 0A              	  3883: 		db	   00AH,000H,000H  ;	 10
01:A4AC 00
01:A4AD 00
01:A4AE 01              	  3884: 		db	   001H,000H,000H  ;	  1
01:A4AF 00
01:A4B0 00
                        	  3885: 
01:A4B1 2146A2          	  3886: NEGAFT: LD	HL,INVSGN			; Negate result
01:A4B4 E3              	  3887: 		EX		(SP),HL			; To be done after caller
01:A4B5 E9              	  3888: 		JP		(HL)			; Return to caller
                        	  3889: 
01:A4B6 CD4EA2          	  3890: SQR:	CALL	STAKFP			; Put value on stack
01:A4B9 219BA4          	  3891: 		LD		HL,HALF			; Set power to 1/2
01:A4BC CD5BA2          	  3892: 		CALL	PHLTFP			; Move 1/2 to FPREG
                        	  3893: 
01:A4BF C1              	  3894: POWER:	POP		BC				; Get base
01:A4C0 D1              	  3895: 		POP		DE
01:A4C1 CD1DA2          	  3896: 		CALL	TSTSGN			; Test sign of power
01:A4C4 78              	  3897: 		LD		A,B				; Get exponent of base
01:A4C5 CA04A5          	  3898: 		JP		Z,EXPP			; Make result 1 if zero
01:A4C8 F2CFA4          	  3899: 		JP		P,POWER1		; Positive base - Ok
01:A4CB B7              	  3900: 		OR		A				; Zero to negative power?
01:A4CC CA7D8F          	  3901: 		JP		Z,DZERR			; Yes - ?/0 Error
01:A4CF B7              	  3902: POWER1: OR		A				; Base zero?
01:A4D0 CA3EA0          	  3903: 		JP		Z,SAVEXP		; Yes - Return zero
01:A4D3 D5              	  3904: 		PUSH	DE				; Save base
01:A4D4 C5              	  3905: 		PUSH	BC
01:A4D5 79              	  3906: 		LD		A,C				; Get MSB of base
01:A4D6 F67F            	  3907: 		OR		01111111B		; Get sign status
01:A4D8 CD69A2          	  3908: 		CALL	BCDEFP			; Move power to BCDE
01:A4DB F2ECA4          	  3909: 		JP		P,POWER2		; Positive base - Ok
01:A4DE D5              	  3910: 		PUSH	DE				; Save power
01:A4DF C5              	  3911: 		PUSH	BC
01:A4E0 CDF0A2          	  3912: 		CALL	INT				; Get integer of power
01:A4E3 C1              	  3913: 		POP		BC				; Restore power
01:A4E4 D1              	  3914: 		POP		DE
01:A4E5 F5              	  3915: 		PUSH	AF				; MSB of base
01:A4E6 CD98A2          	  3916: 		CALL	CMPNUM			; Power an integer?
01:A4E9 E1              	  3917: 		POP		HL				; Restore MSB of base
01:A4EA 7C              	  3918: 		LD		A,H				; but don't affect flags
01:A4EB 1F              	  3919: 		RRA						; Exponent odd or even?
01:A4EC E1              	  3920: POWER2: POP		HL				; Restore MSB and exponent
01:A4ED 22E610          	  3921: 		LD		(FPREG+2),HL	; Save base in FPREG
01:A4F0 E1              	  3922: 		POP		HL				; LSBs of base
01:A4F1 22E410          	  3923: 		LD		(FPREG),HL		; Save in FPREG
01:A4F4 DCB1A4          	  3924: 		CALL	C,NEGAFT		; Odd power - Negate result
01:A4F7 CC46A2          	  3925: 		CALL	Z,INVSGN		; Negative base - Negate it
01:A4FA D5              	  3926: 		PUSH	DE				; Save power
01:A4FB C5              	  3927: 		PUSH	BC
01:A4FC CDD1A0          	  3928: 		CALL	LOG				; Get LOG of base
01:A4FF C1              	  3929: 		POP		BC				; Restore power
01:A500 D1              	  3930: 		POP		DE
01:A501 CD12A1          	  3931: 		CALL	FPMULT			; Multiply LOG by power
                        	  3932: 
01:A504 CD4EA2          	  3933: EXPP:	CALL	STAKFP			; Put value on stack
01:A507 013881          	  3934: 		LD		BC,08138H		; BCDE = 1/Ln(2)
01:A50A 113BAA          	  3935: 		LD		DE,0AA3BH
01:A50D CD12A1          	  3936: 		CALL	FPMULT			; Multiply value by 1/LN(2)
01:A510 3AE710          	  3937: 		LD		A,(FPEXP)		; Get exponent
01:A513 FE88            	  3938: 		CP		80H+8			; Is it in range?
01:A515 D2F9A1          	  3939: 		JP		NC,OVTST1		; No - Test for overflow
01:A518 CDF0A2          	  3940: 		CALL	INT				; Get INT of FPREG
01:A51B C680            	  3941: 		ADD		A,80H			; For excess 128
01:A51D C602            	  3942: 		ADD		A,2				; Exponent > 126?
01:A51F DAF9A1          	  3943: 		JP		C,OVTST1		; Yes - Test for overflow
01:A522 F5              	  3944: 		PUSH	AF				; Save scaling factor
01:A523 21C0A0          	  3945: 		LD		HL,UNITY		; Point to 1.
01:A526 CDC89F          	  3946: 		CALL	ADDPHL			; Add 1 to FPREG
01:A529 CD09A1          	  3947: 		CALL	MULLN2			; Multiply by LN(2)
01:A52C F1              	  3948: 		POP		AF				; Restore scaling factor
01:A52D C1              	  3949: 		POP		BC				; Restore exponent
01:A52E D1              	  3950: 		POP		DE
01:A52F F5              	  3951: 		PUSH	AF				; Save scaling factor
01:A530 CDD49F          	  3952: 		CALL	SUBCDE			; Subtract exponent from FPREG
01:A533 CD46A2          	  3953: 		CALL	INVSGN			; Negate result
01:A536 2144A5          	  3954: 		LD		HL,EXPTAB		; Coefficient table
01:A539 CD74A5          	  3955: 		CALL	SMSER1			; Sum the series
01:A53C 110000          	  3956: 		LD		DE,0			; Zero LSBs
01:A53F C1              	  3957: 		POP		BC				; Scaling factor
01:A540 4A              	  3958: 		LD		C,D				; Zero MSB
01:A541 C312A1          	  3959: 		JP		FPMULT			; Scale result to correct value
                        	  3960: 
01:A544 08              	  3961: EXPTAB: db	   8					; Table used by EXP
01:A545 40              	  3962: 		db	   040H,02EH,094H,074H	; -1/7! (-1/5040)
01:A546 2E
01:A547 94
01:A548 74
01:A549 70              	  3963: 		db	   070H,04FH,02EH,077H	;  1/6! ( 1/720)
01:A54A 4F
01:A54B 2E
01:A54C 77
01:A54D 6E              	  3964: 		db	   06EH,002H,088H,07AH	; -1/5! (-1/120)
01:A54E 02
01:A54F 88
01:A550 7A
01:A551 E6              	  3965: 		db	   0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
01:A552 A0
01:A553 2A
01:A554 7C
01:A555 50              	  3966: 		db	   050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
01:A556 AA
01:A557 AA
01:A558 7E
01:A559 FF              	  3967: 		db	   0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
01:A55A FF
01:A55B 7F
01:A55C 7F
01:A55D 00              	  3968: 		db	   000H,000H,080H,081H	; -1/1! (-1/1)
01:A55E 00
01:A55F 80
01:A560 81
01:A561 00              	  3969: 		db	   000H,000H,000H,081H	;  1/0! ( 1/1)
01:A562 00
01:A563 00
01:A564 81
                        	  3970: 
01:A565 CD4EA2          	  3971: SUMSER: CALL	STAKFP			; Put FPREG on stack
01:A568 1110A1          	  3972: 		LD		DE,MULTT			; Multiply by "X"
01:A56B D5              	  3973: 		PUSH	DE				; To be done after
01:A56C E5              	  3974: 		PUSH	HL				; Save address of table
01:A56D CD69A2          	  3975: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A570 CD12A1          	  3976: 		CALL	FPMULT			; Square the value
01:A573 E1              	  3977: 		POP		HL				; Restore address of table
01:A574 CD4EA2          	  3978: SMSER1: CALL	STAKFP			; Put value on stack
01:A577 7E              	  3979: 		LD		A,(HL)			; Get number of coefficients
01:A578 23              	  3980: 		INC		HL				; Point to start of table
01:A579 CD5BA2          	  3981: 		CALL	PHLTFP			; Move coefficient to FPREG
01:A57C 06              	  3982: 		db	   06H			   ; Skip "POP AF"
01:A57D F1              	  3983: SUMLP:	POP		AF				; Restore count
01:A57E C1              	  3984: 		POP		BC				; Restore number
01:A57F D1              	  3985: 		POP		DE
01:A580 3D              	  3986: 		DEC		A				; Cont coefficients
01:A581 C8              	  3987: 		RET		Z				; All done
01:A582 D5              	  3988: 		PUSH	DE				; Save number
01:A583 C5              	  3989: 		PUSH	BC
01:A584 F5              	  3990: 		PUSH	AF				; Save count
01:A585 E5              	  3991: 		PUSH	HL				; Save address in table
01:A586 CD12A1          	  3992: 		CALL	FPMULT			; Multiply FPREG by BCDE
01:A589 E1              	  3993: 		POP		HL				; Restore address in table
01:A58A CD6CA2          	  3994: 		CALL	LOADFP			; Number at HL to BCDE
01:A58D E5              	  3995: 		PUSH	HL				; Save address in table
01:A58E CDD79F          	  3996: 		CALL	FPADD			; Add coefficient to FPREG
01:A591 E1              	  3997: 		POP		HL				; Restore address in table
01:A592 C37DA5          	  3998: 		JP		SUMLP			; More coefficients
                        	  3999: 
01:A595 CD1DA2          	  4000: RND:	CALL	TSTSGN			; Test sign of FPREG
01:A598 211910          	  4001: 		LD		HL,SEED+2		; Random number seed
01:A59B FAF6A5          	  4002: 		JP		M,RESEED		; Negative - Re-seed
01:A59E 213A10          	  4003: 		LD		HL,LSTRND		; Last random number
01:A5A1 CD5BA2          	  4004: 		CALL	PHLTFP			; Move last RND to FPREG
01:A5A4 211910          	  4005: 		LD		HL,SEED+2		; Random number seed
01:A5A7 C8              	  4006: 		RET		Z				; Return if RND(0)
01:A5A8 86              	  4007: 		ADD		A,(HL)			; Add (SEED)+2)
01:A5A9 E607            	  4008: 		AND		00000111B		; 0 to 7
01:A5AB 0600            	  4009: 		LD		B,0
01:A5AD 77              	  4010: 		LD		(HL),A			; Re-save seed
01:A5AE 23              	  4011: 		INC		HL				; Move to coefficient table
01:A5AF 87              	  4012: 		ADD		A,A				; 4 bytes
01:A5B0 87              	  4013: 		ADD		A,A				; per entry
01:A5B1 4F              	  4014: 		LD		C,A				; BC = Offset into table
01:A5B2 09              	  4015: 		ADD		HL,BC			; Point to coefficient
01:A5B3 CD6CA2          	  4016: 		CALL	LOADFP			; Coefficient to BCDE
01:A5B6 CD12A1          	  4017: 		CALL	FPMULT	;		; Multiply FPREG by coefficient
01:A5B9 3A1810          	  4018: 		LD		A,(SEED+1)		; Get (SEED+1)
01:A5BC 3C              	  4019: 		INC		A				; Add 1
01:A5BD E603            	  4020: 		AND		00000011B		; 0 to 3
01:A5BF 0600            	  4021: 		LD		B,0
01:A5C1 FE01            	  4022: 		CP		1				; Is it zero?
01:A5C3 88              	  4023: 		ADC		A,B				; Yes - Make it 1
01:A5C4 321810          	  4024: 		LD		(SEED+1),A		; Re-save seed
01:A5C7 21FAA5          	  4025: 		LD		HL,RNDTAB-4		; Addition table
01:A5CA 87              	  4026: 		ADD		A,A				; 4 bytes
01:A5CB 87              	  4027: 		ADD		A,A				; per entry
01:A5CC 4F              	  4028: 		LD		C,A				; BC = Offset into table
01:A5CD 09              	  4029: 		ADD		HL,BC			; Point to value
01:A5CE CDC89F          	  4030: 		CALL	ADDPHL			; Add value to FPREG
01:A5D1 CD69A2          	  4031: RND1:	CALL	BCDEFP			; Move FPREG to BCDE
01:A5D4 7B              	  4032: 		LD		A,E				; Get LSB
01:A5D5 59              	  4033: 		LD		E,C				; LSB = MSB
01:A5D6 EE4F            	  4034: 		XOR		01001111B		; Fiddle around
01:A5D8 4F              	  4035: 		LD		C,A				; New MSB
01:A5D9 3680            	  4036: 		LD		(HL),80H		; Set exponent
01:A5DB 2B              	  4037: 		DEC		HL				; Point to MSB
01:A5DC 46              	  4038: 		LD		B,(HL)			; Get MSB
01:A5DD 3680            	  4039: 		LD		(HL),80H		; Make value -0.5
01:A5DF 211710          	  4040: 		LD		HL,SEED			; Random number seed
01:A5E2 34              	  4041: 		INC		(HL)			; Count seed
01:A5E3 7E              	  4042: 		LD		A,(HL)			; Get seed
01:A5E4 D6AB            	  4043: 		SUB		171				; Do it modulo 171
01:A5E6 C2EDA5          	  4044: 		JP		NZ,RND2			; Non-zero - Ok
01:A5E9 77              	  4045: 		LD		(HL),A			; Zero seed
01:A5EA 0C              	  4046: 		INC		C				; Fillde about
01:A5EB 15              	  4047: 		DEC		D				; with the
01:A5EC 1C              	  4048: 		INC		E				; number
01:A5ED CD28A0          	  4049: RND2:	CALL	BNORM			; Normalise number
01:A5F0 213A10          	  4050: 		LD		HL,LSTRND		; Save random number
01:A5F3 C375A2          	  4051: 		JP		FPTHL			; Move FPREG to last and return
                        	  4052: 
01:A5F6 77              	  4053: RESEED: LD		(HL),A			; Re-seed random numbers
01:A5F7 2B              	  4054: 		DEC		HL
01:A5F8 77              	  4055: 		LD		(HL),A
01:A5F9 2B              	  4056: 		DEC		HL
01:A5FA 77              	  4057: 		LD		(HL),A
01:A5FB C3D1A5          	  4058: 		JP		RND1			; Return RND seed
                        	  4059: 
01:A5FE 68              	  4060: RNDTAB: db		068H,0B1H,046H,068H	; Table used by RND
01:A5FF B1
01:A600 46
01:A601 68
01:A602 99              	  4061: 		db		099H,0E9H,092H,069H
01:A603 E9
01:A604 92
01:A605 69
01:A606 10              	  4062: 		db		010H,0D1H,075H,068H
01:A607 D1
01:A608 75
01:A609 68
                        	  4063: 
01:A60A 2154A6          	  4064: COS:	LD		HL,HALFPI		; Point to PI/2
01:A60D CDC89F          	  4065: 		CALL	ADDPHL			; Add it to PPREG
01:A610 CD4EA2          	  4066: SIN:	CALL	STAKFP			; Put angle on stack
01:A613 014983          	  4067: 		LD		BC,8349H		; BCDE = 2 PI
01:A616 11DB0F          	  4068: 		LD		DE,0FDBH
01:A619 CD5EA2          	  4069: 		CALL	FPBCDE			; Move 2 PI to FPREG
01:A61C C1              	  4070: 		POP		BC				; Restore angle
01:A61D D1              	  4071: 		POP		DE
01:A61E CD73A1          	  4072: 		CALL	DVBCDE			; Divide angle by 2 PI
01:A621 CD4EA2          	  4073: 		CALL	STAKFP			; Put it on stack
01:A624 CDF0A2          	  4074: 		CALL	INT				; Get INT of result
01:A627 C1              	  4075: 		POP		BC				; Restore number
01:A628 D1              	  4076: 		POP		DE
01:A629 CDD49F          	  4077: 		CALL	SUBCDE			; Make it 0 <= value < 1
01:A62C 2158A6          	  4078: 		LD		HL,QUARTR		; Point to 0.25
01:A62F CDCE9F          	  4079: 		CALL	SUBPHL			; Subtract value from 0.25
01:A632 CD1DA2          	  4080: 		CALL	TSTSGN			; Test sign of value
01:A635 37              	  4081: 		SCF						; Flag positive
01:A636 F240A6          	  4082: 		JP		P,SIN1			; Positive - Ok
01:A639 CDC59F          	  4083: 		CALL	ROUND			; Add 0.5 to value
01:A63C CD1DA2          	  4084: 		CALL	TSTSGN			; Test sign of value
01:A63F B7              	  4085: 		OR		A				; Flag negative
01:A640 F5              	  4086: SIN1:	PUSH	AF				; Save sign
01:A641 F446A2          	  4087: 		CALL	P,INVSGN		; Negate value if positive
01:A644 2158A6          	  4088: 		LD		HL,QUARTR		; Point to 0.25
01:A647 CDC89F          	  4089: 		CALL	ADDPHL			; Add 0.25 to value
01:A64A F1              	  4090: 		POP		AF				; Restore sign
01:A64B D446A2          	  4091: 		CALL	NC,INVSGN		; Negative - Make positive
01:A64E 215CA6          	  4092: 		LD		HL,SINTAB		; Coefficient table
01:A651 C365A5          	  4093: 		JP		SUMSER			; Evaluate sum of series
                        	  4094: 
01:A654 DB              	  4095: HALFPI: db		0DBH,00FH,049H,081H	; 1.5708 (PI/2)
01:A655 0F
01:A656 49
01:A657 81
                        	  4096: 
01:A658 00              	  4097: QUARTR: db		000H,000H,000H,07FH	; 0.25
01:A659 00
01:A65A 00
01:A65B 7F
                        	  4098: 
01:A65C 05              	  4099: SINTAB: db		5					; Table used by SIN
01:A65D BA              	  4100: 		db		0BAH,0D7H,01EH,086H	; 39.711
01:A65E D7
01:A65F 1E
01:A660 86
01:A661 64              	  4101: 		db		064H,026H,099H,087H	;-76.575
01:A662 26
01:A663 99
01:A664 87
01:A665 58              	  4102: 		db		058H,034H,023H,087H	; 81.602
01:A666 34
01:A667 23
01:A668 87
01:A669 E0              	  4103: 		db		0E0H,05DH,0A5H,086H	;-41.342
01:A66A 5D
01:A66B A5
01:A66C 86
01:A66D DA              	  4104: 		db		0DAH,00FH,049H,083H	;  6.2832
01:A66E 0F
01:A66F 49
01:A670 83
                        	  4105: 
01:A671 CD4EA2          	  4106: TAN:	CALL	STAKFP			; Put angle on stack
01:A674 CD10A6          	  4107: 		CALL	SIN				; Get SIN of angle
01:A677 C1              	  4108: 		POP		BC				; Restore angle
01:A678 E1              	  4109: 		POP		HL
01:A679 CD4EA2          	  4110: 		CALL	STAKFP			; Save SIN of angle
01:A67C EB              	  4111: 		EX		DE,HL			; BCDE = Angle
01:A67D CD5EA2          	  4112: 		CALL	FPBCDE			; Angle to FPREG
01:A680 CD0AA6          	  4113: 		CALL	COS				; Get COS of angle
01:A683 C371A1          	  4114: 		JP		DIV				; TAN = SIN / COS
                        	  4115: 
01:A686 CD1DA2          	  4116: ATN:	CALL	TSTSGN			; Test sign of value
01:A689 FCB1A4          	  4117: 		CALL	M,NEGAFT		; Negate result after if -ve
01:A68C FC46A2          	  4118: 		CALL	M,INVSGN		; Negate value if -ve
01:A68F 3AE710          	  4119: 		LD		A,(FPEXP)		; Get exponent
01:A692 FE81            	  4120: 		CP		81H				; Number less than 1?
01:A694 DAA3A6          	  4121: 		JP		C,ATN1			; Yes - Get arc tangnt
01:A697 010081          	  4122: 		LD		BC,8100H		; BCDE = 1
01:A69A 51              	  4123: 		LD		D,C
01:A69B 59              	  4124: 		LD		E,C
01:A69C CD73A1          	  4125: 		CALL	DVBCDE			; Get reciprocal of number
01:A69F 21CE9F          	  4126: 		LD		HL,SUBPHL		; Sub angle from PI/2
01:A6A2 E5              	  4127: 		PUSH	HL				; Save for angle > 1
01:A6A3 21ADA6          	  4128: ATN1:	LD		HL,ATNTAB		; Coefficient table
01:A6A6 CD65A5          	  4129: 		CALL	SUMSER			; Evaluate sum of series
01:A6A9 2154A6          	  4130: 		LD		HL,HALFPI		; PI/2 - angle in case > 1
01:A6AC C9              	  4131: 		RET						; Number > 1 - Sub from PI/2
                        	  4132: 
01:A6AD 09              	  4133: ATNTAB: db		9					; Table used by ATN
01:A6AE 4A              	  4134: 		db		04AH,0D7H,03BH,078H	;  1/17
01:A6AF D7
01:A6B0 3B
01:A6B1 78
01:A6B2 02              	  4135: 		db		002H,06EH,084H,07BH	; -1/15
01:A6B3 6E
01:A6B4 84
01:A6B5 7B
01:A6B6 FE              	  4136: 		db		0FEH,0C1H,02FH,07CH	;  1/13
01:A6B7 C1
01:A6B8 2F
01:A6B9 7C
01:A6BA 74              	  4137: 		db		074H,031H,09AH,07DH	; -1/11
01:A6BB 31
01:A6BC 9A
01:A6BD 7D
01:A6BE 84              	  4138: 		db		084H,03DH,05AH,07DH	;  1/9
01:A6BF 3D
01:A6C0 5A
01:A6C1 7D
01:A6C2 C8              	  4139: 		db		0C8H,07FH,091H,07EH	; -1/7
01:A6C3 7F
01:A6C4 91
01:A6C5 7E
01:A6C6 E4              	  4140: 		db		0E4H,0BBH,04CH,07EH	;  1/5
01:A6C7 BB
01:A6C8 4C
01:A6C9 7E
01:A6CA 6C              	  4141: 		db		06CH,0AAH,0AAH,07FH	; -1/3
01:A6CB AA
01:A6CC AA
01:A6CD 7F
01:A6CE 00              	  4142: 		db		000H,000H,000H,081H	;  1/1
01:A6CF 00
01:A6D0 00
01:A6D1 81
                        	  4143: 
                        	  4144: ARET:
01:A6D2 C9              	  4145: 	ret								; A RETurn instruction
                        	  4146: 
                        	  4147: GETINP:
01:A6D3 CDC980          	  4148: 	call	ReadChar				;input a character
01:A6D6 C9              	  4149: 	ret
                        	  4150: 
                        	  4151: CLS:
01:A6D7 C3AC82          	  4152: 	jp		ClearScreen
                        	  4153: 
                        	  4154: WIDTH:
01:A6DA CD9C9F          	  4155: 	call	GETINT					; Get integer 0-255
01:A6DD 7B              	  4156: 	ld		A,E						; Width to A
01:A6DE 324210          	  4157: 	ld		(LWIDTH),A				; Set width
01:A6E1 C9              	  4158: 	ret			
                        	  4159: 			
                        	  4160: LINES:			
01:A6E2 CD3B98          	  4161: 	call	GETNUM					; Get a number
01:A6E5 CD8794          	  4162: 	call	DEINT					; Get integer -32768 to 32767
01:A6E8 ED534610        	  4163: 	ld		(LINESC),DE				; Set lines counter
01:A6EC ED534810        	  4164: 	ld		(LINESN),DE				; Set lines number
01:A6F0 C9              	  4165: 	ret			
                        	  4166: 			
                        	  4167: DEEK:			
01:A6F1 CD8794          	  4168: 	call	DEINT					; Get integer -32768 to 32767
01:A6F4 D5              	  4169: 	push	DE						; Save number
01:A6F5 E1              	  4170: 	pop		HL						; Number to HL
01:A6F6 46              	  4171: 	ld		B,(HL)					; Get LSB of contents
01:A6F7 23              	  4172: 	inc		HL			
01:A6F8 7E              	  4173: 	ld		A,(HL)					; Get MSB of contents
01:A6F9 C3F69B          	  4174: 	jp		ABPASS					; Return integer AB
                        	  4175: 			
                        	  4176: DOKE:			
01:A6FC CD3B98          	  4177: 	call	GETNUM					; Get a number
01:A6FF CD8794          	  4178: 	call	DEINT					; Get integer -32768 to 32767
01:A702 D5              	  4179: 	push	DE						; Save address
01:A703 CD4892          	  4180: 	call	CHKSYN					; Make sure ',' follows
01:A706 2C              	  4181: 	db	   ','			
01:A707 CD3B98          	  4182: 	call	GETNUM					; Get a number
01:A70A CD8794          	  4183: 	call	DEINT					; Get integer -32768 to 32767
01:A70D E3              	  4184: 	ex		(SP),HL					; Save value,get address
01:A70E 73              	  4185: 	ld		(HL),E					; Save LSB of value
01:A70F 23              	  4186: 	inc		HL			
01:A710 72              	  4187: 	ld		(HL),D					; Save MSB of value
01:A711 E1              	  4188: 	pop		HL						; Restore code string address
01:A712 C9              	  4189: 	ret
                        	  4190: 
                        	  4191: 
                        	  4192: ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        	  4193: 
                        	  4194: HEX:
01:A713 CD3E98          	  4195: 	call	TSTNUM					; Verify it's a number
01:A716 CD8794          	  4196: 	call	DEINT					; Get integer -32768 to 32767
01:A719 C5              	  4197: 	push	BC						; Save contents of BC
01:A71A 21E910          	  4198: 	ld		HL,PBUFF			
01:A71D 7A              	  4199: 	ld		A,D						; Get high order into A
01:A71E FE00            	  4200: 	cp		$0			
01:A720 280C            	  4201: 	jr		z,HEX2					; Skip output if both high digits are zero
01:A722 CD4BA7          	  4202: 	call	BYT2ASC					; Convert D to ASCII
01:A725 78              	  4203: 	ld		A,B			
01:A726 FE30            	  4204: 	cp		'0'			
01:A728 2802            	  4205: 	jr		z,HEX1					; Don't store high digit if zero
01:A72A 70              	  4206: 	ld		(HL),B					; Store it to PBUFF
01:A72B 23              	  4207: 	inc		HL						; Next location
                        	  4208: HEX1:			
01:A72C 71              	  4209: 	ld		(HL),C					; Store C to PBUFF+1
01:A72D 23              	  4210: 	inc		HL						; Next location
                        	  4211: HEX2:			
01:A72E 7B              	  4212: 	ld		A,E						; Get lower byte
01:A72F CD4BA7          	  4213: 	call	BYT2ASC					; Convert E to ASCII
01:A732 7A              	  4214: 	ld		A,D			
01:A733 FE00            	  4215: 	cp		$0			
01:A735 2005            	  4216: 	jr		nz,HEX3					; If upper byte was not zero then always print lower byte
01:A737 78              	  4217: 	ld		A,B			
01:A738 FE30            	  4218: 	cp		'0'						; If high digit of lower byte is zero then don't print
01:A73A 2802            	  4219: 	jr		z,HEX4			
                        	  4220: HEX3:			
01:A73C 70              	  4221: 	ld		(HL),B					; to PBUFF+2
01:A73D 23              	  4222: 	inc		HL						; Next location
                        	  4223: HEX4:			
01:A73E 71              	  4224: 	ld		(HL),C					; to PBUFF+3
01:A73F 23              	  4225: 	inc		HL						; PBUFF+4 to zero
01:A740 AF              	  4226: 	xor		A						; Terminating character
01:A741 77              	  4227: 	ld		(HL),A					; Store zero to terminate
01:A742 23              	  4228: 	inc		HL						; Make sure PBUFF is terminated
01:A743 77              	  4229: 	ld		(HL),A					; Store the double zero there
01:A744 C1              	  4230: 	pop		BC						; Get BC back
01:A745 21E910          	  4231: 	ld		HL,PBUFF				; Reset to start of PBUFF
01:A748 C3A49C          	  4232: 	jp		STR1					; Convert the PBUFF to a string and return it
                        	  4233: 			
                        	  4234: BYT2ASC:			
01:A74B 47              	  4235: 	ld		B,A						; Save original value
01:A74C E60F            	  4236: 	and		$0F						; Strip off upper nybble
01:A74E FE0A            	  4237: 	cp		$0A						; 0-9?
01:A750 3802            	  4238: 	jr		c,ADD30					; If A-F, add 7 more
01:A752 C607            	  4239: 	add		A,$07					; Bring value up to ASCII A-F
                        	  4240: ADD30:			
01:A754 C630            	  4241: 	add		A,$30					; And make ASCII
01:A756 4F              	  4242: 	ld		C,A						; Save converted char to C
01:A757 78              	  4243: 	ld		A,B						; Retrieve original value
01:A758 CB0F            	  4244: 	rrc		A							; and Rotate it right
01:A75A CB0F            	  4245: 	rrc		A			
01:A75C CB0F            	  4246: 	rrc		A			
01:A75E CB0F            	  4247: 	rrc		A			
01:A760 E60F            	  4248: 	and		$0F						; Mask off upper nybble
01:A762 FE0A            	  4249: 	cp		$0A						; 0-9? < A hex?
01:A764 3802            	  4250: 	jr		c,ADD301				; Skip Add 7
01:A766 C607            	  4251: 	add		A,$07					; Bring it up to ASCII A-F
                        	  4252: ADD301:			
01:A768 C630            	  4253: 	add		A,$30					; And make it full ASCII
01:A76A 47              	  4254: 	ld		B,A						; Store high order byte
01:A76B C9              	  4255: 	ret	
                        	  4256: 
                        	  4257: ; Convert "&Hnnnn" to FPREG
                        	  4258: ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        	  4259: ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
                        	  4260: HEXTFP:
01:A76C EB              	  4261: 	ex		DE,HL					; Move code string pointer to DE
01:A76D 210000          	  4262: 	ld		HL,$0000				; Zero out the value
01:A770 CD85A7          	  4263: 	call	GETHEX					; Check the number for valid hex
01:A773 DAA5A7          	  4264: 	jp		c,HXERR					; First value wasn't hex, HX error
01:A776 1805            	  4265: 	jr		HEXLP1					; Convert first character
                        	  4266: HEXLP:			
01:A778 CD85A7          	  4267: 	call	GETHEX					; Get second and addtional characters
01:A77B 381F            	  4268: 	jr		c,HEXIT					; Exit if not a hex character
                        	  4269: HEXLP1:			
01:A77D 29              	  4270: 	add		HL,HL					; Rotate 4 bits to the left
01:A77E 29              	  4271: 	add		HL,HL			
01:A77F 29              	  4272: 	add		HL,HL			
01:A780 29              	  4273: 	add		HL,HL			
01:A781 B5              	  4274: 	or		L						; Add in D0-D3 into L
01:A782 6F              	  4275: 	ld		L,A						; Save new value
01:A783 18F3            	  4276: 	jr		HEXLP					; And continue until all hex characters are in
                        	  4277: 			
                        	  4278: GETHEX:			
01:A785 13              	  4279: 	inc		DE						; Next location
01:A786 1A              	  4280: 	ld		A,(DE)					; Load character at pointer
01:A787 FE20            	  4281: 	cp		' '			
01:A789 CA85A7          	  4282: 	jp		z,GETHEX				; Skip spaces
01:A78C D630            	  4283: 	sub		$30						; Get absolute value
01:A78E D8              	  4284: 	ret		c						; < "0", error
01:A78F FE0A            	  4285: 	cp		$0A			
01:A791 3805            	  4286: 	jr		c,NOSUB7				; Is already in the range 0-9
01:A793 D607            	  4287: 	sub		$07						; Reduce to A-F
01:A795 FE0A            	  4288: 	cp		$0A						; Value should be $0A-$0F at this point
01:A797 D8              	  4289: 	ret		c						; CY set if was :			 ; < = > ? @
                        	  4290: NOSUB7:			
01:A798 FE10            	  4291: 	cp		$10						; > Greater than "F"?
01:A79A 3F              	  4292: 	ccf			
01:A79B C9              	  4293: 	ret								; CY set if it wasn't valid hex
                        	  4294: 				
                        	  4295: HEXIT:			
01:A79C EB              	  4296: 	ex		DE,HL					; Value into DE, Code string into HL
01:A79D 7A              	  4297: 	ld		A,D						; Load DE into AC
01:A79E 4B              	  4298: 	ld		C,E						; For prep to 
01:A79F E5              	  4299: 	push	HL			
01:A7A0 CDF59B          	  4300: 	call	ACPASS					; ACPASS to set AC as integer into FPREG
01:A7A3 E1              	  4301: 	pop		HL
01:A7A4 C9              	  4302: 	ret
                        	  4303: 
                        	  4304: HXERR:
01:A7A5 1E26            	  4305: 	ld		E,HX					; ?HEX Error
01:A7A7 C38E8F          	  4306: 	jp		ERROR
                        	  4307: 
                        	  4308: ; BIN$(NN) Convert integer to a 1-16 char binary string
                        	  4309: BIN:
01:A7AA CD3E98          	  4310: 	call	TSTNUM					; Verify it's a number
01:A7AD CD8794          	  4311: 	call	DEINT					; Get integer -32768 to 32767
                        	  4312: BIN2:			
01:A7B0 C5              	  4313: 	push	BC						; Save contents of BC
01:A7B1 21E910          	  4314: 	ld		HL,PBUFF			
01:A7B4 0611            	  4315: 	ld		B,17					; One higher than max char count
                        	  4316: ZEROSUP:								; Suppress leading zeros
01:A7B6 05              	  4317: 	dec		B						; Max 16 chars
01:A7B7 78              	  4318: 	ld		A,B			
01:A7B8 FE01            	  4319: 	cp		$01			
01:A7BA 2808            	  4320: 	jr		z,BITOUT				; Always output at least one character
01:A7BC CB13            	  4321: 	rl		E			
01:A7BE CB12            	  4322: 	rl		D			
01:A7C0 30F4            	  4323: 	jr		NC,ZEROSUP			
01:A7C2 1804            	  4324: 	jr		BITOUT2			
                        	  4325: BITOUT:		 			
01:A7C4 CB13            	  4326: 	rl		E			
01:A7C6 CB12            	  4327: 	rl		D						; Top bit now in carry
                        	  4328: BITOUT2:			
01:A7C8 3E30            	  4329: 	ld		A,'0'					; Char for '0'
01:A7CA CE00            	  4330: 	adc		A,0						; If carry set then '0' --> '1'
01:A7CC 77              	  4331: 	ld		(HL),A			
01:A7CD 23              	  4332: 	inc		HL			
01:A7CE 05              	  4333: 	dec		B			
01:A7CF 20F3            	  4334: 	jr		NZ,BITOUT			
01:A7D1 AF              	  4335: 	xor		A						; Terminating character
01:A7D2 77              	  4336: 	ld		(HL),A					; Store zero to terminate
01:A7D3 23              	  4337: 	inc		HL						; Make sure PBUFF is terminated
01:A7D4 77              	  4338: 	ld		(HL),A					; Store the double zero there
01:A7D5 C1              	  4339: 	pop		BC
01:A7D6 21E910          	  4340: 	ld		HL,PBUFF
01:A7D9 C3A49C          	  4341: 	jp		STR1
                        	  4342: 
                        	  4343: ; Convert "&Bnnnn" to FPREG
                        	  4344: ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
                        	  4345: BINTFP: 
01:A7DC EB              	  4346: 	ex		DE,HL					; Move code string pointer to DE
01:A7DD 210000          	  4347: 	ld		HL,$0000				; Zero out the value
01:A7E0 CDF9A7          	  4348: 	call	CHKBIN					; Check the number for valid bin
01:A7E3 DA07A8          	  4349: 	jp		c,BINERR				; First value wasn't bin, HX error
                        	  4350: BINIT:
01:A7E6 D630            	  4351: 	sub		'0'
01:A7E8 29              	  4352: 	add		HL,HL					; Rotate HL left
01:A7E9 B5              	  4353: 	or		L
01:A7EA 6F              	  4354: 	ld		L,A
01:A7EB CDF9A7          	  4355: 	call	CHKBIN					; Get second and addtional characters
01:A7EE 30F6            	  4356: 	jr		NC,BINIT				; Process if a bin character
01:A7F0 EB              	  4357: 	ex		DE,HL					; Value into DE, Code string into HL
01:A7F1 7A              	  4358: 	ld		A,D						; Load DE into AC
01:A7F2 4B              	  4359: 	ld		C,E						; For prep to 
01:A7F3 E5              	  4360: 	push	HL
01:A7F4 CDF59B          	  4361: 	call	ACPASS					; ACPASS to set AC as integer into FPREG
01:A7F7 E1              	  4362: 	pop		HL
01:A7F8 C9              	  4363: 	ret
                        	  4364: 
                        	  4365: ; Char is in A, NC if char is 0 or 1
                        	  4366: CHKBIN: 
01:A7F9 13              	  4367: 	inc		DE
01:A7FA 1A              	  4368: 	ld		A,(DE)
01:A7FB FE20            	  4369: 	cp		' '
01:A7FD CAF9A7          	  4370: 	jp		Z,CHKBIN				; Skip spaces
01:A800 FE30            	  4371: 	cp		'0'						; Set C if < '0'
01:A802 D8              	  4372: 	ret		c
01:A803 FE32            	  4373: 	cp		'2'
01:A805 3F              	  4374: 	ccf								; Set C if > '1'
01:A806 C9              	  4375: 	ret
                        	  4376: 
                        	  4377: BINERR:
01:A807 1E28            	  4378: 	ld		E,BN					; ?BIN Error
01:A809 C38E8F          	  4379: 	jp		ERROR
                        	  4380: 
                        	  4381: JJUMP1: 
01:A80C DD21FFFF        	  4382: 	ld		IX,-1					; Flag cold start
01:A810 C3D98B          	  4383: 	jp		CSTART					; Go and initialise
                        	  4384: 
                        	  4385: MONOUT: 
01:A813 C37680          	  4386: 	jp		PrintChar				; Output a char
                        	  4387: 
                        	  4388: MONITR: 
01:A816 C30080          	  4389: 	jp		$8000					; Restart (Normally Monitor Start)
                        	  4390: 
                        	  4391: INITST:
01:A819 3E00            	  4392: 	ld		A,0						; Clear break flag
01:A81B 324D10          	  4393: 	ld		(BRKFLG),A
01:A81E C3E08B          	  4394: 	jp		INIT
                        	  4395: 
                        	  4396: ARETN:
01:A821 ED45            	  4397: 	retn							; Return from NMI
                        	  4398: 
                        	  4399: TSTBIT:
01:A823 F5              	  4400: 	push	AF						; Save bit mask
01:A824 A0              	  4401: 	and		B						; Get common bits
01:A825 C1              	  4402: 	pop		BC						; Restore bit mask
01:A826 B8              	  4403: 	cp		B						; Same bit set?
01:A827 3E00            	  4404: 	ld		A,0						; Return 0 in A
01:A829 C9              	  4405: 	ret
                        	  4406: 
                        	  4407: OUTNCR:
01:A82A CD5392          	  4408: 	call	OUTC					; Output character in A
01:A82D C38180          	  4409: 	jp		PrintCRLF				; Output CRLF
                        	  4410: 
                        	  4411: EXIT:
01:A830 C30080          	  4412: 	jp		$8000
                        	  4413: 

Source: "main.asm"
                        	   275: 	.include	"data.asm"			; Various data and text messages. Keep last in list of includes

Source: "data.asm"
                        	     1: ;  ____            _           
                        	     2: ; |  _ \    __ _  | |_    __ _ 
                        	     3: ; | | | |  / _` | | __|  / _` |
                        	     4: ; | |_| | | (_| | | |_  | (_| |
                        	     5: ; |____/   \__,_|  \__|  \__,_|
                        	     6: ;
                        	     7: ; ---------------------------------------------------------------------------------------------------------------------
                        	     8: 
                        	     9: BootMsg:
01:A833 5A65644569676874	    10: 	db		"ZedEighty Project by Frederic Segard",CR,LF
01:A83B 792050726F6A6563
01:A843 7420627920467265
01:A84B 6465726963205365
01:A853 67617264
01:A857 0D
01:A858 0A
01:A859 7777772E796F7574	    11: 	db		"www.youtube.com/@microhobbyist",CR,LF
01:A861 7562652E636F6D2F
01:A869 406D6963726F686F
01:A871 626279697374
01:A877 0D
01:A878 0A
01:A879 7777772E67697468	    12: 	db		"www.github.com/FredericSegard",CR,LF,0
01:A881 75622E636F6D2F46
01:A889 7265646572696353
01:A891 6567617264
01:A896 0D
01:A897 0A
01:A898 00
01:A899 42494F5320302E37	    13: 	db		"BIOS 0.7  (c)2023  ",0," bytes free",CR,LF,LF,0
01:A8A1 2020286329323032
01:A8A9 332020
01:A8AC 00
01:A8AD 2062797465732066
01:A8B5 726565
01:A8B8 0D
01:A8B9 0A
01:A8BA 0A
01:A8BB 00
                        	    14: 
                        	    15: CommandList:						; Commands must be in uppercase, and the jp opcode also acts as a delimiter
01:A8BC 41444452        	    16: 	db		"ADDR"					; Sets current address
01:A8C0 C39F87          	    17: 	jp		SetAddress				;
01:A8C3 42414E4B        	    18: 	db		"BANK"					; Sets current bank
01:A8C7 C3C087          	    19: 	jp		SetBank					;
01:A8CA 4241534943      	    20: 	db		"BASIC"					; Tiny Basic
01:A8CF C3498B          	    21: 	jp		BASIC					;
01:A8D2 434C53          	    22: 	db		"CLS"					; Clear screen command
01:A8D5 C3AC82          	    23: 	jp		ClearScreen				;
01:A8D8 434F5059        	    24: 	db		"COPY"					; Copy data from one place to another (destructive)
01:A8DC C3B582          	    25: 	jp		CopyBlock				;
01:A8DF 44494147        	    26: 	db		"DIAG"					; Test RAM (and eventually other system components)
01:A8E3 C31A83          	    27: 	jp		Diagnostics				;
01:A8E6 46494C4C        	    28: 	db		"FILL"					; Fill a region of memory with a byte of data 
01:A8EA C3EA83          	    29: 	jp		FillMemory				;
                        	    30: ;	db		"FORTH"					; Camel Forth
                        	    31: ;	jp		FORTH					;
01:A8ED 44554D50        	    32: 	db		"DUMP"					; Hex dump command
01:A8F1 C38984          	    33: 	jp		HexDump					;
01:A8F4 4C495354        	    34: 	db		"LIST"					; List of commands
01:A8F8 C3D585          	    35: 	jp		ListCmd					;
01:A8FB 4C4F4144        	    36: 	db		"LOAD"					; Intel Hex load command
01:A8FF C30585          	    37: 	jp		IntelHex				;
01:A902 5045454B        	    38: 	db		"PEEK"					; Read a byte from I/O port
01:A906 C3E485          	    39: 	jp		PeekCmd					;
01:A909 504F4B45        	    40: 	db		"POKE"					; Write a byte to I/O port
01:A90D C31286          	    41: 	jp		PokeCmd					;
01:A910 524547          	    42: 	db		"REG"					; Prints the content of the registers
01:A913 C35286          	    43: 	jp		Registers				;
01:A916 52554E          	    44: 	db		"RUN"					; Execute a program in RAM
01:A919 C38C87          	    45: 	jp		RunCode					;
01:A91C 535953494E464F  	    46: 	db		"SYSINFO"				; Info command
01:A923 C3F187          	    47: 	jp		SysInfo					;
01:A926 5752495445      	    48: 	db		"WRITE"					; Write up to 8 bytes of data
01:A92B C30E88          	    49: 	jp		Write					;
01:A92E 5A45524F        	    50: 	db		"ZERO"					; Zero all memory, including banks
01:A932 C35E88          	    51: 	jp		ZeroAllRam				;
01:A935 FF              	    52: 	db		EOT
                        	    53: 
                        	    54: ListOfCommands:
                        	    55: 	;		"                                        "
01:A936 0A              	    56: 	db		LF
01:A937 4D6F6E69746F7220	    57: 	db		"Monitor Commands",CR,LF,0
01:A93F 436F6D6D616E6473
01:A947 0D
01:A948 0A
01:A949 00
01:A94A 2D2041444452205B	    58: 	db		"- ADDR [AAAA]: Sets current address",CR,LF
01:A952 414141415D3A2053
01:A95A 6574732063757272
01:A962 656E742061646472
01:A96A 657373
01:A96D 0D
01:A96E 0A
01:A96F 2D2042414E4B205B	    59: 	db		"- BANK [N]: Sets current bank",CR,LF
01:A977 4E5D3A2053657473
01:A97F 2063757272656E74
01:A987 2062616E6B
01:A98C 0D
01:A98D 0A
01:A98E 2D2042415349433A	    60: 	db		"- BASIC: Nascom MS BASIC",CR,LF
01:A996 204E6173636F6D20
01:A99E 4D53204241534943
01:A9A6 0D
01:A9A7 0A
01:A9A8 2D20434C533A2043	    61: 	db		"- CLS: Clear screen",CR,LF
01:A9B0 6C65617220736372
01:A9B8 65656E
01:A9BB 0D
01:A9BC 0A
01:A9BD 2D20434F50592053	    62: 	db		"- COPY SSSS DDDD BBBB: Copy memory block",CR,LF
01:A9C5 5353532044444444
01:A9CD 20424242423A2043
01:A9D5 6F7079206D656D6F
01:A9DD 727920626C6F636B
01:A9E5 0D
01:A9E6 0A
01:A9E7 2D20444941473A20	    63: 	db		"- DIAG: Diagnostics (RAM)",CR,LF
01:A9EF 446961676E6F7374
01:A9F7 696373202852414D
01:A9FF 29
01:AA00 0D
01:AA01 0A
01:AA02 2D2044554D50205B	    64: 	db		"- DUMP [AAAA] [LL]: Memory hex dump",CR,LF
01:AA0A 414141415D205B4C
01:AA12 4C5D3A204D656D6F
01:AA1A 7279206865782064
01:AA22 756D70
01:AA25 0D
01:AA26 0A
01:AA27 2D2046494C4C2053	    65: 	db		"- FILL SSSS EEEE BB: Fill memory",CR,LF
01:AA2F 5353532045454545
01:AA37 2042423A2046696C
01:AA3F 6C206D656D6F7279
01:AA47 0D
01:AA48 0A
                        	    66: ;	db		"- FORTH: Camel Forth, by Brad Rodriguez",CR,LF
01:AA49 2D204C4953543A20	    67: 	db		"- LIST: List of commands",CR,LF
01:AA51 4C697374206F6620
01:AA59 636F6D6D616E6473
01:AA61 0D
01:AA62 0A
01:AA63 2D204C4F41443A20	    68: 	db		"- LOAD: Intel Hex loader",CR,LF
01:AA6B 496E74656C204865
01:AA73 78206C6F61646572
01:AA7B 0D
01:AA7C 0A
01:AA7D 2D205045454B2050	    69: 	db		"- PEEK PP: Read a byte from I/O port",CR,LF
01:AA85 503A205265616420
01:AA8D 6120627974652066
01:AA95 726F6D20492F4F20
01:AA9D 706F7274
01:AAA1 0D
01:AAA2 0A
01:AAA3 2D20504F4B452050	    70: 	db		"- POKE PP BB: Write a byte to I/O port",CR,LF
01:AAAB 502042423A205772
01:AAB3 6974652061206279
01:AABB 746520746F20492F
01:AAC3 4F20706F7274
01:AAC9 0D
01:AACA 0A
01:AACB 2D205245473A205A	    71: 	db		"- REG: Z80 registers",CR,LF
01:AAD3 3830207265676973
01:AADB 74657273
01:AADF 0D
01:AAE0 0A
01:AAE1 2D2052554E205B41	    72: 	db		"- RUN [AAAA]: Esecute a program",CR,LF
01:AAE9 4141415D3A204573
01:AAF1 6563757465206120
01:AAF9 70726F6772616D
01:AB00 0D
01:AB01 0A
01:AB02 2D20535953494E46	    73: 	db		"- SYSINFO: System information",CR,LF
01:AB0A 4F3A205379737465
01:AB12 6D20696E666F726D
01:AB1A 6174696F6E
01:AB1F 0D
01:AB20 0A
01:AB21 2D20575249544520	    74: 	db		"- WRITE AAAA BB [BB]...: Write to RAM",CR,LF
01:AB29 4141414120424220
01:AB31 5B42425D2E2E2E3A
01:AB39 2057726974652074
01:AB41 6F2052414D
01:AB46 0D
01:AB47 0A
01:AB48 2D205A45524F3A20	    75: 	db		"- ZERO: Zero free RAM, banks included",CR,LF
01:AB50 5A65726F20667265
01:AB58 652052414D2C2062
01:AB60 616E6B7320696E63
01:AB68 6C75646564
01:AB6D 0D
01:AB6E 0A
01:AB6F 0A              	    76: 	db		LF
01:AB70 202A205479706520	    77: 	db		" * Type ? in command parameter for help",CR,LF
01:AB78 3F20696E20636F6D
01:AB80 6D616E6420706172
01:AB88 616D657465722066
01:AB90 6F722068656C70
01:AB97 0D
01:AB98 0A
01:AB99 0A              	    78: 	db		LF,0
01:AB9A 00
                        	    79: 
                        	    80: FlagBits:
01:AB9B 737A68766E63    	    81: 	db		"szhvnc"				; Flag short hand. Use UpperCase to indicate set, else lowercase indicated clear
                        	    82: 	
                        	    83: ClearScreenSeq:
01:ABA1 1B              	    84: 	db		ESC, "[", "2", "J"		; Clears the screen
01:ABA2 5B
01:ABA3 32
01:ABA4 4A
01:ABA5 1B              	    85: 	db		ESC, "[", "0", "1", ";", "0", "1", "H", 0 ; Sets to home position
01:ABA6 5B
01:ABA7 30
01:ABA8 31
01:ABA9 3B
01:ABAA 30
01:ABAB 31
01:ABAC 48
01:ABAD 00
                        	    86: 	
                        	    87: SysInfoMsg:
                        	    88: 	;		"                                        "
01:ABAE 0A              	    89: 	db		LF
01:ABAF 5A65644569676874	    90: 	db		"ZedEighty System Information",CR,LF,0
01:ABB7 792053797374656D
01:ABBF 20496E666F726D61
01:ABC7 74696F6E
01:ABCB 0D
01:ABCC 0A
01:ABCD 00
01:ABCE 2D204350553A2020	    91: 	db		"- CPU:   Z84C00 Z80 @",0,"7.3728 MHz",CR,LF
01:ABD6 205A383443303020
01:ABDE 5A38302040
01:ABE3 00
01:ABE4 372E33373238204D
01:ABEC 487A
01:ABEE 0D
01:ABEF 0A
01:ABF0 2D20524F4D3A2020	    92: 	db		"- ROM:   64KB FLASH (Shadow ROM)",CR,LF
01:ABF8 2036344B4220464C
01:AC00 4153482028536861
01:AC08 646F7720524F4D29
01:AC10 0D
01:AC11 0A
01:AC12 2D2052414D3A2020	    93: 	db		"- RAM:   64KB SRAM, ",0," bytes free",CR,LF
01:AC1A 2036344B42205352
01:AC22 414D2C20
01:AC26 00
01:AC27 2062797465732066
01:AC2F 726565
01:AC32 0D
01:AC33 0A
01:AC34 2D2042414E4B533A	    94: 	db		"- BANKS: 480KB (15x 32KB in lower RAM)",CR,LF
01:AC3C 203438304B422028
01:AC44 3135782033324B42
01:AC4C 20696E206C6F7765
01:AC54 722052414D29
01:AC5A 0D
01:AC5B 0A
01:AC5C 2D20554152543A20	    95: 	db		"- UART:  Z84C40 SIO/0",CR,LF
01:AC64 205A383443343020
01:AC6C 53494F2F30
01:AC71 0D
01:AC72 0A
01:AC73 0A              	    96: 	db		LF,0
01:AC74 00
                        	    97: 
                        	    98: 
                        	    99: 
                        	   100: 
                        	   101: ;  __  __                                                 
                        	   102: ; |  \/  |   ___   ___   ___    __ _    __ _    ___   ___ 
                        	   103: ; | |\/| |  / _ \ / __| / __|  / _` |  / _` |  / _ \ / __|
                        	   104: ; | |  | | |  __/ \__ \ \__ \ | (_| | | (_| | |  __/ \__ \
                        	   105: ; |_|  |_|  \___| |___/ |___/  \__,_|  \__, |  \___| |___/
                        	   106: ;                                      |___/
                        	   107: ; ---------------------------------------------------------------------------------------------------------------------
                        	   108: ; SYSTEM MESSAGES, AND ERROR MESSAGES
                        	   109: 
                        	   110: 
01:AC75 436F6D6D616E6420	   111: ParseInvalidErr:		db	"Command not found or invalid syntax",CR,LF,0
01:AC7D 6E6F7420666F756E
01:AC85 64206F7220696E76
01:AC8D 616C69642073796E
01:AC95 746178
01:AC98 0D
01:AC99 0A
01:AC9A 00
01:AC9B 496E76616C696420	   112: InvalidHexDigitErr:		db	"Invalid hexadecimal digit in parameter",CR,LF,0
01:ACA3 6865786164656369
01:ACAB 6D616C2064696769
01:ACB3 7420696E20706172
01:ACBB 616D65746572
01:ACC1 0D
01:ACC2 0A
01:ACC3 00
01:ACC4 546F6F206D616E79	   113: TooManyDigitsErr:		db	"Too many number of digits in parameter",CR,LF,0
01:ACCC 206E756D62657220
01:ACD4 6F66206469676974
01:ACDC 7320696E20706172
01:ACE4 616D65746572
01:ACEA 0D
01:ACEB 0A
01:ACEC 00
01:ACED 4D697373696E6720	   114: MissingParameterErr:	db	"Missing Parameter(s)",CR,LF,0
01:ACF5 506172616D657465
01:ACFD 72287329
01:AD01 0D
01:AD02 0A
01:AD03 00
01:AD04 556E7265636F676E	   115: UnrecognizedParamErr:	db	"Unrecognized parameter",CR,LF,0
01:AD0C 697A656420706172
01:AD14 616D65746572
01:AD1A 0D
01:AD1B 0A
01:AD1C 00
01:AD1D 5374617274206772	   116: StartGreaterEndErr:		db	"Start greater than end address",CR,LF,0
01:AD25 6561746572207468
01:AD2D 616E20656E642061
01:AD35 646472657373
01:AD3B 0D
01:AD3C 0A
01:AD3D 00
01:AD3E 5265636F72642074	   117: IntelHexUnsupportedErr:	db	"Record type unsupported: ",0
01:AD46 79706520756E7375
01:AD4E 70706F727465643A
01:AD56 20
01:AD57 00
01:AD58 5265736572766564	   118: InvalidVectorRangeErr:	db	"Reserved vector/stack area",CR,LF,0
01:AD60 20766563746F722F
01:AD68 737461636B206172
01:AD70 6561
01:AD72 0D
01:AD73 0A
01:AD74 00
01:AD75 5265736572766564	   119: ReservedBiosAreaErr:	db	"Reserved BIOS range",CR,LF,0
01:AD7D 2042494F53207261
01:AD85 6E6765
01:AD88 0D
01:AD89 0A
01:AD8A 00
01:AD8B 52616E6765206973	   120: RangeTooSmallErr:		db	"Range is null or too small",CR,LF,0
01:AD93 206E756C6C206F72
01:AD9B 20746F6F20736D61
01:ADA3 6C6C
01:ADA5 0D
01:ADA6 0A
01:ADA7 00
01:ADA8 496E76616C696420	   121: InvalidBankNumberErr:	db	"Invalid bank number ($0-$E)",CR,LF,0
01:ADB0 62616E6B206E756D
01:ADB8 626572202824302D
01:ADC0 244529
01:ADC3 0D
01:ADC4 0A
01:ADC5 00
01:ADC6 496E76616C696420	   122: InvalidDecimalNumberErr	db	"Invalid decimal number",CR,LF,0
01:ADCE 646563696D616C20
01:ADD6 6E756D626572
01:ADDC 0D
01:ADDD 0A
01:ADDE 00
01:ADDF 4E756D6265722069	   123: NumberOutOfRangeErr		db	"Number is out of range",CR,LF,0
01:ADE7 73206F7574206F66
01:ADEF 2072616E6765
01:ADF5 0D
01:ADF6 0A
01:ADF7 00
01:ADF8 4572726F72206174	   124: BadMemory1Err:			db	"Error at ",0
01:AE00 20
01:AE01 00
01:AE02 2C20676F7420    	   125: BadMemory2Err:			db	", got ",0,", expected ",0
01:AE08 00
01:AE09 2C20657870656374
01:AE11 656420
01:AE14 00
01:AE15 4E6F7468696E6720	   126: NothingToCopyErr:		db	"Nothing to copy",CR,LF,0
01:AE1D 746F20636F7079
01:AE24 0D
01:AE25 0A
01:AE26 00
                        	   127: 
01:AE27 54657374696E6720	   128: TestingBankNumberMsg:	db	"Testing Bank RAM #",0
01:AE2F 42616E6B2052414D
01:AE37 2023
01:AE39 00
01:AE3A 54657374696E6720	   129: TestingHighRamMsg:		db	"Testing High RAM",CR,LF,0
01:AE42 486967682052414D
01:AE4A 0D
01:AE4B 0A
01:AE4C 00
01:AE4D 4D656D6F72792074	   130: MemoryTestPassedMsg:	db	"Memory test Passed",CR,LF,0
01:AE55 6573742050617373
01:AE5D 6564
01:AE5F 0D
01:AE60 0A
01:AE61 00
01:AE62 4164647265737320	   131: RangeMsg:				db	"Address range:",0
01:AE6A 72616E67653A
01:AE70 00
01:AE71 46696C6520747261	   132: IntelHexFinishedMsg:	db	"File transfer: ",0
01:AE79 6E736665723A20
01:AE80 00
01:AE81 756E737563636573	   133: IntelHexSuccessMsg:		db	"unsuccessful",CR,LF,0
01:AE89 7366756C
01:AE8D 0D
01:AE8E 0A
01:AE8F 00
01:AE90 4C6F616420612070	   134: IntelHexLoadMsg:		db	"Load a program using Intel Hex format",CR,LF,"Press ESC to cancel",CR,LF,0
01:AE98 726F6772616D2075
01:AEA0 73696E6720496E74
01:AEA8 656C204865782066
01:AEB0 6F726D6174
01:AEB5 0D
01:AEB6 0A
01:AEB7 5072657373204553
01:AEBF 4320746F2063616E
01:AEC7 63656C
01:AECA 0D
01:AECB 0A
01:AECC 00
01:AECD 5472616E73666572	   135: IntelHexAbortedMsg:		db	"Transfer aborted by user",CR,LF,0
01:AED5 2061626F72746564
01:AEDD 2062792075736572
01:AEE5 0D
01:AEE6 0A
01:AEE7 00
01:AEE8 2062797465732074	   136: DownloadedBytesMsg:		db	" bytes transfered",CR,LF,0
01:AEF0 72616E7366657265
01:AEF8 64
01:AEF9 0D
01:AEFA 0A
01:AEFB 00
                        	   137: 
                        	   138: ;					"                                        "
01:AEFC 46696C6C73206120	   139: FillHelp:		db	"Fills a range of memory with a byte.",CR,LF
01:AF04 72616E6765206F66
01:AF0C 206D656D6F727920
01:AF14 7769746820612062
01:AF1C 7974652E
01:AF20 0D
01:AF21 0A
01:AF22 50726F7465637473	   140: 				db	"Protects the vector areas and the BIOS.",CR,LF
01:AF2A 2074686520766563
01:AF32 746F722061726561
01:AF3A 7320616E64207468
01:AF42 652042494F532E
01:AF49 0D
01:AF4A 0A
01:AF4B 55736167653A2046	   141: 				db	"Usage: Fill 2400 A400 8A",CR,LF,LF,0
01:AF53 696C6C2032343030
01:AF5B 2041343030203841
01:AF63 0D
01:AF64 0A
01:AF65 0A
01:AF66 00
                        	   142: 
01:AF67 446973706C617973	   143: HexDumpHelp:	db	"Displays the content of memory. The",CR,LF
01:AF6F 2074686520636F6E
01:AF77 74656E74206F6620
01:AF7F 6D656D6F72792E20
01:AF87 546865
01:AF8A 0D
01:AF8B 0A
01:AF8C 7365636F6E642070	   144: 				db	"second parameter is the number of lines.",CR,LF
01:AF94 6172616D65746572
01:AF9C 2069732074686520
01:AFA4 6E756D626572206F
01:AFAC 66206C696E65732E
01:AFB4 0D
01:AFB5 0A
01:AFB6 55736167653A2044	   145: 				db	"Usage: DUMP 1000 4",CR,LF,LF,0
01:AFBE 554D502031303030
01:AFC6 2034
01:AFC8 0D
01:AFC9 0A
01:AFCA 0A
01:AFCB 00
                        	   146: 
01:AFCC 4C6F616420496E74	   147: IntelHexHelp:	db	"Load IntelHex binary programs via the",CR,LF
01:AFD4 656C486578206269
01:AFDC 6E6172792070726F
01:AFE4 6772616D73207669
01:AFEC 6120746865
01:AFF1 0D
01:AFF2 0A
01:AFF3 53494F20506F7274	   148: 				db	"SIO Port A.",CR,LF
01:AFFB 20412E
01:AFFE 0D
01:AFFF 0A
01:B000 55736167653A204C	   149: 				db	"Usage: LOAD",CR,LF,LF,0
01:B008 4F4144
01:B00B 0D
01:B00C 0A
01:B00D 0A
01:B00E 00
                        	   150: 
                        	   151: Range:
01:B00F E5              	   152: 	push	HL
01:B010 2162AE          	   153: 	ld		HL,RangeMsg
01:B013 CDB080          	   154: 	call	PrintString
01:B016 E1              	   155: 	pop		HL
01:B017 C9              	   156: 	ret
                        	   157: 
                        	   158: InvalidVectorRange:
01:B018 E5              	   159: 	push	HL
01:B019 2158AD          	   160: 	ld		HL,InvalidVectorRangeErr
01:B01C CDB080          	   161: 	call	PrintString
01:B01F E1              	   162: 	pop		HL
01:B020 C9              	   163: 	ret
                        	   164: 
                        	   165: RangeTooSmall:
01:B021 E5              	   166: 	push	HL
01:B022 218BAD          	   167: 	ld		HL,RangeTooSmallErr
01:B025 CDB080          	   168: 	call	PrintString
01:B028 E1              	   169: 	pop		HL
01:B029 C9              	   170: 	ret
                        	   171: 
                        	   172: BiosRange:
01:B02A E5              	   173: 	push	HL
01:B02B 2175AD          	   174: 	ld		HL,ReservedBiosAreaErr
01:B02E CDB080          	   175: 	call	PrintString
01:B031 E1              	   176: 	pop		HL
01:B032 C9              	   177: 	ret
                        	   178: 
                        	   179: RangeInverted:
01:B033 E5              	   180: 	push	HL
01:B034 211DAD          	   181: 	ld		HL,StartGreaterEndErr
01:B037 CDB080          	   182: 	call	PrintString
01:B03A E1              	   183: 	pop		HL
01:B03B C9              	   184: 	ret
                        	   185: 
                        	   186: NoParameter:
01:B03C E5              	   187: 	push	HL
01:B03D CDC089          	   188: 	call	PrintErrorPointer
01:B040 21EDAC          	   189: 	ld		HL,MissingParameterErr
01:B043 CDB080          	   190: 	call	PrintString
01:B046 E1              	   191: 	pop		HL
01:B047 C9              	   192: 	ret
                        	   193: 
                        	   194: InvalidBank:
01:B048 E5              	   195: 	push	HL
01:B049 21A8AD          	   196: 	ld		HL,InvalidBankNumberErr
01:B04C CDB080          	   197: 	call	PrintString
01:B04F E1              	   198: 	pop		HL
01:B050 C9              	   199: 	ret
                        	   200: 
                        	   201: TooManyDigits:
01:B051 E5              	   202: 	push	HL
01:B052 21C4AC          	   203: 	ld		HL,TooManyDigitsErr
01:B055 CDB080          	   204: 	call	PrintString
01:B058 E1              	   205: 	pop		HL
01:B059 C9              	   206: 	ret
                        	   207: 
                        	   208: InvalidHexDigit:
01:B05A E5              	   209: 	push	HL
01:B05B 219BAC          	   210: 	ld		HL,InvalidHexDigitErr
01:B05E CDB080          	   211: 	call	PrintString
01:B061 E1              	   212: 	pop		HL
01:B062 C9              	   213: 	ret
                        	   214: 
                        	   215: NumberOutOfRange:
01:B063 E5              	   216: 	push	HL
01:B064 21DFAD          	   217: 	ld		HL,NumberOutOfRangeErr
01:B067 CDB080          	   218: 	call	PrintString
01:B06A E1              	   219: 	pop		HL
01:B06B C9              	   220: 	ret
                        	   221: 
                        	   222: InvalidDecimalNumber:
01:B06C E5              	   223: 	push	HL
01:B06D 21C6AD          	   224: 	ld		HL,InvalidDecimalNumberErr
01:B070 CDB080          	   225: 	call	PrintString
01:B073 E1              	   226: 	pop		HL
01:B074 C9              	   227: 	ret
                        	   228: 
                        	   229: NothingToCopy:
01:B075 E5              	   230: 	push	HL
01:B076 CDC388          	   231: 	call	DecErrorPointer
01:B079 CDC089          	   232: 	call	PrintErrorPointer
01:B07C 2115AE          	   233: 	ld		HL,NothingToCopyErr
01:B07F CDB080          	   234: 	call	PrintString
01:B082 E1              	   235: 	pop		HL
01:B083 C9              	   236: 	ret
                        	   237: 	

Source: "main.asm"
                        	   276: 
                        	   277: 
                        	   278: ; __     __                 _           _       _              
                        	   279: ; \ \   / /   __ _   _ __  (_)   __ _  | |__   | |   ___   ___ 
                        	   280: ;  \ \ / /   / _` | | '__| | |  / _` | | '_ \  | |  / _ \ / __|
                        	   281: ;   \ V /   | (_| | | |    | | | (_| | | |_) | | | |  __/ \__ \
                        	   282: ;    \_/     \__,_| |_|    |_|  \__,_| |_.__/  |_|  \___| |___/
                        	   283: ;
                        	   284: ; ---------------------------------------------------------------------------------------------------------------------
                        	   285: ; VARIABLES ARE DECLARED IN BYTE SIZE
                        	   286: 
01:B084 00              	   287: CommandBuffer:		ds	HorizTextRes; Command prompt buffer
01:B085 *
01:B0AC 00              	   288: BufferPointer:		ds	2			; Buffer pointer
01:B0AD *
01:B0AE 00              	   289: CmdErrorPointer:	ds	1			; Command line error pointer
01:B0AF 00              	   290: CurrentBank:		ds	1			; Keep track of current bank
01:B0B0 00              	   291: CurrentAddress:		ds	2			; Current Address for prompt
01:B0B1 *
01:B0B2 00              	   292: CurrentPort:		ds	1			; Current I/O port
01:B0B3 00              	   293: DigitString			ds	9			; Digit string for numeric conversions (so they are printable with PrintString)
01:B0B4 *
01:B0BC 0200            	   294: ParseSaveHL			dw	2			; Saves the HL, as HL is used to call routines, and interferes with registers
01:B0BE 00              	   295: RegA:				ds	1			; Register A
01:B0BF 00              	   296: RegBC:				ds	2			; Register BC
01:B0C0 *
01:B0C1 00              	   297: RegDE:				ds	2			; Register DE
01:B0C2 *
01:B0C3 00              	   298: RegHL:				ds	2			; Register HL
01:B0C4 *
01:B0C5 00              	   299: RegIX:				ds	2			; Index IX
01:B0C6 *
01:B0C7 00              	   300: RegIY:				ds	2			; Index IY
01:B0C8 *
01:B0C9 00              	   301: StackPtr:			ds	2			; Index SP
01:B0CA *
01:B0CB 00              	   302: FlagsReg:			ds	1			; Status flags
                        	   303: ;RegI:				ds	1			; 
                        	   304: ;RegR:				ds	1			; 
01:B0CC 00              	   305: StartAddress:		ds	2			; Original start or source address
01:B0CD *
01:B0CE 00              	   306: EndAddress:			ds	2			; Original end or destination address
01:B0CF *
01:B0D0 00              	   307: StartAddressAlt:	ds	2			; Original start or source address
01:B0D1 *
01:B0D2 00              	   308: EndAddressAlt: 		ds	2			; Original end or destination address
01:B0D3 *
01:B0D4 00              	   309: ByteTransfer:		ds	1			; Byte to copy/transfer
01:B0D5 00              	   310: UserCodeSize		ds	2			; Size of uploaded user code 
01:B0D6 *
                        	   311: 
                        	   312: EndOfCode:
01:B0D7 FF              	   313: 	ds	VectorTable-$,$FF			; Fill gap with $FF to optimize speed when programming the FLASH/EEPROM
01:B0D8 *
                        	   314: 
                        	   315: 
                        	   316: ; __     __                _                      _____           _       _        
                        	   317: ; \ \   / /   ___    ___  | |_    ___    _ __    |_   _|   __ _  | |__   | |   ___ 
                        	   318: ;  \ \ / /   / _ \  / __| | __|  / _ \  | '__|     | |    / _` | | '_ \  | |  / _ \
                        	   319: ;   \ V /   |  __/ | (__  | |_  | (_) | | |        | |   | (_| | | |_) | | | |  __/
                        	   320: ;    \_/     \___|  \___|  \__|  \___/  |_|        |_|    \__,_| |_.__/  |_|  \___|
                        	   321: ;
                        	   322: ; ---------------------------------------------------------------------------------------------------------------------
                        	   323: ; CONSTANT VALUES SO EXTERNALLY LOADED PROGRAMS CAN ACCESS SPECIFIC INFORMATION
                        	   324: 	.org	$FD00
                        	   325: 
                        	   326: VectorTable:
                        	   327: 
02:FD00 8000            	   328: IntVectorEnd:		dw	InterruptVectorEnd	;= $FD00			; End of interrupt vector table
02:FD02 00FD            	   329: VectorTableStart:	dw	VectorTable			;= $FD02			; Start of vector and jump tables
02:FD04 0080            	   330: CodeStartAddr:		dw	StartOfCode			;= $FD04			; Start of code address
02:FD06 D7B0            	   331: CodeEndAddr:		dw	EndOfCode			;= $FD06			; End of code address
                        	   332: 
02:FD08 FF              	   333: 	ds	JumpTable-$,$FF				; $FF up to the jump table
02:FD09 *
                        	   334: 
                        	   335: 
                        	   336: ;      _                                 _____           _       _        
                        	   337: ;     | |  _   _   _ __ ___    _ __     |_   _|   __ _  | |__   | |   ___ 
                        	   338: ;  _  | | | | | | | '_ ` _ \  | '_ \      | |    / _` | | '_ \  | |  / _ \
                        	   339: ; | |_| | | |_| | | | | | | | | |_) |     | |   | (_| | | |_) | | | |  __/
                        	   340: ;  \___/   \__,_| |_| |_| |_| | .__/      |_|    \__,_| |_.__/  |_|  \___|
                        	   341: ;                             |_|                                         
                        	   342: ; ---------------------------------------------------------------------------------------------------------------------
                        	   343: ; JUMP TABLE TO CALL ROUTINES FROM AN EXTERNAL PROGRAM
                        	   344: 
                        	   345: 	.org	$FE00
                        	   346: 	
                        	   347: JumpTable:
03:FE00 C36B81          	   348: 	jp		Ascii2HexNibble		;= $FE00				; [A -> A][A -> A]
03:FE03 C38F81          	   349: 	jp		Ascii2HexByte		;= $FE03				; [(HL) -> A][(HL) -> A]
03:FE06 C3AE81          	   350: 	jp		Ascii2HexWord		;= $FE06				; [(HL) -> BC][(HL) -> BC]
03:FE09 C3AC82          	   351: 	jp		ClearScreen			;= $FE09				; [][]
03:FE0C C3CD88          	   352: 	jp		GetHexParameter		;= $FE0C				; [(HL) -> BC,A,(HL)][(HL) -> BC,A,(HL)]
03:FE0F C37680          	   353: 	jp		PrintChar			;= $FE0F				; [A ->][A ->]
03:FE12 C3B080          	   354: 	jp		PrintString			;= $FE12				; [HL ->][HL ->]
03:FE15 C38180          	   355: 	jp		PrintCRLF			;= $FE15				; [][]
03:FE18 C3A080          	   356: 	jp		PrintNibble			;= $FE18				; [A ->][A ->]
03:FE1B C36380          	   357: 	jp		PrintByte			;= $FE1B				; [A ->][A ->]
03:FE1E C3BE80          	   358: 	jp		PrintWord			;= $FE1E				; [HL ->][HL ->]
03:FE21 C3D889          	   359: 	jp		RangeValidation		;= $FE21				; Start&EndAddress -> C, Start&EndAddress, Start&EndAddressAlt)
03:FE24 C3C980          	   360: 	jp		ReadChar			;= $FE24				; [-> A][-> A]
03:FE27 C3D280          	   361: 	jp		ReadCharNoWait		;= $FE27
03:FE2A C3F080          	   362: 	jp		ReadString			;= $FE2A				; [HL ->][HL ->]
03:FE2D C3DD80          	   363: 	jp		ReadByte			;= $FE2D				; [-> A][-> A]
03:FE30 C33F81          	   364: 	jp		ReadWord			;= $FE30				; [-> HL][-> HL]
03:FE33 C33B8B          	   365: 	jp		SkipSpaces			;= $FE33				; [HL -> HL][HL -> HL]
03:FE36 C3A182          	   366: 	jp		UpperCase			;= $FE36				; [A -> A][A -> A]
03:FE39 C35286          	   367: 	jp		Registers			;= $FE39				; [][]
03:FE3C C3C181          	   368: 	jp		Dec2Hex				;= $FE3C				; [(HL) -> BC]
                        	   369: 
                        	   370: VectorEnd:
03:FE3F FF              	   371: 	ds		StackPage-$,$FF		; $FF the rest of the jump table all the way to the stack area
03:FE40 *
                        	   372: 
                        	   373: 
                        	   374: ;  ____    _                    _    
                        	   375: ; / ___|  | |_    __ _    ___  | | __
                        	   376: ; \___ \  | __|  / _` |  / __| | |/ /
                        	   377: ;  ___) | | |_  | (_| | | (__  |   < 
                        	   378: ; |____/   \__|  \__,_|  \___| |_|\_\
                        	   379: ;
                        	   380: ; ---------------------------------------------------------------------------------------------------------------------
                        	   381: ; STACK AREA, ClEAR OUT WITH ZEROS
                        	   382: 
                        	   383: 	.org	$FF00
                        	   384: 
                        	   385: StackPage:
                        	   386: 
04:FF00 00              	   387: 	ds		$FFFF-$,$00			; Zero the stack all the way to end of ROM
04:FF01 *
                        	   388: 
                        	   389: BiosEnd:
                        	   390: .end


Symbols by name:
ABPASS                           A:9BF6
ABS                              A:A242
ACCSUM                           A:9466
ACPASS                           A:9BF5
ADD30                            A:A754
ADD301                           A:A768
ADDEXP                           A:A1DB
ADDIG                            A:A381
ADDPHL                           A:9FC8
ALLFOL                           A:9EC4
ANTVLU                           A:975F
ARET                             A:A6D2
ARETN                            A:A821
ARLDSV                           A:9B16
ARREND                           E:10DA
ARRLP                            A:9D8F
ASCC                             A:9E95
Ascii2BcdDigit                   A:816B
Ascii2HexByte                    A:818F
Ascii2HexByteErr                 A:81AB
Ascii2HexNibble                  A:816B
Ascii2HexNibbleEnd               A:8188
Ascii2HexNibbleErr               A:818D
Ascii2HexNibbleOK                A:8180
Ascii2HexWord                    A:81AE
Ascii2HexWordErr                 A:81BE
ASCTFP                           A:A324
ASPCS                            A:96C1
ATN                              A:A686
ATN1                             A:A6A3
ATNTAB                           A:A6AD
ATOH                             A:94A1
BADINP                           A:96E6
BadMemory1Err                    A:ADF8
BadMemory2Err                    A:AE02
BAKSTK                           A:8F23
BAKTMP                           A:9E75
BankCopyLoop                     A:0083
BankSelect                       E:0030
BASIC                            A:8B49
BASTXT                           E:105E
BCDEFP                           A:A269
BFREE                            A:8C75
BIN                              A:A7AA
BIN2                             A:A7B0
BINERR                           A:A807
BINIT                            A:A7E6
BINTFP                           A:A7DC
BiosEnd                          A:FFFF
BiosRange                        A:B02A
BITOUT                           A:A7C4
BITOUT2                          A:A7C8
BKSP                             E:0008
BN                               E:0028
BNORM                            A:A028
BNRMLP                           A:A02B
BootMsg                          A:A833
BRK                              A:9418
BRKFLG                           E:104D
BRKLIN                           E:10CE
BRKMSG                           A:8F1D
BRKRET                           A:8C6F
BS                               E:0010
BSERR                            A:9B49
BUFFER                           E:1061
BufferPointer                    A:B0AC
BYT2ASC                          A:A74B
BytesFree                        E:CBA9
ByteTransfer                     A:B0D4
BYTSFT                           A:A160
Carry                            E:0000
CFEVAL                           A:9AAC
CHARTY                           A:9A5A
CheckIfCold                      A:8B58
CheckIfWarm                      A:8B65
ChecksumErr                      E:0001
CHEKFN                           A:9C8D
CHKBIN                           A:A7F9
CHKLTR                           A:9473
CHKSTK                           A:8F57
CHKSUM                           E:104A
CHKSYN                           A:9248
CHKTYP                           A:9840
CHR                              A:9EA6
CLEAR                            A:94C6
ClearScreen                      A:82AC
ClearScreenSeq                   A:ABA1
CLOTST                           A:927D
CLREG                            A:90AC
CLRPTR                           A:9087
CLS                              A:A6D7
CmdErrorPointer                  A:B0AE
CMPFP                            A:A2B2
CMPLG1                           A:99C0
CMPLOG                           A:99BE
CMPNUM                           A:A298
CMPRES                           A:9A02
CMPSTR                           A:99EA
CN                               E:0020
CNVNUM                           A:A330
CodeEndAddr                      A:FD06
CodeStartAddr                    A:FD04
COLD                             A:8BCE
ColdOrWarm                       A:8B52
COMMAN                           E:1043
CommandBuffer                    A:B084
CommandList                      A:A8BC
CommandPrompt                    A:88A3
COMPL                            A:A088
CONCAT                           A:9E0A
CONEXP                           A:A360
CONPOS                           A:A025
CONT                             A:944B
CONTAD                           E:10D4
CONVAR                           A:992B
CopyBlock                        A:82B5
CopyDestinationAddress           A:82CA
CopyEnd                          A:8315
CopyNoOverlap                    A:8309
CopyNoParameter                  A:830D
CopyNothing                      A:8312
CopyNumberOfBytes                A:82D8
CopySourceAddress                A:82BC
COPYY                            A:8BE8
COS                              A:A60A
COUNT                            A:92ED
CPDEHL                           A:9242
CPYLIT                           A:917E
CR                               E:000D
CRARLP                           A:9B69
CREARY                           A:9B4E
CRESTR                           A:95C5
CRNCLP                           A:90DF
CRTMST                           A:9CC6
CRTST                            A:9CD2
CRTSTE                           A:9CE8
CRUNCH                           A:90D6
CSTART                           A:8BD9
CTLOFG                           E:1045
CTRLC                            E:0003
CTRLG                            E:0007
CTRLO                            E:000F
CTRLQ                            E:0011
CTRLR                            E:0012
CTRLS                            E:0013
CTRLU                            E:0015
CUROPR                           E:10C5
CURPOS                           E:10AB
CurrentAddress                   A:B0B0
CurrentBank                      A:B0AF
CurrentPort                      A:B0B2
DATAA                            A:956C
DATFLG                           E:10AE
DATLIN                           E:10C9
DATSNR                           A:8F74
DCBCDE                           A:A2E9
DD                               E:0012
DDERR                            A:8F83
Dec2Hex                          A:81C1
Dec2HexEnd                       A:820B
Dec2HexInvalidDec                A:8204
Dec2HexLoop                      A:81CA
Dec2HexOutOfRange                A:81FE
Dec2HexShuffleRegs               A:81F8
DecErrorPointer                  A:88C3
DEEK                             A:A6F1
DEF                              A:9C0A
DEFSIZ                           A:9B71
DEINT                            A:9487
DEL                              E:007F
DELCHR                           A:91AE
DELIMITER                        E:0020
DEPINT                           A:9481
DETHL4                           A:A278
DETHLB                           A:A27A
DiagMemoryAddr                   A:83AE
DiagMemoryError                  A:8397
Diagnostics                      A:831A
DiagnosticsBankLoop              A:8328
DiagnosticsEnd                   A:83D1
DiagnosticsEnd2                  A:83E1
DiagnosticsTest                  A:8363
DiagnosticsTestLoop              A:8366
DigitString                      A:B0B3
DIGTXT                           A:A42A
DIM                              A:9A2C
DIMRET                           A:9A23
DINPOS                           A:9277
DIV                              A:A171
DIV1                             E:100A
DIV10                            A:A165
DIV2                             E:100E
DIV3                             E:1012
DIV4                             E:1015
DIVLP                            A:A198
DIVSUP                           E:1009
DOAGN                            A:90C5
DOCOM                            A:9692
DODEL                            A:918E
DOEBIT                           A:A46A
DOFN                             A:9C37
DOKE                             A:A6FC
DONULL                           A:9680
DOSPC                            A:96BC
DOTAB                            A:96A9
DownloadedBytesMsg               A:AEE8
DPOINT                           A:A35C
DTSTR                            A:9CD6
DVBCDE                           A:A173
DZ                               E:0014
DZERR                            A:8F7D
ECHDEL                           A:91A2
EDIGIT                           A:A3A3
EndAddress                       A:B0CE
EndAddressAlt                    A:B0D2
ENDBUF                           A:9185
ENDCON                           A:A36F
ENDDIM                           A:9BD0
ENDINP                           A:9678
ENDNAM                           A:9A4E
EndOfCode                        A:B0D7
ENDPRG                           A:9427
ENFMEM                           A:8F60
EOT                              E:00FF
ERRIN                            A:8FAE
ERRLIN                           E:10D2
ERRMSG                           A:8F0B
ERROR                            A:8F8E
ERRORPTR                         E:005E
ErrorPtrOffset                   E:0009
ERRORS                           A:8E81
ESC                              E:001B
EVAL                             A:984D
EVAL1                            A:9850
EVAL2                            A:9859
EVAL3                            A:985C
EVLPAR                           A:9912
EVNOT                            A:9A0C
EXCUTE                           A:93B2
EXIT                             A:A830
EXPLP                            A:A34E
EXPP                             A:A504
EXPTAB                           A:A544
EXPTEN                           A:A47C
EXTIG                            A:97BB
FANDT                            A:97E5
FC                               E:0008
FCERR                            A:949C
FDTLP                            A:97CC
FillByte                         A:8414
FillEndAddr                      A:8407
FillHelp                         A:AEFC
FillMemory                       A:83EA
FillMemoryEnd                    A:8484
FillNoParameter                  A:8478
FillPrintHelp                    A:847E
FillRange1                       A:8426
FillRange2                       A:844E
FillStartAddr                    A:83F1
FINDEL                           A:9BAC
FlagBits                         A:AB9B
FlagCarryClear                   A:877C
FlagHalfClear                    A:8758
FlagNegativeClear                A:8770
FlagOverClear                    A:8764
FlagSignClear                    A:8740
FlagsReg                         A:B0CB
FlagZeroClear                    A:874C
FLGDIF                           A:A228
FLGREL                           A:A22F
FNARG                            E:10E0
FNCTAB                           A:8CC5
FNDARY                           A:9B1C
FNDELP                           A:9BB1
FNDEND                           A:905A
FNDNUM                           A:9F99
FNDTOK                           A:92CC
FNDVAR                           A:9A93
FNDWRD                           A:9109
FNOFST                           A:993C
FNRGNM                           E:10DE
FNTHR                            A:9AA1
FNVAL                            A:9963
FOPRND                           A:9885
FOR                              A:9319
FORFLG                           E:10CB
FORFND                           A:9349
FORSLP                           A:932D
FPADD                            A:9FD7
FPBCDE                           A:A25E
FPEXP                            E:10E7
FPINT                            A:A2C5
FPMULT                           A:A112
FPREG                            E:10E4
FPROND                           A:A06F
FPSINT                           A:947B
FPTHL                            A:A275
FRE                              A:9BD4
FRENUM                           A:9BF0
FRMEVL                           A:992E
GARBGE                           A:9D57
GARBLP                           A:9D5A
GETCHR                           A:93D2
GETCMD                           A:8FD2
GetErrorPointerLoop              A:8939
GETHEX                           A:A785
GetHexParameter                  A:88CD
GETINP                           A:A6D3
GETINT                           A:9F9C
GETLEN                           A:9E8A
GETLIN                           A:91BF
GETLN                            A:94A2
GETNUM                           A:983B
GETNXT                           A:9124
GetParamCount                    A:88D3
GetParamErrorEnd                 A:894C
GetParameterEnd                  A:8930
GetParamFetch                    A:88E4
GetParamFetch0                   A:88E9
GetParamFetch1                   A:88F1
GetParamFetch2                   A:8901
GetParamFetch3                   A:890F
GetParamFetch4                   A:8925
GetParamHelp                     A:8932
GetParamHexError                 A:8946
GetParamNumberError              A:8937
GETSTR                           A:9E54
GETVAR                           A:9A31
GNXARY                           A:9D8E
GOFUNC                           A:996B
GOSUB                            A:9518
GOTO                             A:9529
GRBARY                           A:9DAE
GRBDON                           A:9D2F
GRBLP                            A:9D68
GSTRCU                           A:9E57
GSTRDE                           A:9E5B
GSTRHL                           A:9E5A
GTFLNM                           A:9E99
GTFNAM                           A:9A36
GTLNLP                           A:94A5
GTSIXD                           A:A3F4
GTVLUS                           A:9737
HALF                             A:A49B
HalfCarry                        E:0004
HALFPI                           A:A654
HELP                             E:000F
HEX                              A:A713
HEX1                             A:A72C
HEX2                             A:A72E
Hex2Dec                          A:820E
Hex2Dec1                         A:828B
Hex2Dec10                        A:826E
Hex2Dec100                       A:8251
Hex2Dec1000                      A:8234
Hex2Dec10000                     A:8219
Hex2Dec10000Loop                 A:821B
Hex2Dec10000Set                  A:822B
Hex2Dec1000Loop                  A:8236
Hex2Dec1000Set                   A:8248
Hex2Dec100Loop                   A:8253
Hex2Dec100Set                    A:8265
Hex2Dec10Loop                    A:8270
Hex2Dec10Set                     A:8282
Hex2DecEnd                       A:8298
HEX3                             A:A73C
HEX4                             A:A73E
HexDefaultLines                  A:84B4
HexDisplayContent                A:84B6
HexDump                          A:8489
HexDumpEnd                       A:8500
HexDumpHelp                      A:AF67
HexDumpPrintHelp                 A:84FA
HEXIT                            A:A79C
HexLinesToRead                   A:84A1
HEXLP                            A:A778
HEXLP1                           A:A77D
HexNextByte                      A:84C7
HexNextChar                      A:84DA
HexNextLine                      A:84B7
HexPrintChar                     A:84E7
HexReplaceDot                    A:84E5
HEXTFP                           A:A76C
HorizTextRes                     E:0028
HX                               E:0026
HXERR                            A:A7A5
ID                               E:0016
IDTEST                           A:9C7F
IFF                              A:95FB
IFGO                             A:9609
IFJMP                            A:93B9
IncErrorPointer                  A:894E
INCHL                            A:A273
INCLEN                           A:9273
INDFND                           A:8F3D
INEWLN                           A:9022
INIT                             A:8BE0
INITAB                           A:8EAB
INITBE                           A:8F0B
INITST                           A:A819
INMSG                            A:8F12
INP                              A:9F59
INPBIN                           A:9789
INPBRK                           A:9424
INPORT                           E:103F
INPSUB                           E:103E
INPUT                            A:96F7
INRNG                            A:A3FD
INT                              A:A2F0
IntelHex                         A:8505
IntelHexAbort                    A:85AA
IntelHexAbortedMsg               A:AECD
IntelHexAddress                  A:8537
IntelHexByteCount                A:8532
IntelHexCheckOk                  A:8578
IntelHexChecksum                 A:856A
IntelHexData                     A:855F
IntelHexEnd                      A:85CE
IntelHexFinishedMsg              A:AE71
IntelHexHelp                     A:AFCC
IntelHexLoadMsg                  A:AE90
IntelHexParamError               A:85C0
IntelHexPrintEndMsg              A:8585
IntelHexPrintHelp                A:85C8
IntelHexPrintNotOk               A:8597
IntelHexPrintStatus              A:857A
IntelHexRecordType               A:854C
IntelHexStartCode                A:8524
IntelHexSuccessMsg               A:AE81
IntelHexUnsupported              A:85B2
IntelHexUnsupportedErr           A:AD3E
InterruptVectorEnd               A:0080
INTVAR                           A:9096
IntVectorEnd                     A:FD00
InvalidBank                      A:B048
InvalidBankNumberErr             A:ADA8
InvalidDecimalNumber             A:B06C
InvalidDecimalNumberErr          A:ADC6
InvalidHexDigit                  A:B05A
InvalidHexDigitErr               A:AC9B
InvalidVectorRange               A:B018
InvalidVectorRangeErr            A:AD58
INVSGN                           A:A246
ITMSEP                           A:977A
JJUMP1                           A:A80C
JSTZER                           A:A486
JUMP                             E:00C3
JumpTable                        A:FE00
KILFOR                           A:982B
KILIN                            A:91B9
LastRec                          E:0007
LCRFLG                           E:10AC
LEFT                             A:9EB6
LEN                              A:9E86
LET                              A:9583
LETNUM                           A:95D6
LETSTR                           A:959E
LF                               E:000A
LFRGNM                           A:9F4F
LINEAT                           E:105C
LINEIN                           A:A3AF
LINES                            A:A6E2
LINESC                           E:1046
LINESN                           E:1048
LINFND                           A:900B
ListCmd                          A:85D5
LISTLP                           A:929A
ListOfCommands                   A:A936
LISTT                            A:928E
LOADFP                           A:A26C
LOG                              A:A0D1
LOGTAB                           A:A0C4
LOKFOR                           A:8F27
LOOPST                           E:10C7
LS                               E:001C
LSTBIN                           E:10CC
LSTLP2                           A:92BA
LSTLP3                           A:92BD
LSTRAM                           E:10AF
LSTRND                           E:103A
LTSTND                           A:9794
LWIDTH                           E:1042
Main                             A:8046
MAKINT                           A:9F9F
MAKNUM                           A:A419
MANLP                            A:A338
MATCH                            A:9156
MEMMSG                           A:8CBA
MemoryTestPassedMsg              A:AE4D
MID                              A:9EF0
MID1                             A:9EBC
MIDNUM                           A:9F54
MINCDE                           A:A017
MINUS                            A:991A
MissingParameterErr              A:ACED
MKTMST                           A:9CC3
MLDBLP                           A:A311
MLDEBC                           A:A309
MLOOP                            A:8C10
MLSP10                           A:A206
MO                               E:0024
MONITR                           A:A816
MONOUT                           A:A813
MORDT                            A:97A0
MORINP                           A:91C8
MOVBUF                           A:9041
MOVDIR                           A:915E
MOVLP                            A:8F4C
MOVSTR                           A:8F49
MOVUP                            A:8F46
MRPRNT                           A:961B
MSIZE                            A:8BFD
MUL8LP                           A:A13D
MULLN2                           A:A109
MULT8                            A:A134
MULTEN                           A:A37A
MULTT                            A:A110
MULVAL                           E:10F6
MVSTPT                           A:95CD
NEDMOR                           A:9733
NEGAFT                           A:A4B1
Negative                         E:0001
NEW                              A:9086
NEXITM                           A:96CC
NEXT                             A:97F0
NEXT1                            A:97F3
NF                               E:0000
NFERR                            A:8F80
NMI66                            A:0066
NOCHNG                           A:914E
NOENED                           A:A489
NOLIN                            A:943A
NOMADD                           A:A14E
NOMLAD                           A:A31F
NoParameter                      A:B03C
NOPMPT                           A:9711
NORMAL                           A:A042
NOSPC                            A:9145
NOSUB7                           A:A798
NOSWAP                           A:9FF1
NOTAMP                           A:98EF
NothingToCopy                    A:B075
NothingToCopyErr                 A:AE15
NOTSTR                           A:9A69
NOXOR                            A:9F7F
NSCFOR                           A:9A79
NULFLG                           E:1044
NULLL                            A:945E
NULLP                            A:9687
NULLS                            E:1041
NUMASC                           A:A3C2
NumberOutOfRange                 A:B063
NumberOutOfRangeErr              A:ADDF
NXTARY                           A:9B30
NXTBYT                           A:9134
NXTCHR                           A:9175
NXTDAT                           E:10DC
NXTDTA                           A:956B
NXTITM                           A:972B
NXTOPR                           E:10D0
NXTSTL                           A:9572
NXTSTT                           A:9575
OD                               E:0006
OKMSG                            A:8F17
OM                               E:000C
OMERR                            A:8F6F
ON                               A:95DD
ONGO                             A:95EC
ONGOLP                           A:95ED
ONJMP                            A:93BA
OPNPAR                           A:9849
OPRND                            A:98C4
OS                               E:001A
OTKLN                            A:91B6
OTPORT                           E:1007
OUTC                             A:9253
OUTEXP                           A:A47A
OUTIT                            A:9234
OUTNBS                           A:923A
OUTNCR                           A:A82A
OUTSUB                           E:1006
OUTWRD                           A:92D6
OV                               E:000A
Overflow                         E:0002
OVERR                            A:8F89
OVTST1                           A:A1F9
OVTST2                           A:A1FE
OVTST3                           A:A1FF
PADD                             A:A39E
PAND                             A:9985
ParseEnd                         A:89B9
ParseExecute                     A:89A4
ParseInvalid                     A:89B3
ParseInvalidErr                  A:AC75
ParseNextChar                    A:8972
ParseNextCmd                     A:898A
Parser                           A:8958
ParseSaveHL                      A:B0BC
ParseValidate                    A:899B
PASSA                            A:9C05
PBUFF                            E:10E9
PEEK                             A:9FAD
PeekAddress                      A:85EA
PeekCmd                          A:85E4
PeekEnd                          A:860E
PeekError                        A:860E
PeekNoParameter                  A:8608
PeekRead                         A:85F4
PEND                             A:941F
PHLTFP                           A:A25B
PLUCDE                           A:A07C
PNORM                            A:A04A
POINT                            E:1051
POKE                             A:9FB4
PokeCmd                          A:8612
PokeEnd                          A:864E
PokeError                        A:864E
PokeGetByte                      A:8626
PokeGetPort                      A:8618
PokeNoParameter                  A:8648
PokeWrite                        A:8631
POPAF                            A:9D49
POPHL                            A:9E73
POPHRT                           A:A15E
POPNOK                           A:8FC4
POR                              A:9984
POR1                             A:99A7
POS                              A:9C02
POSINT                           A:947E
POUT                             A:9F65
POWER                            A:A4BF
POWER1                           A:A4CF
POWER2                           A:A4EC
POWERS                           A:A49F
PrintByte                        A:8063
PrintChar                        A:8076
PrintCharTxWait                  A:8077
PrintCRLF                        A:8081
PrintDec                         A:805A
PrintErrorLoop                   A:89C6
PrintErrorPointer                A:89C0
PrintLine                        A:808E
PrintLineLoop                    A:8095
PrintNibble                      A:80A0
PrintNibbleEnd                   A:80AB
PrintString                      A:80B0
PrintStringEnd                   A:80BC
PrintStringLoop                  A:80B1
PRINTT                           A:961F
PrintWord                        A:80BE
PRITAB                           A:8E6C
PRNTHL                           A:A3B7
PRNTLP                           A:9622
PRNTNB                           A:9665
PRNTOK                           A:8FC5
PRNTST                           A:9669
PRNUMS                           A:9D13
PROCES                           A:91E1
PROGND                           E:10D6
PROGST                           E:10F9
PROMPT                           A:90C9
PRS                              A:9D14
PRS1                             A:9D17
PRSLP                            A:9D1E
PSET                             E:1054
PSUB                             A:9FD2
PTRLP                            A:904E
PUTBUF                           A:9220
PUTCTL                           A:9225
PUTFID                           A:938E
QTSTLP                           A:9CD9
QTSTR                            A:9CD3
QUARTR                           A:A658
Range                            A:B00F
RangeInverted                    A:B033
RangeMsg                         A:AE62
RangeTooSmall                    A:B021
RangeTooSmallErr                 A:AD8B
RangeValidation                  A:89D8
RangeValidationEnd               A:8B2F
RangeValidationError             A:8B2B
READ                             A:9726
ReadByte                         A:80DD
ReadChar                         A:80C9
ReadCharNoWait                   A:80D2
READFG                           E:10CD
ReadString                       A:80F0
ReadStringBS                     A:811B
ReadStringChar                   A:80F8
ReadStringCR                     A:8135
ReadStringESC                    A:8134
ReadStringSave                   A:810F
ReadWord                         A:813F
REDO                             A:96D3
RegA                             A:B0BE
RegBC                            A:B0BF
RegDE                            A:B0C1
RegHL                            A:B0C3
Registers                        A:8652
RegIX                            A:B0C5
RegIY                            A:B0C7
REM                              A:956E
RESDIV                           A:A1AB
RESEED                           A:A5F6
ReservedBiosAreaErr              A:AD75
RESET                            E:1057
ResetErrorPointer                A:8B33
RESTNL                           A:93F7
RESTOR                           A:93E2
RESZER                           A:A03D
RETADR                           A:9AE0
RETINT                           A:A234
RETLIN                           A:9566
RETNAD                           A:915A
RETNUL                           A:9AE3
RETNUM                           A:9926
RETREL                           A:A226
RETURN                           A:9547
RG                               E:0004
RIGHT                            A:9EE6
RIGHT1                           A:9EBA
RINPUT                           E:104E
RLTLP                            A:9869
RND                              A:A595
RND1                             A:A5D1
RND2                             A:A5ED
RNDTAB                           A:A5FE
RNGTST                           A:A48C
ROMCopy                          A:0098
RomDisable                       E:0038
RONDB                            A:A05E
RONDUP                           A:A05D
ROUND                            A:9FC5
RSCALE                           A:A398
RSLNBK                           A:9310
RST00                            A:0000
RST08                            A:0008
RST10                            A:0010
RST18                            A:0018
RST20                            A:0020
RST28                            A:0028
RST30                            A:0030
RST38                            A:0038
RSTSTR                           A:9F09
RUN                              A:950C
RunCallBC                        A:879C
RUNCNT                           A:9392
RunCode                          A:878C
RunEnd                           A:879E
RUNFST                           A:9092
RUNLIN                           A:9528
SAVEXP                           A:A03E
SAVSTP                           A:9385
SAVSTR                           A:9CAE
SBSCPT                           A:9AEE
SCALE                            A:A09C
SCALLP                           A:A09E
SCALMI                           A:A363
SCALPL                           A:A379
SCNEND                           A:9DE5
SCPTLP                           A:9AF4
SEARCH                           A:9122
SEED                             E:1017
SetAddress                       A:879F
SetAddressDefault                A:87B5
SetAddressEnd                    A:87BB
SetBank                          A:87C0
SetBankDefault                   A:87E0
SetBankEnd                       A:87EC
SetBankError                     A:87E9
SETIO                            A:9F89
SETLIN                           A:92E4
SETLIT                           A:916C
SETPTR                           A:9049
SETTOP                           A:8C34
SFTPRG                           A:9013
SGN                              A:A22C
SGNEXP                           A:9974
SGNRES                           E:10E8
ShadowCopy                       A:0080
SHRITE                           A:A0AB
SHRLP                            A:A0AE
SHRT1                            A:A0B2
Sign                             E:0007
SIGNON                           A:8C84
SignOnMsg                        A:8B72
SIGNS                            A:A283
SIN                              A:A610
SIN1                             A:A640
SINTAB                           A:A65C
SIO_Init                         A:814D
SIO_PortA_Ctrl                   E:0002
SIO_PortA_Data                   E:0000
SIXDIG                           A:A3DF
SkipSpaces                       A:8B3B
SkipSpacesEnd                    A:8B47
SkipSpacesLoop                   A:8B3C
SMPVAR                           A:9D79
SMSER1                           A:A574
SN                               E:0002
SNERR                            A:8F7A
SPCFST                           A:A3D0
SPCLP                            A:96C5
SQR                              A:A4B6
SRCHLN                           A:9066
SRCHLP                           A:9069
SSTSA                            A:9E41
ST                               E:001E
STACK                            E:1066
StackPage                        A:FF00
StackPtr                         A:B0C9
STAKFP                           A:A24E
STALL                            A:940C
StartAddr                        E:0000
StartAddress                     A:B0CC
StartAddressAlt                  A:B0D0
StartGreaterEndErr               A:AD1D
StartOfCode                      A:8000
STKTHS                           A:98AD
STLOOK                           E:115D
STOPP                            A:941D
STORED                           A:94E9
STPOOL                           A:9DBC
STR1                             A:9CA4
STRADD                           A:9DBF
STRBOT                           E:10C3
STRENT                           A:977D
STRR                             A:9C9E
STRSPC                           E:105A
STTLIN                           A:9670
SUBCDE                           A:9FD4
SUBPHL                           A:9FCE
SUMLP                            A:A57D
SUMSER                           A:A565
SUPTLZ                           A:A45E
SVNAM2                           A:9A4D
SVSTAD                           A:9CCC
SysInfo                          A:87F1
SysInfoMsg                       A:ABAE
TAN                              A:A671
TestingBankNumberMsg             A:AE27
TestingHighRamMsg                A:AE3A
TESTOS                           A:9D4B
TESTR                            A:9D2D
TM                               E:0018
TMERR                            A:8F8C
TMPSTR                           E:10BF
TMSTPL                           E:10B3
TMSTPT                           E:10B1
TooManyDigits                    A:B051
TooManyDigitsErr                 A:ACC4
TOPOOL                           A:9EB2
TOSTRA                           A:9E4A
TRYAGN                           A:A439
TSALP                            A:9E4B
TSTBIT                           A:A823
TSTBRK                           A:93FD
TSTMEM                           A:8C22
TSTNUM                           A:983E
TSTOPL                           A:9CF4
TSTRED                           A:99AC
TSTREM                           A:916F
TSTSGN                           A:A21D
TSTSTR                           A:983F
TTYLIN                           A:91BF
TYPE                             E:10AD
UF                               E:0022
UFERR                            A:8F86
UL                               E:000E
ULERR                            A:9542
UNITY                            A:A0C0
UnrecognizedParamErr             A:AD04
UPDATA                           A:93F8
UpperCase                        A:82A1
UpperCaseEnd                     A:82AB
UserCodeSize                     A:B0D5
USR                              E:1003
VAL                              A:9F20
VAL1                             A:9F3E
VAL2                             A:9F48
VAL3                             A:9F4B
ValBiosOverlap                   A:8AA0
ValBiosRangeError                A:8B19
ValCheckBiosHi                   A:8A3B
ValCheckBiosLow                  A:8A30
ValCheckHigh                     A:8A49
ValCheckHighBios                 A:8A6F
ValCheckHighLimit                A:8A13
ValCheckHighLimit2               A:8A24
ValCheckIfZeroDataHigh           A:8ACC
ValCheckIfZeroDataLow            A:8ABC
ValCheckInverted                 A:89E6
ValCheckLow                      A:8A7D
ValCheckLowBios                  A:8A97
ValCheckLowLimit                 A:89F6
ValCheckLowLimit2                A:8A07
ValInvertedError                 A:8B25
ValPrintRange                    A:8ADC
ValPrintRange1                   A:8ADF
ValPrintRange2                   A:8AF9
ValPrintRangeEnd                 A:8B13
ValRangeTooSmallError            A:8B1F
VAREND                           E:10D8
VectorCopy                       A:00A3
VectorEnd                        A:FE3F
VectorTable                      A:FD00
VectorTableStart                 A:FD02
VertTextRes                      E:0018
WAIT                             A:9F6B
WAITLP                           A:9F80
WARM                             A:8C6C
WIDTH                            A:A6DA
WORDS                            A:8CFD
WORDTB                           A:8E20
Write                            A:880E
WriteEnd                         A:8859
WriteFirstByte                   A:8821
WriteGetAddress                  A:8815
WriteNoParameter                 A:8856
WriteRemainingBytes              A:8835
WriteTooManyDigits               A:884B
WRKSPC                           E:1000
ZDATA                            E:0083
ZEND                             E:0080
ZEQUAL                           E:00B4
ZERARY                           A:9B8F
ZERBYT                           E:8F16
Zero                             E:0006
ZeroAllRam                       A:885E
ZeroEnd                          A:889E
ZeroHighRange                    A:8885
ZeroLowRange                     A:8864
ZEROLP                           A:9AD2
ZEROSUP                          A:A7B6
ZFN                              E:00A7
ZFOR                             E:0081
ZGOSUB                           E:008C
ZGOTO                            E:0088
ZGTR                             E:00B3
ZLEFT                            E:00CF
ZLTH                             E:00B5
ZMINUS                           E:00AD
ZNEW                             E:00A4
ZNOT                             E:00AA
ZONELP                           A:96A0
ZOR                              E:00B2
ZPLUS                            E:00AC
ZPRINT                           E:009E
ZREM                             E:008E
ZSGN                             E:00B6
ZSPC                             E:00A8
ZSTEP                            E:00AB
ZTAB                             E:00A5
ZTHEN                            E:00A9
ZTO                              E:00A6

Symbols by value:
0000 Carry
0000 StartAddr
0000 SIO_PortA_Data
0000 RST00
0000 NF
0001 Negative
0001 ChecksumErr
0002 Overflow
0002 SIO_PortA_Ctrl
0002 SN
0003 CTRLC
0004 RG
0004 HalfCarry
0006 OD
0006 Zero
0007 Sign
0007 LastRec
0007 CTRLG
0008 FC
0008 BKSP
0008 RST08
0009 ErrorPtrOffset
000A OV
000A LF
000C OM
000D CR
000E UL
000F HELP
000F CTRLO
0010 BS
0010 RST10
0011 CTRLQ
0012 CTRLR
0012 DD
0013 CTRLS
0014 DZ
0015 CTRLU
0016 ID
0018 RST18
0018 VertTextRes
0018 TM
001A OS
001B ESC
001C LS
001E ST
0020 CN
0020 DELIMITER
0020 RST20
0022 UF
0024 MO
0026 HX
0028 RST28
0028 HorizTextRes
0028 BN
0030 RST30
0030 BankSelect
0038 RomDisable
0038 RST38
005E ERRORPTR
0066 NMI66
007F DEL
0080 ZEND
0080 ShadowCopy
0080 InterruptVectorEnd
0081 ZFOR
0083 BankCopyLoop
0083 ZDATA
0088 ZGOTO
008C ZGOSUB
008E ZREM
0098 ROMCopy
009E ZPRINT
00A3 VectorCopy
00A4 ZNEW
00A5 ZTAB
00A6 ZTO
00A7 ZFN
00A8 ZSPC
00A9 ZTHEN
00AA ZNOT
00AB ZSTEP
00AC ZPLUS
00AD ZMINUS
00B2 ZOR
00B3 ZGTR
00B4 ZEQUAL
00B5 ZLTH
00B6 ZSGN
00C3 JUMP
00CF ZLEFT
00FF EOT
1000 WRKSPC
1003 USR
1006 OUTSUB
1007 OTPORT
1009 DIVSUP
100A DIV1
100E DIV2
1012 DIV3
1015 DIV4
1017 SEED
103A LSTRND
103E INPSUB
103F INPORT
1041 NULLS
1042 LWIDTH
1043 COMMAN
1044 NULFLG
1045 CTLOFG
1046 LINESC
1048 LINESN
104A CHKSUM
104D BRKFLG
104E RINPUT
1051 POINT
1054 PSET
1057 RESET
105A STRSPC
105C LINEAT
105E BASTXT
1061 BUFFER
1066 STACK
10AB CURPOS
10AC LCRFLG
10AD TYPE
10AE DATFLG
10AF LSTRAM
10B1 TMSTPT
10B3 TMSTPL
10BF TMPSTR
10C3 STRBOT
10C5 CUROPR
10C7 LOOPST
10C9 DATLIN
10CB FORFLG
10CC LSTBIN
10CD READFG
10CE BRKLIN
10D0 NXTOPR
10D2 ERRLIN
10D4 CONTAD
10D6 PROGND
10D8 VAREND
10DA ARREND
10DC NXTDAT
10DE FNRGNM
10E0 FNARG
10E4 FPREG
10E7 FPEXP
10E8 SGNRES
10E9 PBUFF
10F6 MULVAL
10F9 PROGST
115D STLOOK
8000 StartOfCode
8046 Main
805A PrintDec
8063 PrintByte
8076 PrintChar
8077 PrintCharTxWait
8081 PrintCRLF
808E PrintLine
8095 PrintLineLoop
80A0 PrintNibble
80AB PrintNibbleEnd
80B0 PrintString
80B1 PrintStringLoop
80BC PrintStringEnd
80BE PrintWord
80C9 ReadChar
80D2 ReadCharNoWait
80DD ReadByte
80F0 ReadString
80F8 ReadStringChar
810F ReadStringSave
811B ReadStringBS
8134 ReadStringESC
8135 ReadStringCR
813F ReadWord
814D SIO_Init
816B Ascii2BcdDigit
816B Ascii2HexNibble
8180 Ascii2HexNibbleOK
8188 Ascii2HexNibbleEnd
818D Ascii2HexNibbleErr
818F Ascii2HexByte
81AB Ascii2HexByteErr
81AE Ascii2HexWord
81BE Ascii2HexWordErr
81C1 Dec2Hex
81CA Dec2HexLoop
81F8 Dec2HexShuffleRegs
81FE Dec2HexOutOfRange
8204 Dec2HexInvalidDec
820B Dec2HexEnd
820E Hex2Dec
8219 Hex2Dec10000
821B Hex2Dec10000Loop
822B Hex2Dec10000Set
8234 Hex2Dec1000
8236 Hex2Dec1000Loop
8248 Hex2Dec1000Set
8251 Hex2Dec100
8253 Hex2Dec100Loop
8265 Hex2Dec100Set
826E Hex2Dec10
8270 Hex2Dec10Loop
8282 Hex2Dec10Set
828B Hex2Dec1
8298 Hex2DecEnd
82A1 UpperCase
82AB UpperCaseEnd
82AC ClearScreen
82B5 CopyBlock
82BC CopySourceAddress
82CA CopyDestinationAddress
82D8 CopyNumberOfBytes
8309 CopyNoOverlap
830D CopyNoParameter
8312 CopyNothing
8315 CopyEnd
831A Diagnostics
8328 DiagnosticsBankLoop
8363 DiagnosticsTest
8366 DiagnosticsTestLoop
8397 DiagMemoryError
83AE DiagMemoryAddr
83D1 DiagnosticsEnd
83E1 DiagnosticsEnd2
83EA FillMemory
83F1 FillStartAddr
8407 FillEndAddr
8414 FillByte
8426 FillRange1
844E FillRange2
8478 FillNoParameter
847E FillPrintHelp
8484 FillMemoryEnd
8489 HexDump
84A1 HexLinesToRead
84B4 HexDefaultLines
84B6 HexDisplayContent
84B7 HexNextLine
84C7 HexNextByte
84DA HexNextChar
84E5 HexReplaceDot
84E7 HexPrintChar
84FA HexDumpPrintHelp
8500 HexDumpEnd
8505 IntelHex
8524 IntelHexStartCode
8532 IntelHexByteCount
8537 IntelHexAddress
854C IntelHexRecordType
855F IntelHexData
856A IntelHexChecksum
8578 IntelHexCheckOk
857A IntelHexPrintStatus
8585 IntelHexPrintEndMsg
8597 IntelHexPrintNotOk
85AA IntelHexAbort
85B2 IntelHexUnsupported
85C0 IntelHexParamError
85C8 IntelHexPrintHelp
85CE IntelHexEnd
85D5 ListCmd
85E4 PeekCmd
85EA PeekAddress
85F4 PeekRead
8608 PeekNoParameter
860E PeekEnd
860E PeekError
8612 PokeCmd
8618 PokeGetPort
8626 PokeGetByte
8631 PokeWrite
8648 PokeNoParameter
864E PokeEnd
864E PokeError
8652 Registers
8740 FlagSignClear
874C FlagZeroClear
8758 FlagHalfClear
8764 FlagOverClear
8770 FlagNegativeClear
877C FlagCarryClear
878C RunCode
879C RunCallBC
879E RunEnd
879F SetAddress
87B5 SetAddressDefault
87BB SetAddressEnd
87C0 SetBank
87E0 SetBankDefault
87E9 SetBankError
87EC SetBankEnd
87F1 SysInfo
880E Write
8815 WriteGetAddress
8821 WriteFirstByte
8835 WriteRemainingBytes
884B WriteTooManyDigits
8856 WriteNoParameter
8859 WriteEnd
885E ZeroAllRam
8864 ZeroLowRange
8885 ZeroHighRange
889E ZeroEnd
88A3 CommandPrompt
88C3 DecErrorPointer
88CD GetHexParameter
88D3 GetParamCount
88E4 GetParamFetch
88E9 GetParamFetch0
88F1 GetParamFetch1
8901 GetParamFetch2
890F GetParamFetch3
8925 GetParamFetch4
8930 GetParameterEnd
8932 GetParamHelp
8937 GetParamNumberError
8939 GetErrorPointerLoop
8946 GetParamHexError
894C GetParamErrorEnd
894E IncErrorPointer
8958 Parser
8972 ParseNextChar
898A ParseNextCmd
899B ParseValidate
89A4 ParseExecute
89B3 ParseInvalid
89B9 ParseEnd
89C0 PrintErrorPointer
89C6 PrintErrorLoop
89D8 RangeValidation
89E6 ValCheckInverted
89F6 ValCheckLowLimit
8A07 ValCheckLowLimit2
8A13 ValCheckHighLimit
8A24 ValCheckHighLimit2
8A30 ValCheckBiosLow
8A3B ValCheckBiosHi
8A49 ValCheckHigh
8A6F ValCheckHighBios
8A7D ValCheckLow
8A97 ValCheckLowBios
8AA0 ValBiosOverlap
8ABC ValCheckIfZeroDataLow
8ACC ValCheckIfZeroDataHigh
8ADC ValPrintRange
8ADF ValPrintRange1
8AF9 ValPrintRange2
8B13 ValPrintRangeEnd
8B19 ValBiosRangeError
8B1F ValRangeTooSmallError
8B25 ValInvertedError
8B2B RangeValidationError
8B2F RangeValidationEnd
8B33 ResetErrorPointer
8B3B SkipSpaces
8B3C SkipSpacesLoop
8B47 SkipSpacesEnd
8B49 BASIC
8B52 ColdOrWarm
8B58 CheckIfCold
8B65 CheckIfWarm
8B72 SignOnMsg
8BCE COLD
8BD9 CSTART
8BE0 INIT
8BE8 COPYY
8BFD MSIZE
8C10 MLOOP
8C22 TSTMEM
8C34 SETTOP
8C6C WARM
8C6F BRKRET
8C75 BFREE
8C84 SIGNON
8CBA MEMMSG
8CC5 FNCTAB
8CFD WORDS
8E20 WORDTB
8E6C PRITAB
8E81 ERRORS
8EAB INITAB
8F0B INITBE
8F0B ERRMSG
8F12 INMSG
8F16 ZERBYT
8F17 OKMSG
8F1D BRKMSG
8F23 BAKSTK
8F27 LOKFOR
8F3D INDFND
8F46 MOVUP
8F49 MOVSTR
8F4C MOVLP
8F57 CHKSTK
8F60 ENFMEM
8F6F OMERR
8F74 DATSNR
8F7A SNERR
8F7D DZERR
8F80 NFERR
8F83 DDERR
8F86 UFERR
8F89 OVERR
8F8C TMERR
8F8E ERROR
8FAE ERRIN
8FC4 POPNOK
8FC5 PRNTOK
8FD2 GETCMD
900B LINFND
9013 SFTPRG
9022 INEWLN
9041 MOVBUF
9049 SETPTR
904E PTRLP
905A FNDEND
9066 SRCHLN
9069 SRCHLP
9086 NEW
9087 CLRPTR
9092 RUNFST
9096 INTVAR
90AC CLREG
90C5 DOAGN
90C9 PROMPT
90D6 CRUNCH
90DF CRNCLP
9109 FNDWRD
9122 SEARCH
9124 GETNXT
9134 NXTBYT
9145 NOSPC
914E NOCHNG
9156 MATCH
915A RETNAD
915E MOVDIR
916C SETLIT
916F TSTREM
9175 NXTCHR
917E CPYLIT
9185 ENDBUF
918E DODEL
91A2 ECHDEL
91AE DELCHR
91B6 OTKLN
91B9 KILIN
91BF TTYLIN
91BF GETLIN
91C8 MORINP
91E1 PROCES
9220 PUTBUF
9225 PUTCTL
9234 OUTIT
923A OUTNBS
9242 CPDEHL
9248 CHKSYN
9253 OUTC
9273 INCLEN
9277 DINPOS
927D CLOTST
928E LISTT
929A LISTLP
92BA LSTLP2
92BD LSTLP3
92CC FNDTOK
92D6 OUTWRD
92E4 SETLIN
92ED COUNT
9310 RSLNBK
9319 FOR
932D FORSLP
9349 FORFND
9385 SAVSTP
938E PUTFID
9392 RUNCNT
93B2 EXCUTE
93B9 IFJMP
93BA ONJMP
93D2 GETCHR
93E2 RESTOR
93F7 RESTNL
93F8 UPDATA
93FD TSTBRK
940C STALL
9418 BRK
941D STOPP
941F PEND
9424 INPBRK
9427 ENDPRG
943A NOLIN
944B CONT
945E NULLL
9466 ACCSUM
9473 CHKLTR
947B FPSINT
947E POSINT
9481 DEPINT
9487 DEINT
949C FCERR
94A1 ATOH
94A2 GETLN
94A5 GTLNLP
94C6 CLEAR
94E9 STORED
950C RUN
9518 GOSUB
9528 RUNLIN
9529 GOTO
9542 ULERR
9547 RETURN
9566 RETLIN
956B NXTDTA
956C DATAA
956E REM
9572 NXTSTL
9575 NXTSTT
9583 LET
959E LETSTR
95C5 CRESTR
95CD MVSTPT
95D6 LETNUM
95DD ON
95EC ONGO
95ED ONGOLP
95FB IFF
9609 IFGO
961B MRPRNT
961F PRINTT
9622 PRNTLP
9665 PRNTNB
9669 PRNTST
9670 STTLIN
9678 ENDINP
9680 DONULL
9687 NULLP
9692 DOCOM
96A0 ZONELP
96A9 DOTAB
96BC DOSPC
96C1 ASPCS
96C5 SPCLP
96CC NEXITM
96D3 REDO
96E6 BADINP
96F7 INPUT
9711 NOPMPT
9726 READ
972B NXTITM
9733 NEDMOR
9737 GTVLUS
975F ANTVLU
977A ITMSEP
977D STRENT
9789 INPBIN
9794 LTSTND
97A0 MORDT
97BB EXTIG
97CC FDTLP
97E5 FANDT
97F0 NEXT
97F3 NEXT1
982B KILFOR
983B GETNUM
983E TSTNUM
983F TSTSTR
9840 CHKTYP
9849 OPNPAR
984D EVAL
9850 EVAL1
9859 EVAL2
985C EVAL3
9869 RLTLP
9885 FOPRND
98AD STKTHS
98C4 OPRND
98EF NOTAMP
9912 EVLPAR
991A MINUS
9926 RETNUM
992B CONVAR
992E FRMEVL
993C FNOFST
9963 FNVAL
996B GOFUNC
9974 SGNEXP
9984 POR
9985 PAND
99A7 POR1
99AC TSTRED
99BE CMPLOG
99C0 CMPLG1
99EA CMPSTR
9A02 CMPRES
9A0C EVNOT
9A23 DIMRET
9A2C DIM
9A31 GETVAR
9A36 GTFNAM
9A4D SVNAM2
9A4E ENDNAM
9A5A CHARTY
9A69 NOTSTR
9A79 NSCFOR
9A93 FNDVAR
9AA1 FNTHR
9AAC CFEVAL
9AD2 ZEROLP
9AE0 RETADR
9AE3 RETNUL
9AEE SBSCPT
9AF4 SCPTLP
9B16 ARLDSV
9B1C FNDARY
9B30 NXTARY
9B49 BSERR
9B4E CREARY
9B69 CRARLP
9B71 DEFSIZ
9B8F ZERARY
9BAC FINDEL
9BB1 FNDELP
9BD0 ENDDIM
9BD4 FRE
9BF0 FRENUM
9BF5 ACPASS
9BF6 ABPASS
9C02 POS
9C05 PASSA
9C0A DEF
9C37 DOFN
9C7F IDTEST
9C8D CHEKFN
9C9E STRR
9CA4 STR1
9CAE SAVSTR
9CC3 MKTMST
9CC6 CRTMST
9CCC SVSTAD
9CD2 CRTST
9CD3 QTSTR
9CD6 DTSTR
9CD9 QTSTLP
9CE8 CRTSTE
9CF4 TSTOPL
9D13 PRNUMS
9D14 PRS
9D17 PRS1
9D1E PRSLP
9D2D TESTR
9D2F GRBDON
9D49 POPAF
9D4B TESTOS
9D57 GARBGE
9D5A GARBLP
9D68 GRBLP
9D79 SMPVAR
9D8E GNXARY
9D8F ARRLP
9DAE GRBARY
9DBC STPOOL
9DBF STRADD
9DE5 SCNEND
9E0A CONCAT
9E41 SSTSA
9E4A TOSTRA
9E4B TSALP
9E54 GETSTR
9E57 GSTRCU
9E5A GSTRHL
9E5B GSTRDE
9E73 POPHL
9E75 BAKTMP
9E86 LEN
9E8A GETLEN
9E95 ASCC
9E99 GTFLNM
9EA6 CHR
9EB2 TOPOOL
9EB6 LEFT
9EBA RIGHT1
9EBC MID1
9EC4 ALLFOL
9EE6 RIGHT
9EF0 MID
9F09 RSTSTR
9F20 VAL
9F3E VAL1
9F48 VAL2
9F4B VAL3
9F4F LFRGNM
9F54 MIDNUM
9F59 INP
9F65 POUT
9F6B WAIT
9F7F NOXOR
9F80 WAITLP
9F89 SETIO
9F99 FNDNUM
9F9C GETINT
9F9F MAKINT
9FAD PEEK
9FB4 POKE
9FC5 ROUND
9FC8 ADDPHL
9FCE SUBPHL
9FD2 PSUB
9FD4 SUBCDE
9FD7 FPADD
9FF1 NOSWAP
A017 MINCDE
A025 CONPOS
A028 BNORM
A02B BNRMLP
A03D RESZER
A03E SAVEXP
A042 NORMAL
A04A PNORM
A05D RONDUP
A05E RONDB
A06F FPROND
A07C PLUCDE
A088 COMPL
A09C SCALE
A09E SCALLP
A0AB SHRITE
A0AE SHRLP
A0B2 SHRT1
A0C0 UNITY
A0C4 LOGTAB
A0D1 LOG
A109 MULLN2
A110 MULTT
A112 FPMULT
A134 MULT8
A13D MUL8LP
A14E NOMADD
A15E POPHRT
A160 BYTSFT
A165 DIV10
A171 DIV
A173 DVBCDE
A198 DIVLP
A1AB RESDIV
A1DB ADDEXP
A1F9 OVTST1
A1FE OVTST2
A1FF OVTST3
A206 MLSP10
A21D TSTSGN
A226 RETREL
A228 FLGDIF
A22C SGN
A22F FLGREL
A234 RETINT
A242 ABS
A246 INVSGN
A24E STAKFP
A25B PHLTFP
A25E FPBCDE
A269 BCDEFP
A26C LOADFP
A273 INCHL
A275 FPTHL
A278 DETHL4
A27A DETHLB
A283 SIGNS
A298 CMPNUM
A2B2 CMPFP
A2C5 FPINT
A2E9 DCBCDE
A2F0 INT
A309 MLDEBC
A311 MLDBLP
A31F NOMLAD
A324 ASCTFP
A330 CNVNUM
A338 MANLP
A34E EXPLP
A35C DPOINT
A360 CONEXP
A363 SCALMI
A36F ENDCON
A379 SCALPL
A37A MULTEN
A381 ADDIG
A398 RSCALE
A39E PADD
A3A3 EDIGIT
A3AF LINEIN
A3B7 PRNTHL
A3C2 NUMASC
A3D0 SPCFST
A3DF SIXDIG
A3F4 GTSIXD
A3FD INRNG
A419 MAKNUM
A42A DIGTXT
A439 TRYAGN
A45E SUPTLZ
A46A DOEBIT
A47A OUTEXP
A47C EXPTEN
A486 JSTZER
A489 NOENED
A48C RNGTST
A49B HALF
A49F POWERS
A4B1 NEGAFT
A4B6 SQR
A4BF POWER
A4CF POWER1
A4EC POWER2
A504 EXPP
A544 EXPTAB
A565 SUMSER
A574 SMSER1
A57D SUMLP
A595 RND
A5D1 RND1
A5ED RND2
A5F6 RESEED
A5FE RNDTAB
A60A COS
A610 SIN
A640 SIN1
A654 HALFPI
A658 QUARTR
A65C SINTAB
A671 TAN
A686 ATN
A6A3 ATN1
A6AD ATNTAB
A6D2 ARET
A6D3 GETINP
A6D7 CLS
A6DA WIDTH
A6E2 LINES
A6F1 DEEK
A6FC DOKE
A713 HEX
A72C HEX1
A72E HEX2
A73C HEX3
A73E HEX4
A74B BYT2ASC
A754 ADD30
A768 ADD301
A76C HEXTFP
A778 HEXLP
A77D HEXLP1
A785 GETHEX
A798 NOSUB7
A79C HEXIT
A7A5 HXERR
A7AA BIN
A7B0 BIN2
A7B6 ZEROSUP
A7C4 BITOUT
A7C8 BITOUT2
A7DC BINTFP
A7E6 BINIT
A7F9 CHKBIN
A807 BINERR
A80C JJUMP1
A813 MONOUT
A816 MONITR
A819 INITST
A821 ARETN
A823 TSTBIT
A82A OUTNCR
A830 EXIT
A833 BootMsg
A8BC CommandList
A936 ListOfCommands
AB9B FlagBits
ABA1 ClearScreenSeq
ABAE SysInfoMsg
AC75 ParseInvalidErr
AC9B InvalidHexDigitErr
ACC4 TooManyDigitsErr
ACED MissingParameterErr
AD04 UnrecognizedParamErr
AD1D StartGreaterEndErr
AD3E IntelHexUnsupportedErr
AD58 InvalidVectorRangeErr
AD75 ReservedBiosAreaErr
AD8B RangeTooSmallErr
ADA8 InvalidBankNumberErr
ADC6 InvalidDecimalNumberErr
ADDF NumberOutOfRangeErr
ADF8 BadMemory1Err
AE02 BadMemory2Err
AE15 NothingToCopyErr
AE27 TestingBankNumberMsg
AE3A TestingHighRamMsg
AE4D MemoryTestPassedMsg
AE62 RangeMsg
AE71 IntelHexFinishedMsg
AE81 IntelHexSuccessMsg
AE90 IntelHexLoadMsg
AECD IntelHexAbortedMsg
AEE8 DownloadedBytesMsg
AEFC FillHelp
AF67 HexDumpHelp
AFCC IntelHexHelp
B00F Range
B018 InvalidVectorRange
B021 RangeTooSmall
B02A BiosRange
B033 RangeInverted
B03C NoParameter
B048 InvalidBank
B051 TooManyDigits
B05A InvalidHexDigit
B063 NumberOutOfRange
B06C InvalidDecimalNumber
B075 NothingToCopy
B084 CommandBuffer
B0AC BufferPointer
B0AE CmdErrorPointer
B0AF CurrentBank
B0B0 CurrentAddress
B0B2 CurrentPort
B0B3 DigitString
B0BC ParseSaveHL
B0BE RegA
B0BF RegBC
B0C1 RegDE
B0C3 RegHL
B0C5 RegIX
B0C7 RegIY
B0C9 StackPtr
B0CB FlagsReg
B0CC StartAddress
B0CE EndAddress
B0D0 StartAddressAlt
B0D2 EndAddressAlt
B0D4 ByteTransfer
B0D5 UserCodeSize
B0D7 EndOfCode
CBA9 BytesFree
FD00 VectorTable
FD00 IntVectorEnd
FD02 VectorTableStart
FD04 CodeStartAddr
FD06 CodeEndAddr
FE00 JumpTable
FE3F VectorEnd
FF00 StackPage
FFFF BiosEnd
